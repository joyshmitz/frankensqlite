<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light" />
    <title>FrankenSQLite Spec Evolution</title>

    <!-- OpenGraph -->
    <meta property="og:title" content="FrankenSQLite Spec Evolution" />
    <meta property="og:description" content="Interactive visualization of 137 commits across 12 deep sessions building a 10,791-line comprehensive database specification. MVCC page-level versioning, RaptorQ erasure coding, SSI concurrency control." />
    <meta property="og:image" content="https://frankensqlite.com/og-image.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:url" content="https://frankensqlite.com" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="FrankenSQLite" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="FrankenSQLite Spec Evolution" />
    <meta name="twitter:description" content="137 commits · 10,791 lines · 12 sessions of deep architectural design for a clean-room Rust reimplementation of SQLite with MVCC." />
    <meta name="twitter:image" content="https://frankensqlite.com/twitter-image.png" />

    <!-- General meta -->
    <meta name="description" content="Interactive visualization tracking the evolution of the FrankenSQLite specification across 137 commits — from initial architecture through MVCC, RaptorQ erasure coding, and SSI concurrency control." />

    <!-- Typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,350..900&family=Manrope:wght@200..800&display=swap"
      rel="stylesheet"
    />

    <!-- Tailwind (precompiled) -->
    <!-- Generated from this HTML via tailwindcss CLI to avoid runtime JIT cost (huge perf win vs https://cdn.tailwindcss.com). -->
    <style id="tw">
      *,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/*! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com*/*,:after,:before{box-sizing:border-box;border:0 solid #e5e7eb}:after,:before{--tw-content:""}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:Manrope,ui-sans-serif,system-ui,sans-serif;font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.\\!container{width:100%!important}.container{width:100%}@media (min-width:640px){.\\!container{max-width:640px!important}.container{max-width:640px}}@media (min-width:768px){.\\!container{max-width:768px!important}.container{max-width:768px}}@media (min-width:1024px){.\\!container{max-width:1024px!important}.container{max-width:1024px}}@media (min-width:1280px){.\\!container{max-width:1280px!important}.container{max-width:1280px}}@media (min-width:1536px){.\\!container{max-width:1536px!important}.container{max-width:1536px}}.visible{visibility:visible}.collapse{visibility:collapse}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.inset-0{inset:0}.inset-x-0{left:0;right:0}.bottom-0{bottom:0}.left-0{left:0}.right-0{right:0}.top-0{top:0}.top-full{top:100%}.z-10{z-index:10}.z-30{z-index:30}.z-40{z-index:40}.z-50{z-index:50}.mx-auto{margin-left:auto;margin-right:auto}.mb-2{margin-bottom:.5rem}.ml-1{margin-left:.25rem}.ml-2{margin-left:.5rem}.ml-auto{margin-left:auto}.mr-1\\.5{margin-right:.375rem}.mt-0\\.5{margin-top:.125rem}.mt-1{margin-top:.25rem}.mt-1\\.5{margin-top:.375rem}.mt-2{margin-top:.5rem}.mt-3{margin-top:.75rem}.mt-4{margin-top:1rem}.mt-5{margin-top:1.25rem}.mt-6{margin-top:1.5rem}.mt-7{margin-top:1.75rem}.mt-8{margin-top:2rem}.block{display:block}.inline-block{display:inline-block}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.table{display:table}.grid{display:grid}.\\!hidden{display:none!important}.hidden{display:none}.h-1\\.5{height:.375rem}.h-2{height:.5rem}.h-2\\.5{height:.625rem}.h-5{height:1.25rem}.h-6{height:1.5rem}.max-h-\\[70vh\\]{max-height:70vh}.min-h-0{min-height:0}.w-10{width:2.5rem}.w-16{width:4rem}.w-2{width:.5rem}.w-2\\.5{width:.625rem}.w-20{width:5rem}.w-40{width:10rem}.w-5{width:1.25rem}.w-56{width:14rem}.w-6{width:1.5rem}.w-64{width:16rem}.w-72{width:18rem}.w-full{width:100%}.min-w-0{min-width:0}.min-w-\\[3\\.5rem\\]{min-width:3.5rem}.max-w-\\[1200px\\]{max-width:1200px}.max-w-\\[240px\\]{max-width:240px}.max-w-\\[260px\\]{max-width:260px}.max-w-\\[70ch\\]{max-width:70ch}.flex-1{flex:1 1 0%}.flex-shrink,.shrink{flex-shrink:1}.shrink-0{flex-shrink:0}.border-collapse{border-collapse:collapse}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.cursor-col-resize{cursor:col-resize}.cursor-pointer{cursor:pointer}.resize{resize:both}.list-none{list-style-type:none}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.items-start{align-items:flex-start}.items-end{align-items:flex-end}.items-center{align-items:center}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-1{gap:.25rem}.gap-1\\.5{gap:.375rem}.gap-2{gap:.5rem}.gap-3{gap:.75rem}.gap-4{gap:1rem}.gap-6{gap:1.5rem}.gap-px{gap:1px}.space-y-1>:not([hidden])~:not([hidden]){--tw-space-y-reverse:0;margin-top:calc(.25rem*(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.25rem*var(--tw-space-y-reverse))}.space-y-2>:not([hidden])~:not([hidden]){--tw-space-y-reverse:0;margin-top:calc(.5rem*(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem*var(--tw-space-y-reverse))}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.overflow-y-auto{overflow-y:auto}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.rounded{border-radius:.25rem}.rounded-2xl{border-radius:1rem}.rounded-3xl{border-radius:1.5rem}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:.5rem}.rounded-xl{border-radius:.75rem}.rounded-t-3xl{border-top-left-radius:1.5rem;border-top-right-radius:1.5rem}.border{border-width:1px}.border-b{border-bottom-width:1px}.border-t{border-top-width:1px}.border-blue-200{--tw-border-opacity:1;border-color:rgb(191 219 254/var(--tw-border-opacity,1))}.border-blue-400{--tw-border-opacity:1;border-color:rgb(96 165 250/var(--tw-border-opacity,1))}.border-rose-300{--tw-border-opacity:1;border-color:rgb(253 164 175/var(--tw-border-opacity,1))}.border-slate-100{--tw-border-opacity:1;border-color:rgb(241 245 249/var(--tw-border-opacity,1))}.border-slate-200{--tw-border-opacity:1;border-color:rgb(226 232 240/var(--tw-border-opacity,1))}.border-slate-900\\/10{border-color:rgba(15,23,42,.1)}.bg-amber-50{--tw-bg-opacity:1;background-color:rgb(255 251 235/var(--tw-bg-opacity,1))}.bg-blue-100{--tw-bg-opacity:1;background-color:rgb(219 234 254/var(--tw-bg-opacity,1))}.bg-blue-50\\/60{background-color:rgba(239,246,255,.6)}.bg-blue-50\\/80{background-color:rgba(239,246,255,.8)}.bg-blue-500{--tw-bg-opacity:1;background-color:rgb(59 130 246/var(--tw-bg-opacity,1))}.bg-emerald-50{--tw-bg-opacity:1;background-color:rgb(236 253 245/var(--tw-bg-opacity,1))}.bg-emerald-600{--tw-bg-opacity:1;background-color:rgb(5 150 105/var(--tw-bg-opacity,1))}.bg-red-50{--tw-bg-opacity:1;background-color:rgb(254 242 242/var(--tw-bg-opacity,1))}.bg-rose-50{--tw-bg-opacity:1;background-color:rgb(255 241 242/var(--tw-bg-opacity,1))}.bg-slate-100{--tw-bg-opacity:1;background-color:rgb(241 245 249/var(--tw-bg-opacity,1))}.bg-slate-200{--tw-bg-opacity:1;background-color:rgb(226 232 240/var(--tw-bg-opacity,1))}.bg-slate-200\\/80{background-color:rgba(226,232,240,.8)}.bg-slate-300{--tw-bg-opacity:1;background-color:rgb(203 213 225/var(--tw-bg-opacity,1))}.bg-slate-900{--tw-bg-opacity:1;background-color:rgb(15 23 42/var(--tw-bg-opacity,1))}.bg-slate-900\\/30{background-color:rgba(15,23,42,.3)}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255/var(--tw-bg-opacity,1))}.bg-white\\/60{background-color:hsla(0,0%,100%,.6)}.bg-white\\/70{background-color:hsla(0,0%,100%,.7)}.bg-white\\/80{background-color:hsla(0,0%,100%,.8)}.bg-white\\/90{background-color:hsla(0,0%,100%,.9)}.bg-white\\/95{background-color:hsla(0,0%,100%,.95)}.p-0\\.5{padding:.125rem}.p-2{padding:.5rem}.p-3{padding:.75rem}.p-4{padding:1rem}.p-5{padding:1.25rem}.px-1{padding-left:.25rem;padding-right:.25rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-2\\.5{padding-left:.625rem;padding-right:.625rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-3\\.5{padding-left:.875rem;padding-right:.875rem}.px-4{padding-left:1rem;padding-right:1rem}.px-5{padding-left:1.25rem;padding-right:1.25rem}.py-0\\.5{padding-top:.125rem;padding-bottom:.125rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-1\\.5{padding-top:.375rem;padding-bottom:.375rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.py-2\\.5{padding-top:.625rem;padding-bottom:.625rem}.py-3{padding-top:.75rem;padding-bottom:.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.py-6{padding-top:1.5rem;padding-bottom:1.5rem}.pb-1{padding-bottom:.25rem}.pb-28{padding-bottom:7rem}.pt-10{padding-top:2.5rem}.pt-3{padding-top:.75rem}.pt-4{padding-top:1rem}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}.font-display{font-family:Fraunces,ui-serif,Georgia,serif}.font-mono{font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.text-2xl{font-size:1.5rem;line-height:2rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-\\[10px\\]{font-size:10px}.text-\\[11px\\]{font-size:11px}.text-base{font-size:1rem;line-height:1.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xs{font-size:.75rem;line-height:1rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.italic{font-style:italic}.leading-\\[1\\.05\\]{line-height:1.05}.leading-relaxed{line-height:1.625}.leading-snug{line-height:1.375}.leading-tight{line-height:1.25}.text-amber-600{--tw-text-opacity:1;color:rgb(217 119 6/var(--tw-text-opacity,1))}.text-amber-700{--tw-text-opacity:1;color:rgb(180 83 9/var(--tw-text-opacity,1))}.text-blue-600{--tw-text-opacity:1;color:rgb(37 99 235/var(--tw-text-opacity,1))}.text-blue-700{--tw-text-opacity:1;color:rgb(29 78 216/var(--tw-text-opacity,1))}.text-blue-800{--tw-text-opacity:1;color:rgb(30 64 175/var(--tw-text-opacity,1))}.text-blue-900{--tw-text-opacity:1;color:rgb(30 58 138/var(--tw-text-opacity,1))}.text-emerald-600{--tw-text-opacity:1;color:rgb(5 150 105/var(--tw-text-opacity,1))}.text-emerald-700{--tw-text-opacity:1;color:rgb(4 120 87/var(--tw-text-opacity,1))}.text-red-500{--tw-text-opacity:1;color:rgb(239 68 68/var(--tw-text-opacity,1))}.text-red-600{--tw-text-opacity:1;color:rgb(220 38 38/var(--tw-text-opacity,1))}.text-red-700{--tw-text-opacity:1;color:rgb(185 28 28/var(--tw-text-opacity,1))}.text-rose-700{--tw-text-opacity:1;color:rgb(190 18 60/var(--tw-text-opacity,1))}.text-slate-300{--tw-text-opacity:1;color:rgb(203 213 225/var(--tw-text-opacity,1))}.text-slate-400{--tw-text-opacity:1;color:rgb(148 163 184/var(--tw-text-opacity,1))}.text-slate-500{--tw-text-opacity:1;color:rgb(100 116 139/var(--tw-text-opacity,1))}.text-slate-600{--tw-text-opacity:1;color:rgb(71 85 105/var(--tw-text-opacity,1))}.text-slate-700{--tw-text-opacity:1;color:rgb(51 65 85/var(--tw-text-opacity,1))}.text-slate-900{--tw-text-opacity:1;color:rgb(15 23 42/var(--tw-text-opacity,1))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255/var(--tw-text-opacity,1))}.underline{text-decoration-line:underline}.no-underline{text-decoration-line:none}.placeholder-slate-400::-moz-placeholder{--tw-placeholder-opacity:1;color:rgb(148 163 184/var(--tw-placeholder-opacity,1))}.placeholder-slate-400::placeholder{--tw-placeholder-opacity:1;color:rgb(148 163 184/var(--tw-placeholder-opacity,1))}.shadow-2xl{--tw-shadow:0 25px 50px -12px rgba(0,0,0,.25);--tw-shadow-colored:0 25px 50px -12px var(--tw-shadow-color)}.shadow-2xl,.shadow-glow{box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.shadow-glow{--tw-shadow:0 0 0 1px rgba(15,23,42,.06),0 10px 30px rgba(2,6,23,.1);--tw-shadow-colored:0 0 0 1px var(--tw-shadow-color),0 10px 30px var(--tw-shadow-color)}.shadow-glowLg{--tw-shadow:0 0 0 1px rgba(15,23,42,.06),0 24px 60px rgba(2,6,23,.16);--tw-shadow-colored:0 0 0 1px var(--tw-shadow-color),0 24px 60px var(--tw-shadow-color)}.shadow-glowLg,.shadow-sm{box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 2px 0 rgba(0,0,0,.05);--tw-shadow-colored:0 1px 2px 0 var(--tw-shadow-color)}.\\!outline{outline-style:solid!important}.outline{outline-style:solid}.ring{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.blur{--tw-blur:blur(8px)}.blur,.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop-blur{--tw-backdrop-blur:blur(8px)}.backdrop-blur,.backdrop-blur-sm{-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.backdrop-blur-sm{--tw-backdrop-blur:blur(4px)}.backdrop-blur-xl{--tw-backdrop-blur:blur(24px)}.backdrop-blur-xl,.backdrop-filter{-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.backdrop-filter{-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.placeholder\\:text-slate-400::-moz-placeholder{--tw-text-opacity:1;color:rgb(148 163 184/var(--tw-text-opacity,1))}.placeholder\\:text-slate-400::placeholder{--tw-text-opacity:1;color:rgb(148 163 184/var(--tw-text-opacity,1))}.hover\\:bg-blue-100:hover{--tw-bg-opacity:1;background-color:rgb(219 234 254/var(--tw-bg-opacity,1))}.hover\\:bg-rose-100:hover{--tw-bg-opacity:1;background-color:rgb(255 228 230/var(--tw-bg-opacity,1))}.hover\\:bg-slate-100\\/60:hover{background-color:rgba(241,245,249,.6)}.hover\\:bg-slate-400:hover{--tw-bg-opacity:1;background-color:rgb(148 163 184/var(--tw-bg-opacity,1))}.hover\\:bg-slate-50:hover{--tw-bg-opacity:1;background-color:rgb(248 250 252/var(--tw-bg-opacity,1))}.hover\\:bg-slate-50\\/60:hover{background-color:rgba(248,250,252,.6)}.hover\\:bg-slate-800:hover{--tw-bg-opacity:1;background-color:rgb(30 41 59/var(--tw-bg-opacity,1))}.hover\\:bg-white:hover{--tw-bg-opacity:1;background-color:rgb(255 255 255/var(--tw-bg-opacity,1))}.hover\\:text-slate-900:hover{--tw-text-opacity:1;color:rgb(15 23 42/var(--tw-text-opacity,1))}.hover\\:brightness-95:hover{--tw-brightness:brightness(.95);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.focus\\:border-slate-400:focus{--tw-border-opacity:1;border-color:rgb(148 163 184/var(--tw-border-opacity,1))}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}@media (min-width:640px){.sm\\:hidden{display:none}.sm\\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.sm\\:grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.sm\\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}.sm\\:flex-row{flex-direction:row}.sm\\:flex-wrap{flex-wrap:wrap}.sm\\:items-start{align-items:flex-start}.sm\\:items-end{align-items:flex-end}.sm\\:items-center{align-items:center}.sm\\:justify-between{justify-content:space-between}.sm\\:px-6{padding-left:1.5rem;padding-right:1.5rem}.sm\\:px-7{padding-left:1.75rem;padding-right:1.75rem}.sm\\:py-7{padding-top:1.75rem;padding-bottom:1.75rem}.sm\\:text-5xl{font-size:3rem;line-height:1}.sm\\:text-lg{font-size:1.125rem;line-height:1.75rem}}@media (min-width:768px){.md\\:grid-cols-5{grid-template-columns:repeat(5,minmax(0,1fr))}}@media (min-width:1024px){.lg\\:block{display:block}.lg\\:grid{display:grid}.lg\\:grid-cols-\\[1fr_360px\\]{grid-template-columns:1fr 360px}.lg\\:grid-cols-\\[360px_1fr\\]{grid-template-columns:360px 1fr}.lg\\:flex-row{flex-direction:row}.lg\\:items-end{align-items:flex-end}.lg\\:justify-end{justify-content:flex-end}.lg\\:justify-between{justify-content:space-between}.lg\\:p-5{padding:1.25rem}.lg\\:px-10{padding-left:2.5rem;padding-right:2.5rem}.lg\\:px-8{padding-left:2rem;padding-right:2rem}.lg\\:py-10{padding-top:2.5rem;padding-bottom:2.5rem}}@media (min-width:1280px){.xl\\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}}
    </style>

    <!-- Code highlighting -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css"
    />

    <style>
      :root {
        /* Surfaces */
        --bg0: #fbfbfe;
        --bg1: #f6f7ff;
        --card: rgba(255, 255, 255, 0.82);
        --card2: rgba(255, 255, 255, 0.7);
        --stroke: rgba(2, 6, 23, 0.10);
        --stroke2: rgba(2, 6, 23, 0.07);

        /* Ink */
        --ink0: #0b1220;
        --ink1: rgba(2, 6, 23, 0.80);
        --ink2: rgba(2, 6, 23, 0.62);
        --ink3: rgba(2, 6, 23, 0.46);

        /* Brand-ish gradient */
        --a0: rgba(37, 99, 235, 0.14);
        --a1: rgba(219, 39, 119, 0.10);
        --a2: rgba(20, 184, 166, 0.10);
        --a3: rgba(217, 119, 6, 0.10);

        /* Category colors (10 buckets) */
        --c1: #2563eb; /* logic/math */
        --c2: #d97706; /* sqlite legacy */
        --c3: #059669; /* asupersync */
        --c4: #dc2626; /* architecture mistakes */
        --c5: #64748b; /* scrivening */
        --c6: #db2777; /* background/context */
        --c7: #0ea5e9; /* standard eng perf */
        --c8: #7c3aed; /* alien math */
        --c9: #16a34a; /* clarification */
        --c10: #0f172a; /* other */

        --ring: rgba(37, 99, 235, 0.35);
      }

      html,
      body {
        height: 100%;
      }

      body {
        font-family: Manrope, system-ui, -apple-system, Segoe UI, sans-serif;
        color: var(--ink0);
        background: radial-gradient(1200px 700px at 10% -10%, var(--a0), transparent 60%),
          radial-gradient(900px 600px at 95% 5%, var(--a1), transparent 58%),
          radial-gradient(1100px 700px at 40% 110%, var(--a2), transparent 60%),
          radial-gradient(1100px 650px at 100% 85%, var(--a3), transparent 56%),
          linear-gradient(180deg, var(--bg0), var(--bg1));
        background-attachment: fixed;
      }

      /* Subtle noise */
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        pointer-events: none;
        opacity: 0.035;
        mix-blend-mode: multiply;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='320' height='320'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='320' height='320' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
      }

      .glass {
        background: var(--card);
        border: 1px solid var(--stroke);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
      }

      .glass-2 {
        background: var(--card2);
        border: 1px solid var(--stroke2);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
      }

      .focus-ring:focus {
        outline: none;
        box-shadow: 0 0 0 4px var(--ring);
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          animation: none !important;
          transition: none !important;
          scroll-behavior: auto !important;
        }
      }

      .enter {
        animation: enter 700ms cubic-bezier(0.2, 1, 0.2, 1) both;
      }
      @keyframes enter {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .chip {
        border: 1px solid var(--stroke2);
        background: rgba(255, 255, 255, 0.7);
      }

      .codebox {
        background: rgba(15, 23, 42, 0.03);
        border: 1px solid rgba(2, 6, 23, 0.10);
      }

      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
      }

      /* Mobile bottom sheet */
      .sheet {
        transform: translateY(12px);
        opacity: 0;
        transition: transform 200ms ease, opacity 200ms ease;
        will-change: transform, opacity;
      }
      .sheet.open {
        transform: translateY(0);
        opacity: 1;
      }

      /* ECharts container should not shrink weirdly */
      .chart {
        min-height: 280px;
        contain: content;
      }

      @media (max-width: 639px) {
        .glass,
        .glass-2 {
          backdrop-filter: blur(8px);
          -webkit-backdrop-filter: blur(8px);
        }
        .chart {
          min-height: 320px;
        }
        #docMain:not(.hidden) {
          display: flex;
          flex-direction: column;
        }
        #docMain > aside {
          order: -1;
        }
      }

      #commitList {
        contain: content;
      }

      /* Section summary heading highlight */
      @keyframes section-flash {
        0% { background-color: rgba(59, 130, 246, 0.25); }
        100% { background-color: transparent; }
      }
      .section-highlight {
        animation: section-flash 1.2s ease-out;
      }

      /* Section summary table */
      #sectionTable th {
        cursor: pointer;
        user-select: none;
      }
      #sectionTable th:hover {
        color: var(--ink0);
      }
      #sectionTable .sparkline-bar {
        display: inline-block;
        min-width: 2px;
        border-radius: 1px;
        vertical-align: middle;
      }

      /* Markdown rendering (hand-rolled; avoids tailwind/typography plugin dependency) */
      .md {
        color: rgba(2, 6, 23, 0.82);
        font-size: 15px;
        line-height: 1.75;
      }
      .md h1,
      .md h2,
      .md h3,
      .md h4 {
        font-family: Fraunces, ui-serif, Georgia, serif;
        color: rgba(2, 6, 23, 0.92);
        letter-spacing: -0.01em;
      }
      .md h1 {
        font-size: 28px;
        line-height: 1.15;
        margin: 18px 0 10px;
      }
      .md h2 {
        font-size: 22px;
        line-height: 1.2;
        margin: 18px 0 8px;
      }
      .md h3 {
        font-size: 18px;
        line-height: 1.25;
        margin: 14px 0 6px;
      }
      .md p {
        margin: 10px 0;
      }
      .md ul,
      .md ol {
        margin: 10px 0 10px 18px;
      }
      .md li {
        margin: 4px 0;
      }
      .md code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
        font-size: 0.92em;
        padding: 0.12em 0.36em;
        border: 1px solid rgba(2, 6, 23, 0.10);
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.04);
      }
      .md pre code {
        display: block;
        padding: 0;
        border: none;
        background: transparent;
        font-size: 12px;
        line-height: 1.6;
      }
      .md pre {
        margin: 12px 0;
        padding: 12px 14px;
        border-radius: 18px;
        overflow: auto;
        border: 1px solid rgba(2, 6, 23, 0.10);
        background: rgba(15, 23, 42, 0.03);
      }
      .md a {
        color: rgb(37, 99, 235);
        text-decoration: none;
      }
      .md a:hover {
        text-decoration: underline;
      }
      .md table {
        width: 100%;
        border-collapse: collapse;
        margin: 12px 0;
        font-size: 13px;
      }
      .md th,
      .md td {
        border: 1px solid rgba(2, 6, 23, 0.10);
        padding: 8px 10px;
        vertical-align: top;
      }
      .md th {
        background: rgba(15, 23, 42, 0.03);
        font-weight: 800;
      }
      .md blockquote {
        margin: 12px 0;
        padding: 10px 12px;
        border-left: 3px solid rgba(37, 99, 235, 0.35);
        background: rgba(37, 99, 235, 0.06);
        border-radius: 14px;
      }

      /* Bottom timeline dock */
      .dock {
        background: rgba(255, 255, 255, 0.78);
        border-top: 1px solid rgba(2, 6, 23, 0.10);
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
      }
      .dock-canvas {
        width: 100%;
        height: 40px;
        display: block;
      }
      .dock-slider {
        width: 100%;
      }
      /* Mobile Story Mode (bd-24q.4.3) */
      .story-mobile-overlay {
        position: fixed; inset: 0; z-index: 47;
        background: rgba(2,6,23,0.5); backdrop-filter: blur(6px);
        transition: opacity 0.2s;
      }
      .story-mobile-sheet {
        position: fixed; inset: 0; z-index: 48;
        background: rgba(255,255,255,0.98);
        display: flex; flex-direction: column;
        padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        transform: translateY(100%);
        transition: transform 0.3s ease-out;
      }
      .story-mobile-sheet.open { transform: translateY(0); }
      .story-mobile-card {
        display: flex; flex-direction: column;
        justify-content: center; align-items: stretch;
        flex: 1; padding: 1.5rem;
        overflow-y: auto;
      }

      /* Mobile Mini-Map Sheet (bd-24q.2.3) */
      .minimap-mobile-overlay {
        position: fixed; inset: 0; z-index: 45;
        background: rgba(2,6,23,0.3); backdrop-filter: blur(4px);
        transition: opacity 0.2s;
      }
      .minimap-mobile-sheet {
        position: fixed; top: 0; left: 0; bottom: 0; z-index: 46;
        width: min(320px, 85vw);
        background: rgba(255,255,255,0.97);
        border-right: 1px solid rgba(2,6,23,0.1);
        box-shadow: 8px 0 32px rgba(2,6,23,0.15);
        transform: translateX(-100%);
        transition: transform 0.25s ease-out;
        display: flex; flex-direction: column;
        padding: env(safe-area-inset-top) 0 env(safe-area-inset-bottom) env(safe-area-inset-left);
      }
      .minimap-mobile-sheet.open { transform: translateX(0); }

      .dock-heat-stripe {
        width: 100%;
        height: 12px;
        display: block;
        border-radius: 6px;
        cursor: pointer;
      }
      .dock-heat-tooltip {
        position: fixed;
        z-index: 50;
        pointer-events: none;
        padding: 6px 10px;
        border-radius: 10px;
        background: rgba(255,255,255,0.96);
        border: 1px solid rgba(2,6,23,0.12);
        box-shadow: 0 8px 24px rgba(2,6,23,0.14);
        font-size: 11px;
        color: #0b1220;
        line-height: 1.4;
        max-width: 240px;
        white-space: nowrap;
        transition: opacity 0.12s;
      }

      /* A/B Compare Typeahead Pickers (bd-24q.1) */
      .ab-picker {
        position: relative;
        display: inline-flex;
      }
      .ab-picker-btn {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 10px;
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 8px;
        background: white;
        font-size: 11px;
        font-weight: 600;
        color: #0f172a;
        cursor: pointer;
        max-width: 240px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        transition: border-color 150ms, box-shadow 150ms;
      }
      .ab-picker-btn:hover { border-color: rgba(59, 130, 246, 0.5); }
      .ab-picker-btn:focus { outline: none; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25); }
      .ab-picker-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        z-index: 60;
        margin-top: 4px;
        width: 340px;
        max-height: 300px;
        border: 1px solid rgba(2, 6, 23, 0.12);
        border-radius: 14px;
        background: white;
        box-shadow: 0 10px 30px rgba(2, 6, 23, 0.16);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .ab-picker-search {
        width: 100%;
        border: none;
        border-bottom: 1px solid rgba(2, 6, 23, 0.08);
        padding: 8px 12px;
        font-size: 12px;
        outline: none;
        background: transparent;
      }
      .ab-picker-search::placeholder { color: rgba(2, 6, 23, 0.4); }
      .ab-picker-list {
        flex: 1;
        overflow-y: auto;
        padding: 4px;
      }
      .ab-picker-item {
        display: flex;
        align-items: baseline;
        gap: 6px;
        padding: 6px 8px;
        border-radius: 8px;
        font-size: 11px;
        cursor: pointer;
        transition: background 100ms;
      }
      .ab-picker-item:hover,
      .ab-picker-item.keyboard-active { background: rgba(59, 130, 246, 0.08); }
      .ab-picker-item.selected { background: rgba(59, 130, 246, 0.12); font-weight: 700; }
      .ab-picker-item .idx {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        color: rgba(2, 6, 23, 0.35);
        font-size: 10px;
        min-width: 22px;
        flex-shrink: 0;
      }
      .ab-picker-item .hash {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        color: rgba(2, 6, 23, 0.5);
        font-size: 10px;
        flex-shrink: 0;
      }
      .ab-picker-item .subject {
        color: #0f172a;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        flex: 1;
        min-width: 0;
      }
      @media (max-width: 639px) {
        .ab-picker-dropdown {
          position: fixed;
          inset: 0;
          width: 100%;
          max-height: 100%;
          border-radius: 0;
          margin-top: 0;
          z-index: 100;
        }
        .ab-picker-search {
          padding: 14px 16px;
          font-size: 16px;
        }
        .ab-picker-item {
          padding: 12px 16px;
          font-size: 13px;
        }
        .ab-picker-item .idx { font-size: 11px; }
        .ab-picker-item .hash { font-size: 11px; }
        .ab-picker-dropdown::before {
          content: "";
          display: block;
          height: 4px;
          width: 36px;
          margin: 8px auto 4px;
          border-radius: 2px;
          background: rgba(2, 6, 23, 0.15);
        }
      }

      /* Search Palette (bd-24q.9.2) */
      .search-palette-overlay { position: fixed; inset: 0; z-index: 200; background: rgba(2, 6, 23, 0.35); backdrop-filter: blur(4px); display: flex; justify-content: center; padding-top: min(20vh, 160px); }
      .search-palette-overlay.hidden { display: none; } /* Override display:flex when Tailwind .hidden is applied */
      .search-palette { width: 560px; max-height: 480px; background: white; border-radius: 16px; border: 1px solid rgba(2, 6, 23, 0.12); box-shadow: 0 24px 60px rgba(2, 6, 23, 0.24); display: flex; flex-direction: column; overflow: hidden; animation: spFadeIn 120ms ease-out; }
      @keyframes spFadeIn { from { opacity: 0; transform: translateY(-8px); } to { opacity: 1; transform: translateY(0); } }
      .search-palette-input { border: none; border-bottom: 1px solid rgba(2, 6, 23, 0.08); padding: 14px 16px; font-size: 15px; font-family: inherit; outline: none; background: transparent; width: 100%; }
      .search-palette-input::placeholder { color: rgba(2, 6, 23, 0.38); }
      .search-palette-results { flex: 1; overflow-y: auto; padding: 4px; }
      .search-palette-item { display: flex; align-items: baseline; gap: 8px; padding: 8px 12px; border-radius: 10px; cursor: pointer; font-size: 13px; color: #0f172a; }
      .search-palette-item:hover, .search-palette-item.kb-active { background: rgba(59, 130, 246, 0.08); }
      .search-palette-item .sp-idx { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; color: rgba(2, 6, 23, 0.35); font-size: 11px; min-width: 24px; flex-shrink: 0; }
      .search-palette-item .sp-hash { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; color: rgba(59, 130, 246, 0.6); font-size: 11px; flex-shrink: 0; }
      .search-palette-item .sp-subject { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; min-width: 0; }
      .search-palette-item .sp-score { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; color: rgba(2, 6, 23, 0.25); font-size: 10px; flex-shrink: 0; }
      .search-palette-hint { padding: 16px; text-align: center; font-size: 12px; color: rgba(2, 6, 23, 0.4); }
      .search-palette-footer { border-top: 1px solid rgba(2, 6, 23, 0.06); padding: 6px 12px; display: flex; gap: 12px; font-size: 10px; color: rgba(2, 6, 23, 0.38); }
      .search-palette-footer kbd { display: inline-block; padding: 1px 5px; border: 1px solid rgba(2, 6, 23, 0.15); border-radius: 4px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 10px; background: rgba(2, 6, 23, 0.03); }
      @media (max-width: 639px) {
        .search-palette-overlay { padding-top: 0; align-items: stretch; }
        .search-palette { width: 100%; max-height: 100%; border-radius: 0; }
        .search-palette-input { font-size: 16px; padding: 16px; }
        .search-palette-item { padding: 12px 16px; font-size: 14px; }
      }

      /* Cluster timeline highlight (bd-24q.14.3) */
      .timeline-cluster-highlight { outline: 2px solid rgba(99, 102, 241, 0.5); outline-offset: -1px; border-radius: 8px; background: rgba(99, 102, 241, 0.08) !important; }

      /* Side-by-Side Mobile UX (bd-24q.15.3) */
      .sbs-mobile-tabs {
        display: none;
        gap: 2px;
        background: rgba(2, 6, 23, 0.06);
        border-radius: 10px;
        padding: 2px;
      }
      .sbs-mobile-tabs button {
        flex: 1;
        padding: 5px 10px;
        font-size: 11px;
        font-weight: 600;
        border-radius: 8px;
        border: none;
        background: transparent;
        color: rgba(2, 6, 23, 0.5);
        cursor: pointer;
        transition: background 100ms, color 100ms;
      }
      .sbs-mobile-tabs button.active {
        background: white;
        color: #0f172a;
        box-shadow: 0 1px 3px rgba(2, 6, 23, 0.1);
      }
      .sbs-jump-cta {
        display: none;
        position: absolute;
        bottom: 12px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        padding: 6px 14px;
        font-size: 11px;
        font-weight: 600;
        color: white;
        background: #334155;
        border: none;
        border-radius: 20px;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(2, 6, 23, 0.2);
        animation: sbsCtaIn 200ms ease-out;
      }
      @keyframes sbsCtaIn { from { opacity: 0; transform: translateX(-50%) translateY(8px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
      .sbs-jump-cta:hover { background: #1e293b; }
      @media (max-width: 639px) {
        #sbsContainer .sbs-mobile-tabs { display: flex; }
        #sbsContainer #sbsDivider { display: none; }
        #sbsContainer #sbsPaneA,
        #sbsContainer #sbsPaneB { display: none; }
        #sbsContainer .sbs-pane-visible { display: block !important; flex: 1; }
        #sbsContainer .sbs-jump-cta.visible { display: block; }
      }
      @media (max-width: 639px) and (orientation: landscape) and (min-height: 320px) {
        #sbsContainer .sbs-mobile-tabs { display: none; }
        #sbsContainer #sbsDivider { display: block; }
        #sbsContainer #sbsPaneA,
        #sbsContainer #sbsPaneB { display: block; flex: 1; }
        #sbsContainer .sbs-jump-cta { display: none !important; }
      }
      /* Safe-area insets for notched devices (bd-24q.15.3) */
      @supports (padding-bottom: env(safe-area-inset-bottom)) {
        .dock { padding-bottom: calc(12px + env(safe-area-inset-bottom)); }
        body { padding-bottom: calc(7rem + env(safe-area-inset-bottom)); }
      }
      /* Perf dev panel (bd-24q.5.3) */
      .perf-panel { position: fixed; bottom: 80px; right: 12px; z-index: 50; background: rgba(15,23,42,0.92); color: #e2e8f0; border-radius: 12px; padding: 10px 14px; font: 10px/1.4 ui-monospace, monospace; max-width: 300px; backdrop-filter: blur(8px); box-shadow: 0 4px 24px rgba(0,0,0,0.3); pointer-events: auto; }
      .perf-panel h4 { margin: 0 0 6px; font-size: 11px; font-weight: 700; color: #818cf8; }
      .perf-panel table { border-collapse: collapse; width: 100%; }
      .perf-panel td { padding: 1px 4px; }
      .perf-panel .over { color: #f87171; }
      .perf-panel .ok { color: #4ade80; }
      /* Inline highlights (bd-24q.16.1 + bd-24q.16.2) */
      .ih-changed { border-left: 3px solid #22c55e; background: rgba(34,197,94,0.06); padding-left: 6px; }
      .ih-modified { border-left: 3px solid #f59e0b; background: rgba(245,158,11,0.05); padding-left: 6px; }
      .ih-active { box-shadow: inset 0 0 0 2px rgba(37,99,235,0.35); border-radius: 4px; }
      .ih-debug { outline: 1px dashed rgba(99,102,241,0.4); outline-offset: 1px; }
      .ih-pulse { animation: ihPulse 0.6s ease-out; }
      @keyframes ihPulse { 0% { box-shadow: inset 0 0 0 2px rgba(34,197,94,0.5); } 100% { box-shadow: none; } }
      .ih-popover { position: absolute; z-index: 50; background: #fff; border: 1px solid rgba(2,6,23,0.12); border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.1); padding: 8px 12px; font-size: 11px; max-width: 280px; pointer-events: none; opacity: 0; transition: opacity 0.15s; line-height: 1.5; }
      .ih-popover.visible { opacity: 1; pointer-events: auto; }
      .ih-popover .ih-pop-label { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 4px; vertical-align: middle; }
      .ih-popover .ih-pop-row { display: flex; align-items: center; gap: 6px; }
    </style>
  </head>

  <body>
    <div class="mx-auto max-w-[1200px] px-4 pb-28 pt-10 sm:px-6 lg:px-8">
      <!-- Top -->
      <header class="enter">
        <div
          class="glass shadow-glow rounded-3xl px-5 py-6 sm:px-7 sm:py-7 lg:px-10 lg:py-10"
        >
          <div class="flex flex-col gap-6 lg:flex-row lg:items-end lg:justify-between">
            <div class="max-w-[70ch]">
              <div class="flex flex-wrap items-center gap-2">
                <span
                  class="chip inline-flex items-center gap-2 rounded-full px-3 py-1 text-xs font-semibold text-slate-700"
                >
                  <span
                    class="inline-block h-2 w-2 rounded-full"
                    style="background: linear-gradient(90deg, var(--c1), var(--c6))"
                  ></span>
                  Single-file visualization
                </span>
                <span
                  id="metaSpan"
                  class="chip inline-flex items-center rounded-full px-3 py-1 text-xs font-semibold text-slate-700"
                ></span>
              </div>

              <h1 class="mt-4 font-display text-4xl leading-[1.05] sm:text-5xl">
                Evolution of the FrankenSQLite Spec
              </h1>
              <p class="mt-4 text-base leading-relaxed text-slate-700 sm:text-lg">
                A commit-by-commit atlas of how
                <span class="mono">COMPREHENSIVE_SPEC_FOR_FRANKENSQLITE_V1.md</span>
                changed from inception. Every change is bucketed into 10 categories with
                multi-label support, confidence, and diff excerpts.
              </p>
            </div>

            <div class="flex flex-col gap-3 sm:flex-row sm:flex-wrap sm:items-center lg:justify-end">
              <button
                id="btnFilters"
                class="focus-ring inline-flex items-center justify-center gap-2 rounded-2xl border border-slate-900/10 bg-white/60 px-4 py-2.5 text-sm font-semibold text-slate-900 shadow-sm transition hover:bg-white"
                type="button"
              >
                Filters
              </button>
              <a
                id="btnOpenSpec"
                class="focus-ring inline-flex items-center justify-center gap-2 rounded-2xl border border-slate-900/10 bg-white/60 px-4 py-2.5 text-sm font-semibold text-slate-900 shadow-sm transition hover:bg-white"
                href="COMPREHENSIVE_SPEC_FOR_FRANKENSQLITE_V1.md"
              >
                Open Spec
              </a>
              <button
                id="btnGalaxy"
                class="focus-ring inline-flex items-center justify-center gap-2 rounded-2xl bg-slate-900 px-4 py-2.5 text-sm font-semibold text-white shadow-sm transition hover:bg-slate-800"
                type="button"
              >
                Galaxy Brain
              </button>
            </div>
          </div>

          <div class="mt-7 grid grid-cols-2 gap-3 sm:grid-cols-3 md:grid-cols-5">
            <div class="glass-2 rounded-2xl p-4 shadow-sm">
              <div class="text-xs font-semibold text-slate-500">Commits</div>
              <div id="kpiCommits" class="mt-2 text-2xl font-bold text-slate-900">-</div>
            </div>
            <div class="glass-2 rounded-2xl p-4 shadow-sm">
              <div class="text-xs font-semibold text-slate-500">Change Groups</div>
              <div id="kpiGroups" class="mt-2 text-2xl font-bold text-slate-900">-</div>
            </div>
            <div class="glass-2 rounded-2xl p-4 shadow-sm">
              <div class="text-xs font-semibold text-slate-500">Lines Changed</div>
              <div id="kpiLines" class="mt-2 text-2xl font-bold text-slate-900">-</div>
            </div>
            <div class="glass-2 rounded-2xl p-4 shadow-sm">
              <div class="text-xs font-semibold text-slate-500">Primary Mode</div>
              <div id="kpiMode" class="mt-2 text-2xl font-bold text-slate-900">-</div>
            </div>
            <div class="glass-2 rounded-2xl p-4 shadow-sm">
              <div class="text-xs font-semibold text-slate-500">Data Integrity</div>
              <div id="kpiIntegrity" class="mt-2 text-2xl font-bold text-slate-900">-</div>
            </div>
          </div>
        </div>
      </header>

      <!-- Main layout -->
      <div class="mt-8 grid grid-cols-1 gap-6 lg:grid-cols-[360px_1fr]">
        <!-- Sidebar (desktop) -->
        <aside class="enter hidden lg:block">
          <div class="glass shadow-glow rounded-3xl p-5">
            <div class="flex items-center justify-between">
              <div class="text-sm font-bold text-slate-900">Filters</div>
              <button
                id="btnReset"
                class="focus-ring rounded-xl border border-slate-900/10 bg-white/60 px-3 py-1.5 text-xs font-semibold text-slate-900 hover:bg-white"
                type="button"
              >
                Reset
              </button>
            </div>

            <div class="mt-4">
              <label class="text-xs font-semibold text-slate-600">Search</label>
              <input
                id="q"
                class="focus-ring mt-2 w-full rounded-2xl border border-slate-900/10 bg-white/70 px-3.5 py-2.5 text-sm text-slate-900 placeholder:text-slate-400"
                placeholder="commit, section, keyword..."
              />
            </div>

            <div class="mt-4">
              <div class="flex items-center justify-between">
                <label class="text-xs font-semibold text-slate-600">Min Impact</label>
                <div id="impactLabel" class="mono text-xs text-slate-500">-</div>
              </div>
              <input id="impact" class="mt-2 w-full" type="range" min="0" max="200" value="0" />
            </div>

            <div class="mt-5">
              <div class="flex items-center justify-between">
                <label class="text-xs font-semibold text-slate-600">Bucket Mode</label>
                <div class="mono text-xs text-slate-500" id="bucketModeLabel">primary</div>
              </div>
              <div class="mt-2 grid grid-cols-2 gap-2">
                <button
                  id="modePrimary"
                  class="focus-ring rounded-2xl border border-slate-900/10 bg-slate-900 px-3 py-2 text-xs font-semibold text-white"
                  type="button"
                >
                  Primary (disjoint)
                </button>
                <button
                  id="modeMulti"
                  class="focus-ring rounded-2xl border border-slate-900/10 bg-white/70 px-3 py-2 text-xs font-semibold text-slate-900"
                  type="button"
                >
                  Multi-label
                </button>
              </div>
              <p class="mt-2 text-xs leading-relaxed text-slate-500">
                Multi-label counts a change group in every bucket it matches. Primary assigns each group
                exactly one bucket for clean stacks.
              </p>
            </div>

            <div class="mt-5">
              <label class="text-xs font-semibold text-slate-600">Buckets</label>
              <div id="bucketToggles" class="mt-2 grid grid-cols-1 gap-2"></div>
            </div>

            <div class="mt-6">
              <label class="text-xs font-semibold text-slate-600">Quick Views</label>
              <div class="mt-2 grid grid-cols-1 gap-2">
                <button
                  id="viewTimeline"
                  class="focus-ring rounded-2xl border border-slate-900/10 bg-white/70 px-3 py-2 text-left text-xs font-semibold text-slate-900 hover:bg-white"
                  type="button"
                >
                  Timeline + Categories
                </button>
                <button
                  id="viewCommits"
                  class="focus-ring rounded-2xl border border-slate-900/10 bg-white/70 px-3 py-2 text-left text-xs font-semibold text-slate-900 hover:bg-white"
                  type="button"
                >
                  Commit Explorer
                </button>
                <button
                  id="viewAlien"
                  class="focus-ring rounded-2xl border border-slate-900/10 bg-white/70 px-3 py-2 text-left text-xs font-semibold text-slate-900 hover:bg-white"
                  type="button"
                >
                  Alien Telemetry (BOCPD)
                </button>
              </div>
            </div>
          </div>
        </aside>

        <!-- Content -->
        <main class="enter">
          <!-- Timeline -->
          <section id="sectionTimeline" class="glass shadow-glow rounded-3xl p-5">
            <div class="flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between">
              <div>
                <div class="text-sm font-bold text-slate-900">Timeline</div>
                <div class="mt-1 text-xs text-slate-500">
                  Dot = commit. Size = lines changed. Color = primary bucket.
                </div>
              </div>
              <div class="flex flex-wrap items-center gap-2">
                <div class="chip rounded-2xl px-3 py-1.5 text-xs font-semibold text-slate-700">
                  <span class="mono" id="rangeLabel">-</span>
                </div>
                <a
                  id="btnOpenRepo"
                  class="focus-ring chip inline-flex items-center gap-2 rounded-2xl px-3 py-1.5 text-xs font-semibold text-slate-700 hover:bg-white"
                  href="https://github.com/Dicklesworthstone/frankensqlite"
                  target="_blank"
                  rel="noreferrer"
                >
                  GitHub
                </a>
              </div>
            </div>

            <div id="timelineChart" class="chart mt-4 w-full"></div>
          </section>

          <section class="mt-6 grid grid-cols-1 gap-6 xl:grid-cols-2">
            <section class="glass shadow-glow rounded-3xl p-5">
              <div class="flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between">
                <div>
                  <div class="text-sm font-bold text-slate-900">Buckets Over Time</div>
                  <div class="mt-1 text-xs text-slate-500">
                    Stacked totals across time bins (or by commit). Use this for day/hour/15m/5m
                    density.
                  </div>
                </div>
                <div class="flex flex-wrap items-center gap-2">
                  <label class="chip inline-flex items-center gap-2 rounded-2xl px-3 py-1.5 text-xs font-semibold text-slate-700">
                    Resolution
                    <select id="stackResolution" class="ml-1 rounded-xl border border-slate-900/10 bg-white/70 px-2 py-1 text-xs">
                      <option value="commit">Commit</option>
                      <option value="day">Day</option>
                      <option value="hour">Hour</option>
                      <option value="15m">15 min</option>
                      <option value="5m">5 min</option>
                    </select>
                  </label>
                  <label class="chip inline-flex items-center gap-2 rounded-2xl px-3 py-1.5 text-xs font-semibold text-slate-700">
                    Metric
                    <select id="stackMetric" class="ml-1 rounded-xl border border-slate-900/10 bg-white/70 px-2 py-1 text-xs">
                      <option value="groups">Change groups</option>
                      <option value="lines">Lines changed (approx)</option>
                      <option value="tokens">Tokens changed (approx)</option>
                      <option value="lev">Levenshtein (hunks)</option>
                    </select>
                  </label>
                  <label class="chip inline-flex items-center gap-2 rounded-2xl px-3 py-1.5 text-xs font-semibold text-slate-700">
                    Timezone
                    <select id="stackTimezone" class="ml-1 rounded-xl border border-slate-900/10 bg-white/70 px-2 py-1 text-xs">
                      <option value="local">Local</option>
                      <option value="utc">UTC</option>
                    </select>
                  </label>
                </div>
              </div>
              <div id="stackChart" class="chart mt-4 w-full"></div>
            </section>

            <section class="glass shadow-glow rounded-3xl p-5">
              <div class="flex items-end justify-between">
                <div>
                  <div class="text-sm font-bold text-slate-900">Bucket Mix</div>
                  <div class="mt-1 text-xs text-slate-500">Distribution in current filter.</div>
                </div>
              </div>
              <div id="donutChart" class="chart mt-4 w-full"></div>
            </section>
          </section>

          <!-- Outlier Dashboard (bd-24q.10.2) -->
          <section id="outlierPanel" class="glass shadow-glow mt-6 rounded-3xl p-5">
            <div class="flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between">
              <div>
                <div class="text-sm font-bold text-slate-900">Outlier Commits</div>
                <div class="mt-1 text-xs text-slate-500">Largest deltas by MAD-Z score. Click to jump.</div>
              </div>
              <div class="flex flex-wrap items-center gap-2">
                <label class="chip inline-flex items-center gap-2 rounded-2xl px-3 py-1.5 text-xs font-semibold text-slate-700">Metric
                  <select id="outlierMetricSel" class="ml-1 rounded-xl border border-slate-900/10 bg-white/70 px-2 py-1 text-xs">
                    <option value="impact" selected>Impact (lines)</option>
                    <option value="linesAdded">Lines Added</option>
                    <option value="linesDeleted">Lines Deleted</option>
                    <option value="tokens">Tokens Changed</option>
                    <option value="lev">Levenshtein</option>
                    <option value="hunks">Hunks</option>
                  </select>
                </label>
                <label class="chip inline-flex items-center gap-2 rounded-2xl px-3 py-1.5 text-xs font-semibold text-slate-700">Top
                  <select id="outlierTopKSel" class="ml-1 rounded-xl border border-slate-900/10 bg-white/70 px-2 py-1 text-xs">
                    <option value="5">5</option><option value="10" selected>10</option><option value="20">20</option><option value="50">50</option>
                  </select>
                </label>
              </div>
            </div>
            <div id="outlierList" class="mt-3 space-y-1.5 max-h-[50vh] overflow-auto"></div>
            <div id="outlierEmpty" class="hidden mt-3 text-xs text-slate-400 italic p-3">No outliers detected.</div>
            <div id="outlierLoading" class="hidden mt-3 text-xs text-slate-400 italic p-3">Computing outliers...</div>
          </section>


          <!-- Cluster Explorer (bd-24q.14.3) -->
          <section id="clusterPanel" class="glass shadow-glow mt-6 rounded-3xl p-5">
            <div class="flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between">
              <div>
                <div class="text-sm font-bold text-slate-900">Commit Clusters</div>
                <div class="mt-1 text-xs text-slate-500">Similar commits grouped by content. Click to highlight on timeline.</div>
              </div>
              <div class="flex flex-wrap items-center gap-2">
                <label class="chip inline-flex items-center gap-2 rounded-2xl px-3 py-1.5 text-xs font-semibold text-slate-700">Threshold
                  <select id="clusterThresholdSel" class="ml-1 rounded-xl border border-slate-900/10 bg-white/70 px-2 py-1 text-xs">
                    <option value="0.15">0.15 (loose)</option>
                    <option value="0.3" selected>0.3 (default)</option>
                    <option value="0.5">0.5 (tight)</option>
                  </select>
                </label>
                <label class="chip inline-flex items-center gap-2 rounded-2xl px-3 py-1.5 text-xs font-semibold text-slate-700">Show
                  <select id="clusterLimitSel" class="ml-1 rounded-xl border border-slate-900/10 bg-white/70 px-2 py-1 text-xs">
                    <option value="5">5</option><option value="10" selected>10</option><option value="20">20</option>
                  </select>
                </label>
              </div>
            </div>
            <div id="clusterList" class="mt-3 space-y-2 max-h-[50vh] overflow-auto"></div>
            <div id="clusterEmpty" class="hidden mt-3 text-xs text-slate-400 italic p-3">No clusters found.</div>
            <div id="clusterLoading" class="hidden mt-3 text-xs text-slate-400 italic p-3">Computing clusters...</div>
            <!-- In-cluster navigation (shown when a cluster is selected) -->
            <div id="clusterNav" class="hidden mt-3 flex items-center justify-between border-t border-slate-900/10 pt-3">
              <button id="clusterPrev" class="focus-ring rounded-xl bg-slate-100 px-3 py-1.5 text-xs font-semibold text-slate-700 hover:bg-slate-200">&larr; Prev</button>
              <span id="clusterNavLabel" class="text-xs text-slate-500">1 / 5</span>
              <button id="clusterNext" class="focus-ring rounded-xl bg-slate-100 px-3 py-1.5 text-xs font-semibold text-slate-700 hover:bg-slate-200">Next &rarr;</button>
            </div>
          </section>

          <!-- Doc evolution -->
          <section id="sectionDoc" class="glass shadow-glow mt-6 rounded-3xl p-5">
            <div class="flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between">
              <div>
                <div class="text-sm font-bold text-slate-900">Document Evolution</div>
                <div class="mt-1 text-xs text-slate-500">
                  Scrub the timeline dock to step through history. Inspect the rendered spec and the
                  unified diff (with token + Levenshtein metrics).
                </div>
              </div>
              <div class="flex flex-wrap items-center gap-2">
                <button
                  id="docTabSpec"
                  class="focus-ring rounded-2xl bg-slate-900 px-3 py-2 text-xs font-semibold text-white hover:bg-slate-800"
                  type="button"
                >
                  Spec
                </button>
                <button
                  id="docTabDiff"
                  class="focus-ring rounded-2xl border border-slate-900/10 bg-white/70 px-3 py-2 text-xs font-semibold text-slate-900 hover:bg-white"
                  type="button"
                >
                  Diff
                </button>
                <button
                  id="docTabMetrics"
                  class="focus-ring rounded-2xl border border-slate-900/10 bg-white/70 px-3 py-2 text-xs font-semibold text-slate-900 hover:bg-white"
                  type="button"
                >
                  Metrics
                </button>
                <button
                  id="docTabSections"
                  class="focus-ring rounded-2xl border border-slate-900/10 bg-white/70 px-3 py-2 text-xs font-semibold text-slate-900 hover:bg-white"
                  type="button"
                >
                  Sections
                </button>
                <span class="relative ml-1">
                  <button
                    id="btnCopyLink"
                    class="focus-ring rounded-2xl border border-slate-900/10 bg-white/70 px-3 py-2 text-xs font-semibold text-slate-900 hover:bg-white"
                    type="button"
                    title="Copy a shareable permalink to the current view"
                  >Copy Link</button>
                  <button
                    id="btnShareHelp"
                    class="focus-ring ml-1 rounded-full border border-slate-900/10 bg-white/70 px-2 py-1 text-[10px] font-bold text-slate-500 hover:bg-white hover:text-slate-900"
                    type="button"
                    title="URL parameter reference"
                  >?</button>
                  <div
                    id="shareHelpPopover"
                    class="hidden absolute right-0 top-full z-50 mt-2 w-72 rounded-2xl border border-slate-900/10 bg-white p-4 shadow-glowLg text-left"
                  >
                    <div class="text-xs font-bold text-slate-900 mb-2">Permalink URL Parameters</div>
                    <table class="w-full text-[11px] text-slate-700">
                      <thead><tr class="border-b border-slate-200"><th class="pb-1 text-left font-semibold">Param</th><th class="pb-1 text-left font-semibold">Values</th><th class="pb-1 text-left font-semibold">Default</th></tr></thead>
                      <tbody>
                        <tr><td class="py-0.5 font-mono">v</td><td>Schema version</td><td>1</td></tr>
                        <tr><td class="py-0.5 font-mono">c</td><td>Commit index (0-based)</td><td>latest</td></tr>
                        <tr><td class="py-0.5 font-mono">t</td><td>spec | diff | metrics</td><td>spec</td></tr>
                        <tr><td class="py-0.5 font-mono">raw</td><td>1 = raw markdown</td><td>rendered</td></tr>
                        <tr><td class="py-0.5 font-mono">dm</td><td>pretty | raw</td><td>pretty</td></tr>
                        <tr><td class="py-0.5 font-mono">q</td><td>Search query</td><td>(empty)</td></tr>
                        <tr><td class="py-0.5 font-mono">mi</td><td>Min impact (lines)</td><td>0</td></tr>
                        <tr><td class="py-0.5 font-mono">bm</td><td>primary | multi</td><td>primary</td></tr>
                        <tr><td class="py-0.5 font-mono">b</td><td>Bucket IDs (1-10, comma-sep)</td><td>all</td></tr>
                        <tr><td class="py-0.5 font-mono">cmp</td><td>1 = A/B compare mode</td><td>off</td></tr>
                        <tr><td class="py-0.5 font-mono">ca</td><td>Compare "A" commit index</td><td>0</td></tr>
                        <tr><td class="py-0.5 font-mono">cb</td><td>Compare "B" commit index</td><td>0</td></tr>
                        <tr><td class="py-0.5 font-mono">dl</td><td>side-by-side | line-by-line</td><td>side-by-side</td></tr>
                        <tr><td class="py-0.5 font-mono">avm</td><td>diff | rendered</td><td>diff</td></tr>
                        <tr><td class="py-0.5 font-mono">res</td><td>commit | day | hour | 15m | 5m</td><td>commit</td></tr>
                        <tr><td class="py-0.5 font-mono">tz</td><td>local | utc</td><td>local</td></tr>
                        <tr><td class="py-0.5 font-mono">met</td><td>groups | lines | tokens | lev</td><td>groups</td></tr>
                      </tbody>
                    </table>
                    <div class="mt-2 text-[10px] text-slate-500">Default values are omitted for minimal URLs. Invalid values are clamped. Canonical key order: v, c, t, raw, dm, cmp, ca, cb, dl, avm, q, mi, bm, b, res, tz, met.</div>
                  </div>
                </span>
              </div>
            </div>

            <div id="docLoading" class="mt-4 rounded-3xl border border-slate-900/10 bg-white/60 p-4 text-sm text-slate-700">
              Loading spec evolution dataset... (local gzip JSON; no GitHub API)
            </div>

            <div id="docMain" class="mt-4 hidden grid-cols-1 gap-4 lg:grid lg:grid-cols-[1fr_360px]">
              <section class="glass-2 rounded-3xl p-4 lg:p-5">
                <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                  <div class="min-w-0">
                    <div class="text-xs font-semibold text-slate-500">Selected commit</div>
                    <div id="docCommitTitle" class="mt-1 truncate text-sm font-semibold text-slate-900">-</div>
                  </div>
                  <div class="flex shrink-0 flex-wrap items-center gap-2">
                    <span id="docCommitMeta" class="chip mono inline-flex items-center rounded-full px-2.5 py-1 text-[11px] text-slate-700">-</span>
                    <a
                      id="docCommitLink"
                      class="focus-ring chip inline-flex items-center gap-2 rounded-2xl px-3 py-2 text-xs font-semibold text-slate-700 hover:bg-white"
                      href="#"
                      target="_blank"
                      rel="noreferrer"
                    >
                      Open commit
                    </a>
                  </div>
                </div>

                <div class="mt-4">
                  <div id="docSpecView" class="hidden">
                    <div class="flex items-center justify-between">
                      <div class="text-xs font-semibold text-slate-600">Rendered Markdown</div>
                      <div class="flex items-center gap-2">
                        <button
                          id="btnStoryToggle"
                          class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-1.5 text-[11px] font-semibold text-slate-900 hover:bg-white"
                          type="button"
                          title="Toggle story mode milestones"
                        >
                          Story
                        </button>
                        <button
                          id="btnStoryMobileTrigger"
                          class="sm:hidden focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-1.5 text-[11px] font-semibold text-slate-900 hover:bg-white"
                          type="button"
                          title="Story mode (mobile)"
                        >
                          Story
                        </button>
                        <button
                          id="btnMiniMapToggle"
                          class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-1.5 text-[11px] font-semibold text-slate-900 hover:bg-white"
                          type="button"
                          title="Toggle heading mini-map"
                        >
                          Outline
                        </button>
                        <button id="btnIHToggle" class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-1.5 text-[11px] font-semibold text-slate-900 hover:bg-white" type="button" title="Toggle inline change highlights">Highlights</button>
                        <div id="ihNav" style="display:none;align-items:center;gap:4px">
                          <button id="btnIHPrev" class="focus-ring rounded-lg border border-slate-900/10 bg-white/80 px-2 py-0.5 text-[10px] font-semibold text-slate-600 hover:bg-white" type="button" title="Previous change (Alt+Up)" aria-label="Previous change">&uarr;</button>
                          <span id="ihNavLabel" class="text-[10px] text-slate-400" style="min-width:3rem;text-align:center">0/0</span>
                          <button id="btnIHNext" class="focus-ring rounded-lg border border-slate-900/10 bg-white/80 px-2 py-0.5 text-[10px] font-semibold text-slate-600 hover:bg-white" type="button" title="Next change (Alt+Down)" aria-label="Next change">&darr;</button>
                        </div>
                        <button
                          id="btnRawToggle"
                          class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-1.5 text-[11px] font-semibold text-slate-900 hover:bg-white"
                          type="button"
                        >
                          Toggle Raw
                        </button>
                      </div>
                    </div>
                    <!-- Mobile outline trigger (bd-24q.2.3) -->
                    <button
                      id="btnMiniMapMobile"
                      class="sm:hidden mt-2 w-full focus-ring rounded-2xl bg-slate-900 px-4 py-2.5 text-sm font-semibold text-white hover:bg-slate-800"
                      type="button"
                    >Outline</button>
                    <div class="mt-3 flex gap-3">
                      <nav
                        id="miniMap"
                        class="hidden w-56 shrink-0 flex flex-col rounded-2xl border border-slate-900/10 bg-white/70"
                        style="max-height: 70vh"
                        aria-label="Document outline"
                      >
                        <div class="shrink-0 border-b border-slate-900/10 px-3 py-2">
                          <input
                            id="miniMapSearch"
                            type="text"
                            class="w-full rounded-lg border border-slate-900/10 bg-white/80 px-2 py-1 text-[11px] text-slate-700 placeholder:text-slate-400 focus:border-slate-400 focus:outline-none"
                            placeholder="Filter headings..."
                            autocomplete="off"
                          />
                        </div>
                        <div id="miniMapItems" class="flex-1 overflow-y-auto p-3" role="tree" tabindex="0"></div>
                      </nav>
                      <div style="position:relative" class="min-w-0 flex-1">
                        <div id="docRendered" class="md max-h-[70vh] overflow-auto rounded-2xl border border-slate-900/10 bg-white/70 p-4"></div>
                        <div id="ihPopover" class="ih-popover" aria-hidden="true"></div>
                      </div>
                      <aside
                        id="storyRail"
                        class="hidden w-64 shrink-0 flex flex-col rounded-2xl border border-slate-900/10 bg-white/70"
                        style="max-height: 70vh"
                        aria-label="Story mode milestones"
                      >
                        <div class="shrink-0 border-b border-slate-900/10 px-3 py-2 flex items-center justify-between">
                          <span class="text-[11px] font-semibold text-slate-600">Milestones</span>
                          <div class="flex items-center gap-1.5">
                            <button id="storyPrev" class="focus-ring rounded-lg border border-slate-900/10 bg-white/80 px-2 py-0.5 text-[10px] font-semibold text-slate-600 hover:bg-white" type="button" aria-label="Previous milestone">&larr;</button>
                            <span id="storyProgress" class="text-[10px] text-slate-400">0/0</span>
                            <button id="storyNext" class="focus-ring rounded-lg border border-slate-900/10 bg-white/80 px-2 py-0.5 text-[10px] font-semibold text-slate-600 hover:bg-white" type="button" aria-label="Next milestone">&rarr;</button>
                            <button id="storyAutoplayBtn" class="focus-ring rounded-lg border border-slate-900/10 bg-white/80 px-2 py-0.5 text-[10px] font-semibold text-slate-600 hover:bg-white" type="button" aria-label="Autoplay through milestones" title="Autoplay tour">&#9654; Tour</button>
                          </div>
                        </div>
                        <div id="storyCards" class="flex-1 overflow-y-auto p-3 space-y-2"></div>
                      </aside>
                    </div>
                    <pre id="docRaw" class="codebox mono mt-3 hidden max-h-[70vh] overflow-auto rounded-2xl p-4 text-[11px] leading-relaxed text-slate-900"></pre>
                  </div>

                  <div id="docDiffView" class="hidden">
                    <div class="flex items-center justify-between flex-wrap gap-2">
                      <div class="flex items-center gap-2">
                        <div id="diffLabel" class="text-xs font-semibold text-slate-600">Diff (parent → selected)</div>
                        <button
                          id="btnCompareToggle"
                          class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-1.5 text-[11px] font-semibold text-slate-900 hover:bg-white"
                          type="button"
                          title="Toggle A/B compare mode"
                        >A/B Compare</button>
                      </div>
                      <div class="flex items-center gap-2">
                        <button
                          id="btnDiffLayout"
                          class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-1.5 text-[11px] font-semibold text-slate-900 hover:bg-white hidden"
                          type="button"
                          title="Toggle side-by-side / unified layout"
                        >Side-by-Side</button>
                        <button
                          id="btnSbsRendered"
                          class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-1.5 text-[11px] font-semibold text-slate-900 hover:bg-white hidden"
                          type="button"
                          title="Show rendered markdown side-by-side (A left, B right)"
                        >Rendered A|B</button>
                        <button
                          id="btnPrettyDiff"
                          class="focus-ring rounded-xl bg-slate-900 px-3 py-1.5 text-[11px] font-semibold text-white hover:bg-slate-800"
                          type="button"
                        >
                          Pretty
                        </button>
                        <button
                          id="btnRawDiff"
                          class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-1.5 text-[11px] font-semibold text-slate-900 hover:bg-white"
                          type="button"
                        >
                          Raw
                        </button>
                      </div>
                    </div>
                    <!-- A/B Compare commit pickers with typeahead (bd-24q.1) -->
                    <div id="abCompareBar" class="hidden mt-2 flex items-center gap-2 flex-wrap rounded-xl border border-blue-200 bg-blue-50/60 px-3 py-2">
                      <label class="text-[11px] font-semibold text-blue-700">A:</label>
                      <div class="ab-picker" id="pickerA">
                        <button type="button" class="ab-picker-btn" id="pickerABtn" title="Select commit A">Select...</button>
                        <div class="ab-picker-dropdown hidden" id="pickerADropdown">
                          <input type="text" class="ab-picker-search" id="pickerASearch" placeholder="Search by subject, hash, or #index..." autocomplete="off" />
                          <div class="ab-picker-list" id="pickerAList"></div>
                        </div>
                      </div>
                      <button id="btnSwapAB" class="focus-ring rounded-lg border border-blue-200 bg-white px-2 py-1 text-[11px] font-semibold text-blue-700 hover:bg-blue-100" type="button" title="Swap A and B">⇄</button>
                      <label class="text-[11px] font-semibold text-blue-700">B:</label>
                      <div class="ab-picker" id="pickerB">
                        <button type="button" class="ab-picker-btn" id="pickerBBtn" title="Select commit B">Select...</button>
                        <div class="ab-picker-dropdown hidden" id="pickerBDropdown">
                          <input type="text" class="ab-picker-search" id="pickerBSearch" placeholder="Search by subject, hash, or #index..." autocomplete="off" />
                          <div class="ab-picker-list" id="pickerBList"></div>
                        </div>
                      </div>
                      <button id="btnResetAB" class="focus-ring rounded-lg border border-blue-200 bg-white px-2 py-1 text-[11px] font-semibold text-blue-700 hover:bg-blue-100" type="button" title="Reset to current commit">Reset</button>
                      <div id="abDiffLoading" class="hidden text-[11px] text-blue-600 ml-2">Computing diff…</div>
                    </div>
                    <!-- A/B Compare metric chips -->
                    <div id="abMetricsBar" class="hidden mt-2 flex items-center gap-2 flex-wrap">
                      <span id="abmLines" class="chip mono rounded-full px-2.5 py-1 text-[11px] text-blue-800 bg-blue-100 border border-blue-200"></span>
                      <span id="abmTokens" class="chip mono rounded-full px-2.5 py-1 text-[11px] text-blue-800 bg-blue-100 border border-blue-200"></span>
                      <span id="abmLev" class="chip mono rounded-full px-2.5 py-1 text-[11px] text-blue-800 bg-blue-100 border border-blue-200"></span>
                      <span id="abmHunks" class="chip mono rounded-full px-2.5 py-1 text-[11px] text-blue-800 bg-blue-100 border border-blue-200"></span>
                      <span id="abmBytes" class="chip mono rounded-full px-2.5 py-1 text-[11px] text-blue-800 bg-blue-100 border border-blue-200"></span>
                    </div>
                    <div id="diffPretty" class="mt-3 max-h-[70vh] overflow-auto rounded-2xl border border-slate-900/10 bg-white/70 p-2"></div>
                    <pre id="diffRaw" class="codebox mono mt-3 hidden max-h-[70vh] overflow-auto rounded-2xl p-4 text-[11px] leading-relaxed text-slate-900"></pre>
                    <!-- Side-by-Side Rendered Markdown Panes (bd-24q.15.1) -->
                    <div id="sbsContainer" class="hidden mt-3 relative flex flex-col rounded-2xl border border-slate-900/10 bg-white/70" style="max-height: 70vh">
                      <!-- Pane header bar: labels + controls -->
                      <div class="flex items-center justify-between border-b border-slate-900/10 px-3 py-1.5 shrink-0">
                        <div class="flex items-center gap-4">
                          <span id="sbsLabelA" class="text-[11px] font-semibold text-blue-700 truncate max-w-[260px]">A</span>
                          <span class="text-[10px] text-slate-300">|</span>
                          <span id="sbsLabelB" class="text-[11px] font-semibold text-emerald-700 truncate max-w-[260px]">B</span>
                        </div>
                        <div class="flex items-center gap-1">
                          <button
                            id="btnSbsCopyLink"
                            class="focus-ring rounded-lg border border-slate-900/10 bg-white/90 px-2 py-0.5 text-[10px] font-semibold text-slate-600 hover:bg-white"
                            type="button"
                            title="Copy permalink for this side-by-side view"
                          >Copy Link</button>
                          <button
                            id="btnSbsSyncScroll"
                            class="focus-ring rounded-lg border border-slate-900/10 bg-white/90 px-2 py-0.5 text-[10px] font-semibold text-slate-600 hover:bg-white"
                            type="button"
                            title="Toggle synced scrolling between panes"
                          >Sync &#x2714;</button>
                        </div>
                      </div>
                      <!-- Mobile segmented control A | B (bd-24q.15.3) -->
                      <div class="sbs-mobile-tabs shrink-0 mx-3 mt-1.5 mb-1">
                        <button id="sbsTabA" class="active" type="button">Pane A</button>
                        <button id="sbsTabB" type="button">Pane B</button>
                      </div>
                      <!-- Pane content area -->
                      <div class="flex flex-1 min-h-0 overflow-hidden relative">
                        <div id="sbsPaneA" class="md flex-1 min-w-0 overflow-auto p-4 sbs-pane-visible" style="scroll-behavior: auto"></div>
                        <div
                          id="sbsDivider"
                          class="shrink-0 cursor-col-resize bg-slate-200 hover:bg-slate-400 transition-colors"
                          style="width: 5px"
                          title="Drag to resize panes"
                        ></div>
                        <div id="sbsPaneB" class="md flex-1 min-w-0 overflow-auto p-4" style="scroll-behavior: auto"></div>
                        <!-- Jump to heading CTA (mobile portrait, bd-24q.15.3) -->
                        <button id="sbsJumpCta" class="sbs-jump-cta" type="button"></button>
                      </div>
                    </div>
                  </div>

                  <div id="docMetricsView" class="hidden">
                    <div class="text-xs font-semibold text-slate-600">Computed metrics</div>
                    <div class="mt-3 grid grid-cols-2 gap-3 sm:grid-cols-4">
                      <div class="glass-2 rounded-2xl p-4 shadow-sm">
                        <div class="text-[11px] font-semibold text-slate-500">Tokens touched</div>
                        <div id="mTokens" class="mt-2 text-lg font-bold text-slate-900">-</div>
                      </div>
                      <div class="glass-2 rounded-2xl p-4 shadow-sm">
                        <div class="text-[11px] font-semibold text-slate-500">Levenshtein</div>
                        <div id="mLev" class="mt-2 text-lg font-bold text-slate-900">-</div>
                      </div>
                      <div class="glass-2 rounded-2xl p-4 shadow-sm">
                        <div class="text-[11px] font-semibold text-slate-500">Hunks</div>
                        <div id="mHunks" class="mt-2 text-lg font-bold text-slate-900">-</div>
                      </div>
                      <div class="glass-2 rounded-2xl p-4 shadow-sm">
                        <div class="text-[11px] font-semibold text-slate-500">Bytes touched</div>
                        <div id="mBytes" class="mt-2 text-lg font-bold text-slate-900">-</div>
                      </div>
                    </div>
                    <div class="mt-4">
                      <div class="grid grid-cols-1 gap-2 sm:grid-cols-2">
                        <button
                          id="btnComputeAll"
                          class="focus-ring w-full rounded-2xl bg-slate-900 px-4 py-2.5 text-sm font-semibold text-white hover:bg-slate-800"
                          type="button"
                        >
                          Compute token + Levenshtein metrics for all commits
                        </button>
                        <button
                          id="btnCancelCompute"
                          class="focus-ring hidden w-full rounded-2xl border border-rose-300 bg-rose-50 px-4 py-2.5 text-sm font-semibold text-rose-700 hover:bg-rose-100"
                          type="button"
                        >
                          Cancel running compute
                        </button>
                      </div>
                      <div class="mt-2 text-xs text-slate-500">
                        This can take a bit on large diffs. The UI stays responsive; charts update
                        as metrics arrive.
                      </div>
                      <div id="workerStatus" class="mt-2 text-xs text-slate-500"></div>
                      <div id="computeProgress" class="mt-2 hidden text-xs font-semibold text-slate-700"></div>
                      <!-- Global warmup progress bar (bd-24q.5.3) -->
                      <div id="warmupProgress" class="hidden mt-2">
                        <div class="flex items-center gap-2">
                          <div class="flex-1 h-1.5 rounded-full bg-slate-200 overflow-hidden">
                            <div id="warmupProgressBar" class="h-full rounded-full bg-indigo-500 transition-all duration-300" style="width:0%"></div>
                          </div>
                          <span id="warmupProgressLabel" class="text-[10px] text-slate-500 shrink-0">0%</span>
                          <button id="btnCancelWarmup" class="text-[10px] text-rose-500 hover:text-rose-700 font-semibold" type="button">Cancel</button>
                        </div>
                        <div id="warmupStage" class="mt-0.5 text-[10px] text-slate-400 truncate"></div>
                      </div>
                    </div>
                  </div>

                  <div id="docSectionsView" class="hidden">
                    <div class="flex items-center justify-between">
                      <div class="text-xs font-semibold text-slate-600">Per-Section Change Summary</div>
                      <div class="flex items-center gap-2">
                        <input
                          id="sectionFilter"
                          type="text"
                          placeholder="Filter headings..."
                          class="focus-ring w-40 rounded-xl border border-slate-900/10 bg-white/70 px-3 py-1.5 text-[11px] text-slate-700 placeholder-slate-400"
                        />
                      </div>
                    </div>
                    <div id="sectionTableWrap" class="mt-3 max-h-[70vh] overflow-auto rounded-2xl border border-slate-900/10 bg-white/70">
                      <table id="sectionTable" class="w-full text-[11px]">
                        <thead class="sticky top-0 z-10 bg-white/95 backdrop-blur">
                          <tr class="border-b border-slate-200">
                            <th class="px-3 py-2 text-left font-semibold text-slate-500" data-sort="name">Section</th>
                            <th class="px-3 py-2 text-right font-semibold text-slate-500 w-16" data-sort="add">+Lines</th>
                            <th class="px-3 py-2 text-right font-semibold text-slate-500 w-16" data-sort="del">-Lines</th>
                            <th class="px-3 py-2 text-right font-semibold text-slate-500 w-20" data-sort="tokens">Tokens</th>
                            <th class="px-3 py-2 text-right font-semibold text-slate-500 w-20" data-sort="impact">Impact</th>
                          </tr>
                        </thead>
                        <tbody id="sectionTableBody"></tbody>
                      </table>
                    </div>
                    <div id="sectionEmpty" class="hidden mt-3 text-xs text-slate-400 italic p-3">No section changes for this commit.</div>
                    <button id="btnOpenSectionSheet" class="mt-3 w-full sm:hidden focus-ring rounded-2xl bg-slate-900 px-4 py-2.5 text-sm font-semibold text-white hover:bg-slate-800" type="button">View sections (mobile)</button>
                  </div>
                </div>
              </section>

              <aside class="glass-2 rounded-3xl p-4 lg:p-5">
                <div class="text-xs font-semibold text-slate-600">Change summary</div>
                <div id="docSummary" class="mt-3 space-y-2 text-sm text-slate-700"></div>
                <div class="mt-4 border-t border-slate-900/10 pt-4">
                  <div class="text-xs font-semibold text-slate-600">Patch notes</div>
                  <div class="mt-2 text-xs leading-relaxed text-slate-600">
                    Distances are computed per-hunk between removed and added blocks (byte-level
                    Levenshtein in WASM), then summed.
                  </div>
                </div>
              </aside>
            </div>
          </section>

          <!-- Commit explorer -->
          <section id="sectionCommits" class="glass shadow-glow mt-6 rounded-3xl p-5">
            <div class="flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between">
              <div>
                <div class="text-sm font-bold text-slate-900">Commit Explorer</div>
                <div class="mt-1 text-xs text-slate-500">
                  Click a commit to expand its change groups and evidence excerpts.
                </div>
              </div>
              <div class="flex items-center gap-2">
                <div class="chip rounded-2xl px-3 py-1.5 text-xs font-semibold text-slate-700">
                  Showing <span id="showingCount" class="mono">-</span>
                </div>
              </div>
            </div>

            <div id="commitList" class="mt-4 grid grid-cols-1 gap-3"></div>
          </section>

          <!-- Alien telemetry -->
          <section id="sectionAlien" class="glass shadow-glow mt-6 rounded-3xl p-5">
            <div class="flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between">
              <div>
                <div class="text-sm font-bold text-slate-900">Alien Telemetry</div>
                <div class="mt-1 text-xs text-slate-500">
                  BOCPD change-point detection over commit impact (lines changed).
                </div>
              </div>
              <div class="chip rounded-2xl px-3 py-1.5 text-xs font-semibold text-slate-700">
                Hazard <span id="hazardLabel" class="mono">-</span>
              </div>
            </div>

            <div class="mt-4 grid grid-cols-1 gap-4 lg:grid-cols-[1fr_360px]">
              <div>
                <div id="bocpdChart" class="chart w-full"></div>
              </div>
              <div class="glass-2 rounded-3xl p-5">
                <div class="text-xs font-semibold text-slate-600">Galaxy Brain Card</div>
                <div class="mt-3 codebox rounded-2xl p-3">
                  <div class="mono text-[11px] leading-relaxed text-slate-900">
                    P(r_t | x_{1:t}) ∝ Σ_{r_{t-1}} P(x_t | r_t, …) · P(r_t | r_{t-1}) · P(r_{t-1} |
                    x_{1:t-1})
                  </div>
                </div>
                <p class="mt-3 text-xs leading-relaxed text-slate-600">
                  This page runs a tiny BOCPD model locally on the commit impact series (add+del).
                  With only 101 points, it is fast and deterministic. Change points are used only as
                  a lens, not a claim of truth.
                </p>
                <div class="mt-4">
                  <label class="text-xs font-semibold text-slate-600">Hazard H</label>
                  <input
                    id="hazard"
                    class="mt-2 w-full"
                    type="range"
                    min="0.01"
                    max="0.30"
                    step="0.01"
                    value="0.10"
                  />
                </div>
              </div>
            </div>
          </section>
        </main>
      </div>
    </div>

    <!-- Mobile filter sheet -->
    <div id="overlay" class="fixed inset-0 z-40 hidden bg-slate-900/30 backdrop-blur-sm"></div>
    <div
      id="sheet"
      class="sheet fixed bottom-0 left-0 right-0 z-50 hidden rounded-t-3xl border border-slate-900/10 bg-white/90 p-5 shadow-2xl backdrop-blur-xl"
    >
      <div class="flex items-center justify-between">
        <div class="text-sm font-bold text-slate-900">Filters</div>
        <button
          id="btnCloseSheet"
          class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-1.5 text-xs font-semibold text-slate-900 hover:bg-white"
          type="button"
        >
          Close
        </button>
      </div>
      <div class="mt-4">
        <label class="text-xs font-semibold text-slate-600">Search</label>
        <input
          id="qMobile"
          class="focus-ring mt-2 w-full rounded-2xl border border-slate-900/10 bg-white/70 px-3.5 py-2.5 text-sm text-slate-900 placeholder:text-slate-400"
          placeholder="commit, section, keyword..."
        />
      </div>
      <div class="mt-4">
        <div class="flex items-center justify-between">
          <label class="text-xs font-semibold text-slate-600">Min Impact</label>
          <div id="impactLabelMobile" class="mono text-xs text-slate-500">-</div>
        </div>
        <input id="impactMobile" class="mt-2 w-full" type="range" min="0" max="200" value="0" />
      </div>
      <div class="mt-5">
        <label class="text-xs font-semibold text-slate-600">Bucket Mode</label>
        <div class="mt-2 grid grid-cols-2 gap-2">
          <button
            id="modePrimaryMobile"
            class="focus-ring rounded-2xl border border-slate-900/10 bg-slate-900 px-3 py-2 text-xs font-semibold text-white"
            type="button"
          >
            Primary
          </button>
          <button
            id="modeMultiMobile"
            class="focus-ring rounded-2xl border border-slate-900/10 bg-white/70 px-3 py-2 text-xs font-semibold text-slate-900"
            type="button"
          >
            Multi-label
          </button>
        </div>
      </div>
      <div class="mt-5">
        <label class="text-xs font-semibold text-slate-600">Buckets</label>
        <div id="bucketTogglesMobile" class="mt-2 grid grid-cols-1 gap-2"></div>
      </div>
      <div class="mt-6 grid grid-cols-2 gap-2">
        <button
          id="btnResetMobile"
          class="focus-ring rounded-2xl border border-slate-900/10 bg-white/70 px-3 py-2 text-xs font-semibold text-slate-900 hover:bg-white"
          type="button"
        >
          Reset
        </button>
        <button
          id="btnApplyMobile"
          class="focus-ring rounded-2xl bg-slate-900 px-3 py-2 text-xs font-semibold text-white hover:bg-slate-800"
          type="button"
        >
          Apply
        </button>
      </div>
    </div>

    <!-- Mobile section summary sheet (bd-24q.8.3) -->
    <div id="sectionSheetOverlay" class="fixed inset-0 z-40 hidden bg-slate-900/30 backdrop-blur-sm"></div>
    <div
      id="sectionSheet"
      class="sheet fixed bottom-0 left-0 right-0 z-50 hidden rounded-t-3xl border border-slate-900/10 bg-white/90 p-5 shadow-2xl backdrop-blur-xl"
      style="max-height: 75vh"
    >
      <div class="flex items-center justify-between">
        <div class="text-sm font-bold text-slate-900">Section Changes</div>
        <button
          id="btnCloseSectionSheet"
          class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-1.5 text-xs font-semibold text-slate-900 hover:bg-white"
          type="button"
        >Close</button>
      </div>
      <input
        id="sectionFilterMobile"
        type="text"
        placeholder="Filter headings..."
        class="focus-ring mt-3 w-full rounded-2xl border border-slate-900/10 bg-white/70 px-3.5 py-2.5 text-sm text-slate-900 placeholder:text-slate-400"
      />
      <div id="sectionSheetList" class="mt-3 overflow-auto space-y-1" style="max-height: 55vh"></div>
    </div>

    <!-- History Search Palette (bd-24q.9.2) -->
    <div id="searchPaletteOverlay" class="search-palette-overlay hidden" role="dialog" aria-modal="true" aria-label="Search history">
      <div class="search-palette">
        <input id="searchPaletteInput" class="search-palette-input" type="text" placeholder="Search commits, sections, keywords... (use &quot;quotes&quot; for exact phrase)" autocomplete="off" spellcheck="false" />
        <div id="searchPaletteResults" class="search-palette-results">
          <div class="search-palette-hint">Type to search across all commits</div>
        </div>
        <div class="search-palette-footer">
          <span><kbd>&uarr;</kbd><kbd>&darr;</kbd> navigate</span>
          <span><kbd>Enter</kbd> jump</span>
          <span><kbd>Esc</kbd> close</span>
          <span class="ml-auto"><kbd>Ctrl</kbd>+<kbd>K</kbd></span>
        </div>
      </div>
    </div>

    <!-- Mobile Story Mode Sheet (bd-24q.4.3) -->
    <div id="storyMobileOverlay" class="story-mobile-overlay hidden" aria-hidden="true"></div>
    <div id="storyMobileSheet" class="story-mobile-sheet hidden" role="dialog" aria-label="Story milestones">
      <div class="shrink-0 flex items-center justify-between border-b border-slate-200 px-4 py-3">
        <span class="text-sm font-bold text-slate-900">Milestones</span>
        <span id="storyMobileProgress" class="text-[11px] font-semibold text-slate-400">0/0</span>
        <button id="btnStoryMobileClose" class="focus-ring rounded-lg px-2 py-1 text-xs font-semibold text-slate-500 hover:bg-slate-100" type="button">Close</button>
      </div>
      <div id="storyMobileCardArea" class="story-mobile-card"></div>
      <div class="shrink-0 flex items-center justify-between gap-3 border-t border-slate-200 px-4 py-3">
        <button id="storyMobilePrev" class="focus-ring flex-1 rounded-2xl bg-slate-100 px-4 py-3 text-sm font-semibold text-slate-700 hover:bg-slate-200" type="button">&larr; Previous</button>
        <button id="storyMobileAutoplay" class="focus-ring flex-1 rounded-2xl bg-slate-100 px-4 py-3 text-sm font-semibold text-slate-700 hover:bg-slate-200" type="button" aria-label="Autoplay tour">&#9654; Tour</button>
        <button id="storyMobileNext" class="focus-ring flex-1 rounded-2xl bg-slate-900 px-4 py-3 text-sm font-semibold text-white hover:bg-slate-800" type="button">Next &rarr;</button>
      </div>
    </div>

    <!-- Mobile Mini-Map Sheet (bd-24q.2.3) -->
    <div id="miniMapMobileOverlay" class="minimap-mobile-overlay hidden" aria-hidden="true"></div>
    <div id="miniMapMobileSheet" class="minimap-mobile-sheet hidden" role="dialog" aria-label="Document outline">
      <div class="shrink-0 flex items-center justify-between border-b border-slate-200 px-4 py-3">
        <span class="text-sm font-bold text-slate-900">Outline</span>
        <label class="flex items-center gap-1.5 text-[10px] text-slate-500">
          <input id="miniMapMobileStayOpen" type="checkbox" class="rounded" />
          Stay open
        </label>
        <button id="btnMiniMapMobileClose" class="focus-ring rounded-lg px-2 py-1 text-xs font-semibold text-slate-500 hover:bg-slate-100" type="button">Close</button>
      </div>
      <div class="shrink-0 px-4 py-2">
        <input
          id="miniMapMobileSearch"
          type="text"
          placeholder="Filter headings..."
          class="focus-ring w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 placeholder-slate-400"
        />
      </div>
      <div id="miniMapMobileList" class="flex-1 overflow-auto px-2 py-2 space-y-1"></div>
    </div>

    <!-- Timeline dock -->
    <div id="dock" class="dock fixed inset-x-0 bottom-0 z-30 px-4 py-3">
      <div class="mx-auto max-w-[1200px]">
        <div class="flex items-center justify-between gap-3">
          <div class="min-w-0 flex items-center gap-2">
            <button
              id="dockCollapseToggle"
              class="sm:hidden focus-ring inline-flex h-6 w-6 items-center justify-center rounded-lg border border-slate-900/10 bg-white/70 text-[10px] font-bold text-slate-600 hover:bg-white"
              type="button"
              aria-label="Toggle dock"
            >&#9650;</button>
            <div>
              <div class="text-[11px] font-semibold text-slate-500">Timeline scrubber</div>
              <div id="dockTitle" class="mt-0.5 truncate text-xs font-semibold text-slate-900">-</div>
            </div>
          </div>
          <div class="shrink-0 flex items-center gap-2">
            <button
              id="dockPrev"
              class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-2.5 text-[11px] font-semibold text-slate-900 hover:bg-white"
              type="button"
              aria-label="Previous commit"
            >
              Prev
            </button>
            <button
              id="dockPlayPause"
              class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-2.5 text-[11px] font-semibold text-slate-900 hover:bg-white min-w-[3.5rem]"
              type="button"
              aria-label="Play or pause timeline playback"
            >
              &#9654;
            </button>
            <button
              id="dockNext"
              class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-2.5 text-[11px] font-semibold text-slate-900 hover:bg-white"
              type="button"
              aria-label="Next commit"
            >
              Next
            </button>
            <select
              id="dockSpeed"
              class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-2 py-2 text-[11px] font-semibold text-slate-900 hover:bg-white cursor-pointer"
              aria-label="Playback speed"
            >
              <option value="0.25">0.25x</option>
              <option value="0.5">0.5x</option>
              <option value="1" selected>1x</option>
              <option value="2">2x</option>
              <option value="4">4x</option>
            </select>
            <button
              id="dockLoop"
              class="focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-2.5 py-2.5 text-[11px] font-semibold text-slate-500 hover:bg-white"
              type="button"
              aria-label="Toggle loop playback"
              title="Loop"
            >
              &#x1F501;
            </button>
          </div>
        </div>

        <div id="dockBody">
          <canvas
            id="dockCanvas"
            class="dock-canvas mt-2 rounded-2xl border border-slate-900/10 bg-white/70"
          ></canvas>
          <input id="dockSlider" class="dock-slider mt-2" type="range" min="0" max="1" value="0" />
          <canvas
            id="dockHeatStripe"
            class="dock-heat-stripe mt-1"
            aria-label="Heat stripe showing bucket density over time"
          ></canvas>
          <div id="dockHeatTooltip" class="dock-heat-tooltip hidden" aria-hidden="true"></div>
          <div class="mt-1 flex items-center justify-between text-[11px] text-slate-500">
            <div id="dockLeftLabel" class="mono">-</div>
            <div id="dockRightLabel" class="mono">-</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Dependencies (deferred to avoid blocking first paint) -->
	    <script defer src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
	    <script defer src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>
	    <script defer src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/plugin/utc.js"></script>
	    <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
	    <script defer src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js"></script>
	    <script defer src="https://cdn.jsdelivr.net/npm/dompurify@3.1.0/dist/purify.min.js"></script>
	    <script defer src="https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html.min.js"></script>
	    <script defer src="https://cdn.jsdelivr.net/npm/diff@7.0.0/dist/diff.min.js"></script>

	    <script type="module">
	      const { dayjs, echarts, hljs, markdownit, DOMPurify, Diff2Html, Diff } = window;

      // Extend dayjs with UTC plugin for timezone-aware binning.
      if (dayjs && window.dayjs_plugin_utc) dayjs.extend(window.dayjs_plugin_utc);

      // requestIdleCallback polyfill (Safari < 16.4)
      if (typeof requestIdleCallback === "undefined") {
        window.requestIdleCallback = function (cb) {
          const start = Date.now();
          return setTimeout(() => {
            cb({
              didTimeout: false,
              timeRemaining: () => Math.max(0, 50 - (Date.now() - start)),
            });
          }, 1);
        };
        window.cancelIdleCallback = function (id) {
          clearTimeout(id);
        };
      }

      // -----------------------------
      // Data: commit metadata + stats
      // -----------------------------

      // All spec evolution data (commits, patches, base doc, and classification change-groups)
      // is loaded from a SQLite DB via sql.js (see loadEvolutionDataset()).

      const CSS_CACHE = new Map();
      function getCss(varName) {
        if (CSS_CACHE.has(varName)) return CSS_CACHE.get(varName);
        const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        CSS_CACHE.set(varName, v);
        return v;
      }

      // -----------------------------
      // Buckets
      // -----------------------------

      const BUCKETS = [
        {
          id: 1,
          name: "Logic/Math Fixes",
          desc: "Fixing outright mistakes in logic, math, or reasoning.",
          color: getCss("--c1"),
        },
        {
          id: 2,
          name: "SQLite Legacy Corrections",
          desc: "Fixing inaccurate statements about the C SQLite codebase or semantics.",
          color: getCss("--c2"),
        },
        {
          id: 3,
          name: "asupersync Corrections",
          desc: "Fixing inaccurate statements about asupersync APIs or behavior.",
          color: getCss("--c3"),
        },
        {
          id: 4,
          name: "Architecture Fixes",
          desc: "Fixing conceptual errors or architectural mistakes.",
          color: getCss("--c4"),
        },
        {
          id: 5,
          name: "Scrivening",
          desc: "Ministerial fixes: numbering, references, footers, wording cleanup.",
          color: getCss("--c5"),
        },
        {
          id: 6,
          name: "Added Context",
          desc: "Added background information to make the spec more self-contained.",
          color: getCss("--c6"),
        },
        {
          id: 7,
          name: "Standard Engineering",
          desc: "Improvements based on standard computer engineering: cache, concurrency, I/O, durability mechanics.",
          color: getCss("--c7"),
        },
        {
          id: 8,
          name: "Alien Artifact Math",
          desc: "Esoteric math/rigor additions: e-processes, conformal, BOCPD, VOI, proofs, bounds.",
          color: getCss("--c8"),
        },
        {
          id: 9,
          name: "Clarification",
          desc: "Clarification/elaboration without substantive improvements or fixes.",
          color: getCss("--c9"),
        },
        {
          id: 10,
          name: "Other",
          desc: "Catch-all category.",
          color: getCss("--c10"),
        },
      ];

      // Story Mode: Milestone Schema + Curated Data (bd-24q.4.1)
      const MILESTONES = [
        { id: "genesis", title: "Genesis: 8,628 Lines", commitHash: "c08f160", annotationMd: "The spec is born. A single massive commit lays down the entire architectural blueprint: MVCC page-level versioning, RaptorQ erasure coding, asupersync integration, and the 23-crate workspace structure.", defaultTab: "spec" },
        { id: "ssi-promotion", title: "SSI Promoted to V1", commitHash: "f9d88aa", annotationMd: "Serializable Snapshot Isolation promoted from future goal to V1 requirement. Intent logs, sharded lock tables, and the conservative Page-SSI rule introduced.", focusHeading: "serializable-snapshot-isolation-ssi", defaultTab: "diff" },
        { id: "scope-doctrine", title: "V1.3: Scope Doctrine", commitHash: "9800b17", annotationMd: "\"There is no V1 scope\" \u2014 everything ships. ECS substrate, multi-process MVCC, encryption, WindowsVfs all mandatory.", defaultTab: "diff" },
        { id: "codex-synthesis", title: "V1.4: Codex Synthesis", commitHash: "5ad3487", annotationMd: "Codex (GPT-5.3) spec merged. RaptorQ pervasive: WAL sidecar, ECS layout, replication. Spec crosses 9,000 lines.", defaultTab: "diff" },
        { id: "alien-artifact", title: "V1.5: Alien-Artifact Discipline", commitHash: "7b2c677", annotationMd: "Decision-theoretic rigor: BOCPD, e-process monitoring, conformal calibration. SSI abort gets formal loss matrix. Spec crosses 10,000 lines.", focusHeading: "decision-theoretic-ssi-abort-policy", defaultTab: "diff" },
        { id: "witness-plane", title: "V1.6a: RaptorQ Witness Plane", commitHash: "bf04264", annotationMd: "SSI gains RaptorQ-native witness plane for cross-process proof-carrying commits.", defaultTab: "diff" },
        { id: "perf-optimizations", title: "V1.6c: Performance Hardening", commitHash: "e8ddf46", annotationMd: "Arena allocators, CAR/CLOCK-Pro cache, per-invariant e-process calibration. Cache-line alignment scrutiny.", defaultTab: "diff" },
        { id: "canonical-ssi", title: "V1.6g: Canonical SSI Algorithm", commitHash: "643c89c", annotationMd: "SSI detection algorithm reaches final form. Canonical proof-carrying commit with eager abort.", defaultTab: "diff" },
        { id: "deep-audit-mvcc", title: "V1.7: MVCC Deep Audit", commitHash: "d7b38ef", annotationMd: "Word-by-word audit of Section 5 (~3,000 lines). Finds SSI incoming-edge false negative. RecentlyCommittedReadersIndex added.", focusHeading: "mvcc-formal-model", defaultTab: "diff" },
        { id: "deep-audit-raptorq", title: "V1.7e: RaptorQ Deep Audit", commitHash: "3cf0f13", annotationMd: "Section 3 audit: MTU/sub-blocking fixes, ESI/ISI confusion, OTI.T u16\u2192u32. GF(256) verified against RFC 6330.", defaultTab: "diff" },
        { id: "deep-audit-query", title: "V1.7h: Query Pipeline Audit", commitHash: "2f0970b", annotationMd: "Section 10: lexer DQS, cost model, UPDATE trace. Ne/BangEq fixed. ESCAPE removed from Pratt table.", defaultTab: "diff" },
        { id: "deep-audit-fts5", title: "V1.7j: FTS5 + SQL Coverage", commitHash: "a3e7ae5", annotationMd: "Section 14: FTS5 NOT binary-only. Full section-by-section audit coverage reached.", defaultTab: "diff" },
      ];
      /** Resolve milestones against loaded commit data. Call after ALL_COMMITS is populated. */
      function getMilestones() {
        if (!ALL_COMMITS || !ALL_COMMITS.length) return [];
        const hashToIdx = new Map();
        for (let i = 0; i < ALL_COMMITS.length; i++) {
          const c = ALL_COMMITS[i];
          hashToIdx.set(c.hash, i);
          if (c.short) hashToIdx.set(c.short, i);
        }
        return MILESTONES.map((m) => {
          const idx = hashToIdx.get(m.commitHash) ?? null;
          if (idx === null) console.warn(`Milestone "${m.id}": commit ${m.commitHash} not found`);
          return { ...m, commitIdx: idx, warning: idx === null ? `commit ${m.commitHash} not found` : null };
        });
      }

      // -----------------------------
      // App state
      // -----------------------------

      const STATE = {
        q: "",
        minImpact: 0,
        bucketMode: "primary", // 'primary' | 'multi'
        bucketEnabled: new Set(BUCKETS.map((b) => b.id)),
      };

      // -----------------------------
      // Spec evolution database (SQLite via sql.js WASM)
      // -----------------------------

      const SPEC_EVOLUTION_DB_URL = "spec_evolution_v1.sqlite3";
      const SPEC_EVOLUTION_DB_CONFIG_URL = "spec_evolution_v1.sqlite3.config.json";

      const DB_STATE = {
        sql: null,        // sql.js module
        cacheKey: null,   // config.hash (used for OPFS cache filename)
        source: "none",   // "cache" | "network" | "none"
      };

      const DATASET = {
        db: null,       // SQL.Database
        meta: null,     // { key: value }
        baseDoc: "",    // base spec snapshot (commit 0)
        loaded: false,
        error: null,
      };

      const DOC = {
        idx: 0,
        tab: "spec", // 'spec' | 'diff' | 'metrics'
        rawSpec: false,
        diffMode: "pretty", // 'pretty' | 'raw'
        compareMode: false, // true = A/B compare between two arbitrary commits
        compareFromIdx: 0, // "A" commit index
        compareToIdx: 0, // "B" commit index
        diffLayout: "side-by-side", // 'side-by-side' | 'line-by-line'
        diffCollapse: true, // collapse unchanged context in A/B diffs
        abViewMode: "diff", // 'diff' | 'rendered' — diff shows Diff2Html, rendered shows side-by-side markdown panes
        sbsSyncScroll: true, // sync scroll between side-by-side panes
        sbsMobilePane: "a", // 'a' | 'b' — which pane visible on mobile portrait
        inlineHighlights: false, // bd-24q.16.2: show inline change highlights in spec view
      };

      const METRICS = {
        // commit hash -> metric
        tokensChanged: new Map(),
        bytesChanged: new Map(),
        hunks: new Map(),
        lev: new Map(),
      };


      // --- Cache Layer (bd-24q.5.2) ---
      const CACHE_SCHEMA_VERSION = 2;

      /**
       * LRU Memory Cache with bounded capacity.
       * Keying: (datasetHash, op, params) → serialized key.
       * Evicts oldest entry when capacity reached.
       */
      class LruCache {
        constructor(maxEntries) {
          this._max = maxEntries;
          this._map = new Map(); // key → value (insertion order = access order)
        }

        _makeKey(op, params) {
          return `${WORKER_STATE.datasetHash || ""}:${op}:${JSON.stringify(params || {})}`;
        }

        get(op, params) {
          const key = this._makeKey(op, params);
          if (!this._map.has(key)) return undefined;
          const val = this._map.get(key);
          // Move to end (most recently used).
          this._map.delete(key);
          this._map.set(key, val);
          return val;
        }

        set(op, params, value) {
          const key = this._makeKey(op, params);
          if (this._map.has(key)) this._map.delete(key);
          this._map.set(key, value);
          // Evict oldest if over capacity.
          while (this._map.size > this._max) {
            const oldest = this._map.keys().next().value;
            this._map.delete(oldest);
          }
        }

        has(op, params) {
          return this._map.has(this._makeKey(op, params));
        }

        clear() { this._map.clear(); }
        get size() { return this._map.size; }
      }

      /**
       * localStorage-backed cache with schema versioning and eviction.
       * Stores JSON-serializable values keyed by (namespace, op, params, datasetHash).
       * Clears on schema version mismatch.
       */
      const LS_CACHE_PREFIX = "fsqlite_viz_cache_";
      const LS_CACHE_META_KEY = "fsqlite_viz_cache_meta";
      const LS_CACHE_MAX_ENTRIES = 20;

      function lsCacheInit() {
        try {
          const raw = localStorage.getItem(LS_CACHE_META_KEY);
          if (raw) {
            const meta = JSON.parse(raw);
            if (meta.schemaVersion !== CACHE_SCHEMA_VERSION) {
              console.log("[cache] Schema version mismatch (" + meta.schemaVersion + " vs " + CACHE_SCHEMA_VERSION + "), clearing localStorage cache");
              lsCacheClear();
              localStorage.setItem(LS_CACHE_META_KEY, JSON.stringify({ schemaVersion: CACHE_SCHEMA_VERSION, keys: [] }));
            }
          } else {
            localStorage.setItem(LS_CACHE_META_KEY, JSON.stringify({ schemaVersion: CACHE_SCHEMA_VERSION, keys: [] }));
          }
        } catch (e) { console.warn("[cache] localStorage init failed:", e); }
      }

      function lsCacheKey(op, params) {
        return LS_CACHE_PREFIX + op + "_" + (WORKER_STATE.datasetHash || "none") + "_" + JSON.stringify(params || {});
      }

      function lsCacheGet(op, params) {
        try {
          const raw = localStorage.getItem(lsCacheKey(op, params));
          return raw ? JSON.parse(raw) : undefined;
        } catch { return undefined; }
      }

      function lsCacheSet(op, params, value) {
        try {
          const key = lsCacheKey(op, params);
          localStorage.setItem(key, JSON.stringify(value));
          // Update meta with key list for eviction.
          const meta = JSON.parse(localStorage.getItem(LS_CACHE_META_KEY) || "{}");
          const keys = meta.keys || [];
          const idx = keys.indexOf(key);
          if (idx !== -1) keys.splice(idx, 1);
          keys.push(key);
          // Evict oldest if over limit.
          while (keys.length > LS_CACHE_MAX_ENTRIES) {
            const old = keys.shift();
            try { localStorage.removeItem(old); } catch { /* ignore */ }
          }
          meta.keys = keys;
          meta.schemaVersion = CACHE_SCHEMA_VERSION;
          localStorage.setItem(LS_CACHE_META_KEY, JSON.stringify(meta));
        } catch (e) { console.warn("[cache] localStorage set failed:", e); }
      }

      function lsCacheClear() {
        try {
          const meta = JSON.parse(localStorage.getItem(LS_CACHE_META_KEY) || "{}");
          const keys = meta.keys || [];
          for (const k of keys) {
            try { localStorage.removeItem(k); } catch { /* ignore */ }
          }
          localStorage.removeItem(LS_CACHE_META_KEY);
        } catch { /* ignore */ }
      }

      // Shared memory cache instance (128 entries max).
      const WORKER_RESULT_CACHE = new LruCache(128);

      const DOC_CACHE = new Map(); // idx -> { text: string, lines?: string[] }

      const OUTLINE_CACHE = new Map(); // idx -> outline[]

      const LEV_WASM_URL = "levenshtein_bytes.wasm";
      let LEV_WASM = null;

      const WORKER_STATE = {
        worker: null,
        ready: false,
        disabled: false,
        reqSeq: 1,
        pending: new Map(), // reqId -> { resolve, reject, onProgress, timeoutId }
        datasetHash: "",
      };

      const WORKER_DERIVED = {
        searchReady: false,
        clusterReady: false,
        mostEditedReady: false,
        phase: null,
        phaseKey: "",
        outliers: null,
        outlierKey: "",
      };

      let COMPUTE_ABORT_CONTROLLER = null;
      let PHASE_ABORT_CONTROLLER = null;
      let OUTLIER_ABORT_CONTROLLER = null;

      // -----------------------------
      // URL State Schema (Permalinks) — v1
      // -----------------------------
      // Canonical param order: v, c, t, raw, dm, q, mi, bm, b
      // Default values are omitted for minimal URLs.
      // Invalid values are clamped or reset to defaults.

      const URL_SCHEMA_VERSION = 1;

      const URL_DEFAULTS = {
        c: -1,          // commit index; -1 means "latest"
        t: "spec",      // tab: spec | diff | metrics
        raw: false,     // raw spec toggle
        dm: "pretty",   // diff mode: pretty | raw
        q: "",          // search query
        mi: 0,          // minimum impact filter
        bm: "primary",  // bucket mode: primary | multi
        b: null,        // enabled bucket ids; null = all
        res: "commit",  // stack chart resolution: commit | day | hour | 15m | 5m
        tz: "local",    // timezone mode: local | utc
        met: "groups",  // stack chart metric: groups | lines | tokens | lev
      };

      const URL_VALID_TABS = new Set(["spec", "diff", "metrics", "sections"]);
      const URL_VALID_DIFF_MODES = new Set(["pretty", "raw"]);
      const URL_VALID_BUCKET_MODES = new Set(["primary", "multi"]);
      const URL_VALID_RESOLUTIONS = new Set(["commit", "day", "hour", "15m", "5m"]);
      const URL_VALID_TZ_MODES = new Set(["local", "utc"]);
      const URL_VALID_METRICS = new Set(["groups", "lines", "tokens", "lev"]);
      const URL_ALL_BUCKET_IDS = new Set(BUCKETS.map((b) => b.id));

      function encodeUrlState() {
        const p = new URLSearchParams();
        const maxIdx = Math.max(0, (ALL_COMMITS?.length || 1) - 1);

        // Always include version when any non-default param is present.
        // We build params first, then prepend v= if non-empty.

        if (DOC.idx !== maxIdx && DOC.idx >= 0) p.set("c", String(DOC.idx));
        if (DOC.tab !== URL_DEFAULTS.t && URL_VALID_TABS.has(DOC.tab)) p.set("t", DOC.tab);
        if (DOC.rawSpec) p.set("raw", "1");
        if (DOC.diffMode !== URL_DEFAULTS.dm && URL_VALID_DIFF_MODES.has(DOC.diffMode)) p.set("dm", DOC.diffMode);
        if (STATE.q) p.set("q", STATE.q);
        if (STATE.minImpact > 0) p.set("mi", String(STATE.minImpact));
        if (STATE.bucketMode !== URL_DEFAULTS.bm) p.set("bm", STATE.bucketMode);

        // Stack chart resolution, timezone, metric (bd-24q.12.2).
        const resSel = document.getElementById("stackResolution");
        const tzSel = document.getElementById("stackTimezone");
        const metSel = document.getElementById("stackMetric");
        const curRes = resSel?.value || URL_DEFAULTS.res;
        const curTz = tzSel?.value || URL_DEFAULTS.tz;
        const curMet = metSel?.value || URL_DEFAULTS.met;
        if (curRes !== URL_DEFAULTS.res) p.set("res", curRes);
        if (curTz !== URL_DEFAULTS.tz) p.set("tz", curTz);
        if (curMet !== URL_DEFAULTS.met) p.set("met", curMet);

        // Encode enabled buckets only if not all are enabled.
        const allEnabled = URL_ALL_BUCKET_IDS.size === STATE.bucketEnabled.size &&
          [...URL_ALL_BUCKET_IDS].every((id) => STATE.bucketEnabled.has(id));
        if (!allEnabled) {
          const sorted = [...STATE.bucketEnabled].sort((a, b) => a - b);
          p.set("b", sorted.join(","));
        }

        // Story autoplay URL state (bd-24q.4.4).
        if (typeof STORY_AUTOPLAY !== "undefined" && STORY_AUTOPLAY.enabled) {
          p.set("sa", "1");
          if (STORY_AUTOPLAY.milestoneIdx >= 0) p.set("si", String(STORY_AUTOPLAY.milestoneIdx));
        }

        // Inline highlights URL state (bd-24q.16.2).
        if (DOC.inlineHighlights) p.set("ih", "1");

        // Canonical ordering: rebuild with v first, then alphabetical key order.
        if ([...p.keys()].length === 0) return "";
        const canon = new URLSearchParams();
        canon.set("v", String(URL_SCHEMA_VERSION));
        // Canonical key order: v, c, t, raw, dm, cmp, ca, cb, dl, avm, q, mi, bm, b, res, tz, met, sa, si, ih
        if (DOC.compareMode) { p.set("cmp", "1"); p.set("ca", String(DOC.compareFromIdx)); p.set("cb", String(DOC.compareToIdx)); if (DOC.diffLayout !== "side-by-side") p.set("dl", DOC.diffLayout); if (DOC.abViewMode === "rendered") p.set("avm", "rendered"); }
        for (const k of ["c", "t", "raw", "dm", "cmp", "ca", "cb", "dl", "avm", "q", "mi", "bm", "b", "res", "tz", "met", "sa", "si", "ih"]) {
          if (p.has(k)) canon.set(k, p.get(k));
        }
        return canon.toString();
      }

      function decodeUrlState(search) {
        const p = new URLSearchParams(search || "");
        if (!p.has("v")) return null; // No URL state present.

        const v = Number(p.get("v"));
        if (v !== URL_SCHEMA_VERSION) return null; // Unknown schema version; ignore.

        const result = {};

        // Commit index.
        if (p.has("c")) {
          const raw = Number(p.get("c"));
          result.c = Number.isFinite(raw) && raw >= 0 ? Math.floor(raw) : URL_DEFAULTS.c;
        } else {
          result.c = URL_DEFAULTS.c;
        }

        // Tab.
        const tab = p.get("t") || URL_DEFAULTS.t;
        result.t = URL_VALID_TABS.has(tab) ? tab : URL_DEFAULTS.t;

        // Raw spec.
        result.raw = p.get("raw") === "1";

        // Diff mode.
        const dm = p.get("dm") || URL_DEFAULTS.dm;
        result.dm = URL_VALID_DIFF_MODES.has(dm) ? dm : URL_DEFAULTS.dm;

        // Search query.
        result.q = p.get("q") || URL_DEFAULTS.q;

        // Min impact.
        if (p.has("mi")) {
          const mi = Number(p.get("mi"));
          result.mi = Number.isFinite(mi) && mi >= 0 ? Math.floor(mi) : URL_DEFAULTS.mi;
        } else {
          result.mi = URL_DEFAULTS.mi;
        }

        // Bucket mode.
        const bm = p.get("bm") || URL_DEFAULTS.bm;
        result.bm = URL_VALID_BUCKET_MODES.has(bm) ? bm : URL_DEFAULTS.bm;

        // Enabled buckets.
        if (p.has("b")) {
          const ids = p.get("b").split(",")
            .map((s) => Number(s.trim()))
            .filter((n) => Number.isFinite(n) && URL_ALL_BUCKET_IDS.has(n));
          result.b = ids.length > 0 ? new Set(ids) : new Set(URL_ALL_BUCKET_IDS);
        } else {
          result.b = null; // null = all enabled
        }

        // Stack chart resolution, timezone, metric (bd-24q.12.2).
        const res = p.get("res") || URL_DEFAULTS.res;
        result.res = URL_VALID_RESOLUTIONS.has(res) ? res : URL_DEFAULTS.res;
        const tz = p.get("tz") || URL_DEFAULTS.tz;
        result.tz = URL_VALID_TZ_MODES.has(tz) ? tz : URL_DEFAULTS.tz;
        const met = p.get("met") || URL_DEFAULTS.met;
        result.met = URL_VALID_METRICS.has(met) ? met : URL_DEFAULTS.met;

        // A/B Compare mode.
        result.cmp = p.get("cmp") === "1";
        if (result.cmp) {
          const ca = Number(p.get("ca")); result.ca = Number.isFinite(ca) && ca >= 0 ? Math.floor(ca) : 0;
          const cb = Number(p.get("cb")); result.cb = Number.isFinite(cb) && cb >= 0 ? Math.floor(cb) : 0;
          const dl = p.get("dl") || "side-by-side";
          result.dl = (dl === "line-by-line") ? "line-by-line" : "side-by-side";
          result.avm = p.get("avm") || "diff";
        }

        // Story autoplay (bd-24q.4.4).
        result.sa = p.get("sa") === "1";
        if (p.has("si")) {
          const si = Number(p.get("si"));
          result.si = Number.isFinite(si) && si >= 0 ? Math.floor(si) : -1;
        } else {
          result.si = -1;
        }

        // Inline highlights (bd-24q.16.2).
        result.ih = p.get("ih") === "1";

        return result;
      }

      function applyUrlState(s) {
        if (!s) return;
        const maxIdx = Math.max(0, (ALL_COMMITS?.length || 1) - 1);

        // Commit index: -1 means latest, otherwise clamp.
        DOC.idx = s.c < 0 ? maxIdx : clamp(s.c, 0, maxIdx);
        DOC.tab = s.t;
        DOC.rawSpec = s.raw;
        DOC.diffMode = s.dm;
        STATE.q = s.q;
        STATE.minImpact = s.mi;
        STATE.bucketMode = s.bm;
        STATE.bucketEnabled = s.b ? new Set(s.b) : new Set(URL_ALL_BUCKET_IDS);
        if (s.cmp) { DOC.compareMode = true; DOC.compareFromIdx = clamp(s.ca || 0, 0, maxIdx); DOC.compareToIdx = clamp(s.cb || 0, 0, maxIdx); DOC.diffLayout = s.dl || "side-by-side"; DOC.abViewMode = s.avm === "rendered" ? "rendered" : "diff"; }
        DOC.inlineHighlights = Boolean(s.ih); // bd-24q.16.2

        // Sync UI inputs to match restored state.
        const qEl = document.getElementById("q");
        const qMob = document.getElementById("qMobile");
        if (qEl) qEl.value = STATE.q;
        if (qMob) qMob.value = STATE.q;

        const impactEl = document.getElementById("impact");
        const impactMob = document.getElementById("impactMobile");
        if (impactEl) impactEl.value = String(STATE.minImpact);
        if (impactMob) impactMob.value = String(STATE.minImpact);

        // Restore stack chart controls from URL state (bd-24q.12.2).
        const resSel = document.getElementById("stackResolution");
        const tzSel = document.getElementById("stackTimezone");
        const metSel = document.getElementById("stackMetric");
        if (resSel && s.res) resSel.value = s.res;
        if (tzSel && s.tz) tzSel.value = s.tz;
        if (metSel && s.met) metSel.value = s.met;

        // Restore story autoplay from URL (bd-24q.4.4).
        if (s.sa && typeof STORY_AUTOPLAY !== "undefined") {
          // Defer until after initial render so milestones are available.
          requestAnimationFrame(() => {
            _storyMilestones = getMilestones().filter(m => m.commitIdx !== null);
            if (_storyMilestones.length) {
              _storyAutoplayBuildSet();
              STORY_AUTOPLAY.enabled = true;
              STORY_AUTOPLAY.milestoneIdx = (s.si >= 0 && s.si < _storyMilestones.length) ? s.si : -1;
              STORY_AUTOPLAY.pausedAtMilestone = false;
              // Show story rail.
              const rail = document.getElementById("storyRail");
              if (rail?.classList.contains("hidden")) {
                rail.classList.remove("hidden");
                const btn = document.getElementById("btnStoryToggle");
                if (btn) { btn.classList.add("bg-slate-900", "text-white"); btn.classList.remove("bg-white/70", "text-slate-900"); }
              }
              renderStoryCards();
              _syncStoryAutoplayUI();
              // Auto-resume playback.
              playbackPlay();
            }
          });
        }
      }

      let _urlSyncScheduled = false;

      function syncUrlToState(opts = {}) {
        // Debounce: avoid thrashing history on rapid slider moves.
        if (_urlSyncScheduled && !opts.immediate) return;
        _urlSyncScheduled = true;
        requestAnimationFrame(() => {
          _urlSyncScheduled = false;
          const qs = encodeUrlState();
          const newUrl = qs ? `${location.pathname}?${qs}` : location.pathname;
          if (location.search !== (qs ? `?${qs}` : "")) {
            history.replaceState(null, "", newUrl);
          }
        });
      }

      function copyPermalink() {
        const qs = encodeUrlState();
        const url = qs
          ? `${location.origin}${location.pathname}?${qs}`
          : `${location.origin}${location.pathname}`;
        if (navigator.clipboard?.writeText) {
          navigator.clipboard.writeText(url).then(() => {
            showCopyToast("Link copied");
          }, () => {
            fallbackCopy(url);
          });
        } else {
          fallbackCopy(url);
        }
      }

      function fallbackCopy(text) {
        const ta = document.createElement("textarea");
        ta.value = text;
        ta.style.position = "fixed";
        ta.style.opacity = "0";
        document.body.appendChild(ta);
        ta.select();
        try {
          document.execCommand("copy");
          showCopyToast("Link copied");
        } catch {
          showCopyToast("Copy failed");
        }
        document.body.removeChild(ta);
      }

      function showCopyToast(msg) {
        const btn = document.getElementById("btnCopyLink");
        if (!btn) return;
        const orig = btn.textContent;
        btn.textContent = msg;
        btn.classList.add("bg-emerald-600", "text-white");
        btn.classList.remove("bg-white/70", "text-slate-900");
        setTimeout(() => {
          btn.textContent = orig;
          btn.classList.remove("bg-emerald-600", "text-white");
          btn.classList.add("bg-white/70", "text-slate-900");
        }, 1500);
      }

      function toggleShareHelp() {
        const el = document.getElementById("shareHelpPopover");
        if (el) el.classList.toggle("hidden");
      }

      // -----------------------------
      // Helpers
      // -----------------------------

      function clamp(n, lo, hi) {
        return Math.max(lo, Math.min(hi, n));
      }

      function escapeHtml(s) {
        return String(s)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#39;");
      }

      function fmtInt(n) {
        return Intl.NumberFormat(undefined).format(n);
      }

      function debounce(fn, ms) {
        let t;
        return function (...args) {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(this, args), ms);
        };
      }

	      function parseCommitLog() {
	        if (!DATASET.db) throw new Error("DB not loaded");
	        const rows = dbQuery(
	          `SELECT idx, hash, short, date_iso AS dateIso, author, subject, url
	           FROM commits
	           ORDER BY idx ASC`,
	        );
	        return rows.map((r) => ({
	          idx: Number(r.idx || 0),
	          hash: String(r.hash || ""),
	          short: String(r.short || ""),
	          dateIso: String(r.dateIso || ""),
	          author: String(r.author || ""),
	          subject: String(r.subject || ""),
	          url: String(r.url || ""),
	        }));
	      }

		      function parseCommitStats() {
		        if (!DATASET.db) throw new Error("DB not loaded");
		        const rows = dbQuery(
		          `SELECT hash, add_lines, del_lines, impact
		           FROM commits`,
		        );
		        const m = new Map();
		        for (const r of rows) {
		          const h = String(r.hash || "");
		          m.set(h, {
		            add: Number(r.add_lines || 0),
		            del: Number(r.del_lines || 0),
		            impact: Number(r.impact || 0),
		          });
		        }
		        return m;
		      }

      function formatErr(e) {
        const name = e?.name || "Error";
        const message = e?.message || String(e || "Unknown error");
        const stack = e?.stack ? String(e.stack) : "";
        return stack ? `${name}: ${message}\n${stack}` : `${name}: ${message}`;
      }

      function setWorkerStatus(text, tone = "neutral", detail = "") {
        const el = document.getElementById("workerStatus");
        if (!el) return;
        el.textContent = text || "";
        el.title = detail ? String(detail) : "";
        if (tone === "error") {
          el.className = "mt-2 text-xs font-semibold text-rose-700";
        } else if (tone === "ok") {
          el.className = "mt-2 text-xs font-semibold text-emerald-700";
        } else {
          el.className = "mt-2 text-xs text-slate-500";
        }
      }

      function supportsAnalysisWorker() {
        return typeof Worker !== "undefined" && typeof URL !== "undefined" && typeof Blob !== "undefined";
      }

      function toHex(buf) {
        return Array.from(new Uint8Array(buf))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }

      async function computeDatasetHash(data) {
        const commitHashes = Array.isArray(data?.commits) ? data.commits.map((c) => String(c.hash || "")) : [];
        const patchSizes = Array.isArray(data?.patches) ? data.patches.map((p) => String((p || "").length)) : [];
        const basis = `${String(data?.base_doc || "").length}|${commitHashes.join(",")}|${patchSizes.join(",")}`;
        const enc = new TextEncoder().encode(basis);
        if (crypto?.subtle?.digest) {
          const dig = await crypto.subtle.digest("SHA-256", enc);
          return toHex(dig);
        }
        // Fallback hash (djb2 xor), deterministic but non-cryptographic.
        let h = 5381;
        for (let i = 0; i < basis.length; i++) {
          h = ((h << 5) + h) ^ basis.charCodeAt(i);
        }
        return `djb2-${(h >>> 0).toString(16)}`;
      }

      function makeAnalysisWorkerSource() {
        return `
          const LEV_WASM_URL = ${JSON.stringify(LEV_WASM_URL)};
          const STATE = {
            dataset: null,
            datasetHash: "",
            patchHunks: [],
            snapshotCache: new Map(),
            snapshotCursorIdx: 0,
            snapshotCursorLines: null,
            levWasm: null,
            searchIndex: null,
            clusterData: null,
            minhashSignatures: null,
            mostEditedSections: null,
          };
          const CANCELLED_REQS = new Set();

          class AbortErr extends Error {
            constructor(message) {
              super(message || "Request cancelled");
              this.name = "AbortError";
            }
          }

          function isCancelled(reqId) {
            return CANCELLED_REQS.has(reqId);
          }

          function throwIfCancelled(reqId) {
            if (isCancelled(reqId)) throw new AbortErr("Request cancelled by main thread");
          }

          function serializeError(err) {
            return {
              name: err?.name || "Error",
              message: err?.message || String(err || "Unknown error"),
              stack: err?.stack ? String(err.stack) : "",
            };
          }

          function countRoughTokens(s) {
            let n = 0;
            const re = /[A-Za-z0-9_]+|[^\\s]/g;
            while (re.exec(String(s))) n++;
            return n;
          }

          function parseUnifiedHunks(patch) {
            const lines = String(patch || "").split("\\n");
            const hunks = [];
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              if (!line.startsWith("@@")) continue;
              const m = /^@@ -(\\\\d+)(?:,(\\\\d+))? \\\\+(\\\\d+)(?:,(\\\\d+))? @@/.exec(line);
              if (!m) continue;
              const oldStart = Number(m[1]);
              const oldCount = Number(m[2] || "1");
              const newStart = Number(m[3]);
              const newCount = Number(m[4] || "1");
              const hunkLines = [];
              i++;
              for (; i < lines.length; i++) {
                const l = lines[i];
                if (l.startsWith("@@")) {
                  i--;
                  break;
                }
                if (l.startsWith("diff --git")) break;
                if (l.startsWith("index ") || l.startsWith("---") || l.startsWith("+++")) continue;
                hunkLines.push(l);
              }
              hunks.push({ oldStart, oldCount, newStart, newCount, lines: hunkLines });
            }
            return hunks;
          }

          function quickMetricsFromPatch(patch) {
            const lines = String(patch || "").split("\\n");
            let hunks = 0;
            let addLines = 0;
            let delLines = 0;
            let tokAdd = 0;
            let tokDel = 0;
            let bytesAdd = 0;
            let bytesDel = 0;
            for (const l of lines) {
              if (l.startsWith("@@")) hunks += 1;
              if (l.startsWith("+")) {
                if (l.startsWith("+++")) continue;
                addLines += 1;
                const s = l.slice(1);
                tokAdd += countRoughTokens(s);
                bytesAdd += s.length + 1;
              } else if (l.startsWith("-")) {
                if (l.startsWith("---")) continue;
                delLines += 1;
                const s = l.slice(1);
                tokDel += countRoughTokens(s);
                bytesDel += s.length + 1;
              }
            }
            return {
              hunks,
              addLines,
              delLines,
              tokensChanged: tokAdd + tokDel,
              bytesChanged: bytesAdd + bytesDel,
              tokensDelta: tokAdd - tokDel,
              bytesDelta: bytesAdd - bytesDel,
            };
          }

          function clamp(n, lo, hi) {
            return Math.max(lo, Math.min(hi, n));
          }

          function applyPatchLines(prevLines, patch) {
            const hunks = parseUnifiedHunks(patch);
            let out = prevLines.slice();
            let offset = 0;
            for (const h of hunks) {
              let at = (h.oldStart - 1) + offset;
              at = clamp(at, 0, out.length);
              let cursor = at;
              const next = [];
              for (const hl of h.lines) {
                if (!hl) continue;
                const p = hl[0];
                const content = hl.slice(1);
                if (p === " ") {
                  next.push(content);
                  cursor += 1;
                } else if (p === "-") {
                  cursor += 1;
                } else if (p === "+") {
                  next.push(content);
                }
              }
              out.splice(at, cursor - at, ...next);
              offset += next.length - (cursor - at);
            }
            return out;
          }

          function patchForIdx(idx) {
            const d = STATE.dataset;
            if (!d || !Array.isArray(d.patches)) return "";
            return d.patches[idx] || "";
          }

          function docTextAtLocal(idx, reqId, progressCb) {
            const d = STATE.dataset;
            if (!d) return "";
            if (idx <= 0) return String(d.base_doc || "");
            const cached = STATE.snapshotCache.get(idx);
            if (typeof cached === "string") return cached;

            if (STATE.snapshotCursorLines && idx === STATE.snapshotCursorIdx + 1) {
              throwIfCancelled(reqId);
              const nextLines = applyPatchLines(STATE.snapshotCursorLines, patchForIdx(idx));
              STATE.snapshotCursorIdx = idx;
              STATE.snapshotCursorLines = nextLines;
              const text = nextLines.join("\\n");
              STATE.snapshotCache.set(idx, text);
              return text;
            }

            let anchor = 0;
            for (let j = idx - 1; j > 0; j--) {
              if (STATE.snapshotCache.has(j)) {
                anchor = j;
                break;
              }
            }

            let lines = String(d.base_doc || "").split("\\n");
            if (anchor > 0) lines = String(STATE.snapshotCache.get(anchor) || "").split("\\n");

            for (let k = Math.max(1, anchor + 1); k <= idx; k++) {
              throwIfCancelled(reqId);
              lines = applyPatchLines(lines, patchForIdx(k));
              if (k === idx || k % 10 === 0) {
                STATE.snapshotCache.set(k, lines.join("\\n"));
              }
              if (progressCb && (k % 8 === 0 || k === idx)) {
                progressCb({ stage: "snapshot", done: k, total: idx, message: "Reconstructing snapshot" });
              }
            }

            STATE.snapshotCursorIdx = idx;
            STATE.snapshotCursorLines = lines;
            const out = STATE.snapshotCache.get(idx) || lines.join("\\n");
            STATE.snapshotCache.set(idx, out);
            return out;
          }

          async function initLevWasm() {
            if (STATE.levWasm) return STATE.levWasm;
            const res = await fetch(LEV_WASM_URL, { cache: "force-cache" });
            if (!res.ok) throw new Error("Failed to fetch " + LEV_WASM_URL + ": HTTP " + res.status);
            const buf = await res.arrayBuffer();
            const { instance } = await WebAssembly.instantiate(buf, {});
            STATE.levWasm = instance.exports;
            return STATE.levWasm;
          }

          async function levenshteinBytes(aBytes, bBytes) {
            const ex = await initLevWasm();
            const memory = ex.memory;
            const alloc = ex.alloc;
            const dealloc = ex.dealloc;
            const levenshtein = ex.levenshtein;
            if (!memory || !alloc || !dealloc || !levenshtein) {
              throw new Error("WASM exports missing (memory/alloc/dealloc/levenshtein)");
            }
            const a = aBytes || new Uint8Array();
            const b = bBytes || new Uint8Array();
            const ptrA = alloc(a.length);
            const viewA = new Uint8Array(memory.buffer, ptrA, a.length);
            viewA.set(a);
            const ptrB = alloc(b.length);
            const viewB = new Uint8Array(memory.buffer, ptrB, b.length);
            viewB.set(b);
            const d = levenshtein(ptrA, a.length, ptrB, b.length) >>> 0;
            dealloc(ptrA, a.length);
            dealloc(ptrB, b.length);
            return d;
          }

          async function levenshteinForPatch(patch, reqId) {
            const hunks = parseUnifiedHunks(patch);
            const enc = new TextEncoder();
            let sum = 0;
            for (const h of hunks) {
              throwIfCancelled(reqId);
              const oldLines = [];
              const newLines = [];
              for (const hl of h.lines) {
                if (!hl) continue;
                const p = hl[0];
                const content = hl.slice(1);
                if (p === "-") oldLines.push(content);
                if (p === "+") newLines.push(content);
              }
              if (!oldLines.length && !newLines.length) continue;
              const a = enc.encode(oldLines.join("\\n"));
              const b = enc.encode(newLines.join("\\n"));
              if (a.length > 20000 || b.length > 20000) {
                sum += a.length + b.length;
              } else {
                sum += await levenshteinBytes(a, b);
              }
            }
            return sum;
          }

          function slugifyHeadingW(text) {
            return String(text || "")
              .toLowerCase()
              .replace(/[^a-z0-9\\u00C0-\\u024F]+/g, "-")
              .replace(/^-+|-+$/g, "")
              || "heading";
          }

          function extractOutlineWorker(markdownText) {
            const lines = String(markdownText || "").split("\\n");
            const outline = [];
            const slugCounts = new Map();
            const atxRe = /^(#{1,6})\\s+(.+?)\\s*$/;
            let inFence = false;
            for (let li = 0; li < lines.length; li++) {
              const line = lines[li];
              if (line.startsWith("\`\`\`")) {
                inFence = !inFence;
                continue;
              }
              if (inFence) continue;
              const m = atxRe.exec(line);
              if (!m) continue;
              const level = m[1].length;
              const text = m[2].replace(/\\s+#+\\s*$/, "");
              const baseSlug = slugifyHeadingW(text);
              const count = slugCounts.get(baseSlug) || 0;
              slugCounts.set(baseSlug, count + 1);
              const id = count === 0 ? baseSlug : baseSlug + "-" + count;
              outline.push({ text: text.trim(), level, id, line: li + 1 });
            }
            return outline;
          }

          function buildLineToHeadingMapW(totalLines, outline) {
            const map = new Array(totalLines + 1);
            map[0] = "__preamble__";
            let ptr = 0;
            let currentId = "__preamble__";
            for (let ln = 1; ln <= totalLines; ln++) {
              while (ptr < outline.length && outline[ptr].line != null && outline[ptr].line <= ln) {
                currentId = outline[ptr].id;
                ptr++;
              }
              map[ln] = currentId;
            }
            return map;
          }

          function attributeHunksToHeadingsW(patch, lineToHeading) {
            const hunks = parseUnifiedHunks(patch);
            const metrics = {};
            for (const hunk of hunks) {
              let newLineNum = hunk.newStart;
              for (const hl of hunk.lines) {
                if (!hl) continue;
                const p = hl[0];
                const content = hl.slice(1);
                const hid = lineToHeading[newLineNum] || "__preamble__";
                if (!metrics[hid]) metrics[hid] = { addLines: 0, delLines: 0, tokensAdded: 0, tokensDeleted: 0 };
                if (p === "+") {
                  metrics[hid].addLines++;
                  metrics[hid].tokensAdded += countRoughTokens(content);
                  newLineNum++;
                } else if (p === "-") {
                  metrics[hid].delLines++;
                  metrics[hid].tokensDeleted += countRoughTokens(content);
                } else if (p === " ") {
                  newLineNum++;
                }
              }
            }
            return metrics;
          }

          // --- Search index (bd-24q.9.1) ---

          // Stemming-lite: strip common English suffixes for better recall.
          function stemLite(w) {
            if (w.length < 5) return w;
            if (w.endsWith("ying")) return w;
            if (w.endsWith("ies") && w.length > 5) return w.slice(0, -3) + "y";
            if (w.endsWith("ness") && w.length > 6) return w.slice(0, -4);
            if (w.endsWith("ment") && w.length > 6) return w.slice(0, -4);
            if (w.endsWith("ing") && w.length > 5) return w.slice(0, -3);
            if (w.endsWith("tion") && w.length > 6) return w.slice(0, -4);
            if (w.endsWith("sion") && w.length > 6) return w.slice(0, -4);
            if (w.endsWith("able") && w.length > 6) return w.slice(0, -4);
            if (w.endsWith("ible") && w.length > 6) return w.slice(0, -4);
            if (w.endsWith("ful") && w.length > 5) return w.slice(0, -3);
            if (w.endsWith("ous") && w.length > 5) return w.slice(0, -3);
            if (w.endsWith("ed") && w.length > 4) return w.slice(0, -2);
            if (w.endsWith("ly") && w.length > 4) return w.slice(0, -2);
            if (w.endsWith("er") && w.length > 4) return w.slice(0, -2);
            if (w.endsWith("es") && w.length > 4) return w.slice(0, -2);
            if (w.endsWith("s") && !w.endsWith("ss") && w.length > 3) return w.slice(0, -1);
            return w;
          }

          function tokenize(text) {
            return String(text || "")
              .toLowerCase()
              .split(/[^a-z0-9_]+/g)
              .filter((x) => x.length >= 2);
          }

          function tokenizeStemmed(text) {
            return tokenize(text).map(stemLite);
          }

          // Extract headings from markdown text (lightweight, for indexing).
          function extractHeadingsForIndex(text) {
            const out = [];
            const lines = String(text || "").split("\\n");
            for (const line of lines) {
              const m = line.match(/^(#{1,6})\\s+(.+)/);
              if (m) out.push(m[2]);
            }
            return out.join(" ");
          }

          // Added lines from a unified diff patch (just the content, not the +-prefix).
          function addedLinesFromPatch(patch) {
            const lines = String(patch || "").split("\\n");
            const out = [];
            for (const line of lines) {
              if (line.startsWith("+") && !line.startsWith("+++")) out.push(line.slice(1));
            }
            return out.join(" ");
          }

          function buildSearchIndex(reqId, progressCb) {
            const commits = STATE.dataset?.commits || [];
            const patches = STATE.dataset?.patches || [];
            const postings = new Map(); // stemmed token -> sorted commitIdx[]
            const docs = []; // per-commit doc record
            const N = commits.length;
            for (let i = 0; i < N; i++) {
              if (reqId && i % 20 === 0) throwIfCancelled(reqId);
              if (progressCb && i % 25 === 0) progressCb({ phase: "indexing", current: i, total: N });
              const c = commits[i];
              // Sources: commit metadata + patch added lines + headings from snapshot.
              const metaText = [c.hash || "", c.short || "", c.author || "", c.subject || ""].join(" ");
              const patchText = addedLinesFromPatch(patches[i] || "");
              // Reconstruct headings from snapshot (if cached; skip full reconstruction for speed).
              const cachedSnapshot = STATE.snapshotCache.get(i);
              const headingText = cachedSnapshot ? extractHeadingsForIndex(cachedSnapshot) : "";
              const fullBody = metaText + " " + patchText + " " + headingText;
              const rawTokens = tokenize(fullBody);
              const stemmedTokens = rawTokens.map(stemLite);
              docs.push({
                i,
                hash: c.hash,
                short: c.short,
                subject: c.subject,
                author: c.author,
                body: metaText + " " + patchText.slice(0, 500), // keep body small for phrase search
              });
              const seen = new Set();
              for (const tok of stemmedTokens) {
                if (seen.has(tok)) continue;
                seen.add(tok);
                let arr = postings.get(tok);
                if (!arr) { arr = []; postings.set(tok, arr); }
                arr.push(i);
              }
            }
            STATE.searchIndex = { postings, docs, version: 2 };
            if (progressCb) progressCb({ phase: "done", current: N, total: N });
            return { docs: docs.length, terms: postings.size };
          }

          // Parse query: extract quoted phrases and plain tokens.
          function parseSearchQuery(q) {
            const phrases = [];
            const tokens = [];
            const stripped = String(q || "").replace(/"([^"]+)"/g, (_, phrase) => {
              phrases.push(phrase.toLowerCase());
              return "";
            });
            tokens.push(...tokenizeStemmed(stripped));
            return { phrases, tokens };
          }

          function querySearch(q, limit) {
            const index = STATE.searchIndex;
            if (!index) return { query: q, hits: [] };
            const { phrases, tokens } = parseSearchQuery(q);
            if (!tokens.length && !phrases.length) return { query: q, hits: [] };

            // Token-based intersection (stemmed).
            let candidate = null;
            for (const t of tokens) {
              const posting = index.postings.get(t) || [];
              const postingSet = new Set(posting);
              candidate = candidate === null ? postingSet : new Set([...candidate].filter((x) => postingSet.has(x)));
            }
            // If only phrases (no tokens), start with all docs.
            if (candidate === null) {
              candidate = new Set();
              for (let i = 0; i < index.docs.length; i++) candidate.add(i);
            }

            // Phrase filter: raw substring scan on doc body.
            if (phrases.length) {
              const next = new Set();
              for (const docId of candidate) {
                const d = index.docs[docId];
                if (!d) continue;
                const bodyLower = d.body.toLowerCase();
                if (phrases.every((p) => bodyLower.includes(p))) next.add(docId);
              }
              candidate = next;
            }

            const out = [];
            for (const docId of candidate) {
              const d = index.docs[docId];
              if (!d) continue;
              let score = 0;
              const bodyLower = d.body.toLowerCase();
              for (const t of tokens) { if (bodyLower.includes(t)) score += 1; }
              for (const p of phrases) { if (bodyLower.includes(p)) score += 2; } // phrases worth more
              out.push({ idx: d.i, hash: d.hash, short: d.short, subject: d.subject, author: d.author, score });
            }
            out.sort((a, b) => b.score - a.score || a.idx - b.idx);
            return { query: q, hits: out.slice(0, Math.max(1, Number(limit || 20))) };
          }

          // Export search index as JSON-serializable object for localStorage persistence (bd-24q.9.1).
          function exportSearchIndex() {
            const index = STATE.searchIndex;
            if (!index) return null;
            // Delta-compress postings lists for storage efficiency.
            const entries = [];
            for (const [tok, idxs] of index.postings) {
              const deltas = [idxs[0]];
              for (let i = 1; i < idxs.length; i++) deltas.push(idxs[i] - idxs[i - 1]);
              entries.push([tok, deltas]);
            }
            return { v: index.version || 2, docs: index.docs, postings: entries };
          }

          // Hydrate search index from serialized data (localStorage cache).
          function hydrateSearchIndex(data) {
            if (!data || data.v !== 2) return false;
            const postings = new Map();
            for (const [tok, deltas] of data.postings) {
              const idxs = [deltas[0]];
              for (let i = 1; i < deltas.length; i++) idxs.push(idxs[i - 1] + deltas[i]);
              postings.set(tok, idxs);
            }
            STATE.searchIndex = { postings, docs: data.docs, version: 2 };
            return true;
          }

          function hash32(seed, str) {
            let h = seed >>> 0;
            for (let i = 0; i < str.length; i++) {
              h ^= str.charCodeAt(i);
              h = Math.imul(h, 16777619);
            }
            return h >>> 0;
          }

          // --- MinHash Signature Pipeline (bd-24q.14.1) ---

          /** Generate deterministic hash seeds from dataset hash for stable MinHash results. */
          function generateMinHashSeeds(datasetHash, sigLen) {
            const seeds = new Uint32Array(sigLen);
            let h = 2166136261 >>> 0;
            const basis = String(datasetHash || "minhash");
            for (let i = 0; i < basis.length; i++) {
              h ^= basis.charCodeAt(i);
              h = Math.imul(h, 16777619);
            }
            for (let i = 0; i < sigLen; i++) {
              h ^= i;
              h = Math.imul(h, 16777619);
              h = (h ^ (h >>> 16)) >>> 0;
              seeds[i] = h;
            }
            return seeds;
          }

          /** Generate character-level k-shingles from text. Returns unique shingle strings. */
          function shingle(text, k) {
            const s = String(text || "").toLowerCase();
            if (s.length < k) return s.length > 0 ? [s] : [];
            const seen = new Set();
            for (let i = 0; i <= s.length - k; i++) {
              seen.add(s.substring(i, i + k));
            }
            return Array.from(seen);
          }

          /**
           * Compute MinHash signatures for all commits (bd-24q.14.1).
           * Sources: diff added lines (primary) + commit subject + author.
           * Options: sigLen (default 64), shingleK (default 5), mode ("full"|"added", default "added").
           */
          function computeMinHashSignatures(reqId, progressCb, options) {
            const commits = STATE.dataset?.commits || [];
            const patches = STATE.dataset?.patches || [];
            const N = commits.length;
            const sigLen = Math.max(8, Number(options?.sigLen || 64));
            const shingleK = Math.max(2, Number(options?.shingleK || 5));
            const mode = options?.mode === "full" ? "full" : "added";
            const seeds = generateMinHashSeeds(STATE.datasetHash, sigLen);
            const sigs = new Uint32Array(N * sigLen);
            const meta = [];
            for (let i = 0; i < N; i++) {
              if (reqId && i % 15 === 0) throwIfCancelled(reqId);
              if (progressCb && i % 20 === 0) progressCb({ phase: "minhash", current: i, total: N });
              const c = commits[i];
              const patchRaw = patches[i] || "";
              const diffText = mode === "full" ? patchRaw : addedLinesFromPatch(patchRaw);
              const text = (c.subject || "") + " " + (c.author || "") + " " + diffText;
              const shingles = shingle(text, shingleK);
              const offset = i * sigLen;
              if (shingles.length === 0) {
                sigs.fill(0xffffffff, offset, offset + sigLen);
              } else {
                for (let s = 0; s < sigLen; s++) {
                  let best = 0xffffffff;
                  const seed = seeds[s];
                  for (const sh of shingles) {
                    const h = hash32(seed, sh);
                    if (h < best) best = h;
                  }
                  sigs[offset + s] = best;
                }
              }
              meta.push({ idx: i, hash: c.hash, short: c.short, subject: c.subject });
            }
            STATE.minhashSignatures = { sigs, meta, sigLen, shingleK, version: 1 };
            if (progressCb) progressCb({ phase: "done", current: N, total: N });
            return { docs: N, sigLen, shingleK };
          }

          /** Export MinHash signatures for localStorage persistence (base64-encoded Uint32Array). */
          function exportMinHashSignatures() {
            const mh = STATE.minhashSignatures;
            if (!mh) return null;
            const bytes = new Uint8Array(mh.sigs.buffer, mh.sigs.byteOffset, mh.sigs.byteLength);
            const chunks = [];
            for (let i = 0; i < bytes.length; i += 8192) {
              chunks.push(String.fromCharCode.apply(null, bytes.subarray(i, i + 8192)));
            }
            const b64 = btoa(chunks.join(""));
            return { v: 1, sigLen: mh.sigLen, shingleK: mh.shingleK, docs: mh.meta.length, meta: mh.meta, sigs_b64: b64 };
          }

          /** Hydrate MinHash signatures from exported localStorage data. */
          function hydrateMinHashSignatures(data) {
            if (!data || data.v !== 1 || !data.sigs_b64) return false;
            const binary = atob(data.sigs_b64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            const sigs = new Uint32Array(bytes.buffer);
            STATE.minhashSignatures = { sigs, meta: data.meta, sigLen: data.sigLen, shingleK: data.shingleK, version: 1 };
            return true;
          }


          // --- History Search Analytics: First-Introduced + Most-Edited (bd-24q.9.3) ---

          /**
           * Find the earliest commit where a token or phrase first appears in added lines.
           * Returns { found, commitIdx, hash, short, subject, matchLine, contextLines[] }.
           */
          function findFirstIntroduced(query, options) {
            const commits = STATE.dataset?.commits || [];
            const patches = STATE.dataset?.patches || [];
            if (!commits.length || !query) return { found: false, query };

            const qLower = query.toLowerCase().trim();
            const maxContext = (options && options.contextLines) || 3;

            for (let i = 0; i < commits.length; i++) {
              const patch = patches[i] || "";
              const lines = String(patch).split("\\n");
              for (let j = 0; j < lines.length; j++) {
                const line = lines[j];
                if (!line.startsWith("+") || line.startsWith("+++")) continue;
                const content = line.slice(1);
                if (content.toLowerCase().includes(qLower)) {
                  const contextLines = [];
                  const start = Math.max(0, j - maxContext);
                  const end = Math.min(lines.length - 1, j + maxContext);
                  for (let k = start; k <= end; k++) {
                    const cl = lines[k];
                    if (cl.startsWith("@@") || cl.startsWith("---") || cl.startsWith("+++")) continue;
                    contextLines.push({ line: k, prefix: cl[0] || " ", text: cl.slice(1), isMatch: k === j });
                  }
                  const c = commits[i];
                  return {
                    found: true,
                    query: qLower,
                    commitIdx: i,
                    hash: c.hash,
                    short: c.short,
                    subject: c.subject,
                    author: c.author,
                    matchLine: content,
                    contextLines,
                  };
                }
              }
            }
            return { found: false, query: qLower };
          }

          /**
           * Compute per-heading edit mass across all commits.
           * Returns { sections: [{ heading, totalTokensDelta, totalLinesDelta, peakIdx, peakDelta, commitCount, timeline[] }] }.
           */
          function computeMostEditedSections(reqId, progressCb, options) {
            const commits = STATE.dataset?.commits || [];
            const patches = STATE.dataset?.patches || [];
            const topK = (options && options.topK) || 20;
            if (!commits.length) return { sections: [] };

            const headingStats = {};

            for (let i = 0; i < commits.length; i++) {
              if (progressCb && i % 10 === 0) progressCb({ phase: "most_edited", current: i, total: commits.length });
              throwIfCancelled(reqId);

              const patch = patches[i] || "";
              if (!patch) continue;

              const text = docTextAtLocal(i, reqId, null);
              if (!text) continue;
              const outline = extractOutlineWorker(text);
              const totalLines = text.split("\\n").length;
              const lineMap = buildLineToHeadingMapW(totalLines, outline);
              const metrics = attributeHunksToHeadingsW(patch, lineMap);

              for (const hid of Object.keys(metrics)) {
                if (hid === "__preamble__") continue;
                const m = metrics[hid];
                if (!headingStats[hid]) {
                  headingStats[hid] = { heading: hid, totalTokensDelta: 0, totalLinesDelta: 0, peakIdx: i, peakDelta: 0, commitCount: 0, timeline: [] };
                }
                const s = headingStats[hid];
                const tokenDelta = m.tokensAdded + m.tokensDeleted;
                const lineDelta = m.addLines + m.delLines;
                s.totalTokensDelta += tokenDelta;
                s.totalLinesDelta += lineDelta;
                s.commitCount++;
                s.timeline.push({ idx: i, tokensAdded: m.tokensAdded, tokensDeleted: m.tokensDeleted, addLines: m.addLines, delLines: m.delLines });
                if (tokenDelta > s.peakDelta) {
                  s.peakDelta = tokenDelta;
                  s.peakIdx = i;
                }
              }
            }

            const sections = Object.values(headingStats)
              .sort((a, b) => b.totalTokensDelta - a.totalTokensDelta || a.heading.localeCompare(b.heading))
              .slice(0, topK)
              .map((s) => ({
                heading: s.heading,
                totalTokensDelta: s.totalTokensDelta,
                totalLinesDelta: s.totalLinesDelta,
                peakIdx: s.peakIdx,
                peakDelta: s.peakDelta,
                commitCount: s.commitCount,
                timeline: s.timeline,
              }));

            STATE.mostEditedSections = sections;
            return { sections };
          }

          // --- Clustering: Deterministic Grouping + Theme Tags (bd-24q.14.2) ---

          /** Estimate Jaccard similarity from MinHash signature agreement. */
          function minhashJaccard(sigA, sigB, len) {
            let agree = 0;
            for (let i = 0; i < len; i++) { if (sigA[i] === sigB[i]) agree++; }
            return agree / len;
          }

          /** Stable cluster ID: FNV-1a hash of sorted member indices. */
          function clusterStableId(members) {
            let h = 2166136261;
            for (const idx of members) {
              h ^= (idx & 0xff); h = Math.imul(h, 16777619);
              h ^= ((idx >> 8) & 0xff); h = Math.imul(h, 16777619);
              h ^= ((idx >> 16) & 0xff); h = Math.imul(h, 16777619);
            }
            return "cl-" + ((h >>> 0).toString(36));
          }

          /** Extract top-K keywords from texts, excluding stopwords. TF-DF scoring. */
          function extractThemeTags(texts, topK) {
            const STOP = new Set(["the","a","an","and","or","but","in","on","at","to","for","of","is","it","this","that","was","be","with","as","by","from","not","are","were","been","have","has","had","do","does","did","will","would","could","should","may","can","if","then","else","when","while","so","no","all","any","each","which","their","its","they","we","he","she","you","i","my","your","our","his","her","up","out","into","over","also","add","added","remove","removed","change","changed","update","updated","fix","fixed","use","used","new","set","get","make"]);
            const freq = new Map();
            for (const text of texts) {
              const words = tokenize(text);
              const seen = new Set();
              for (const w of words) {
                if (w.length < 3 || STOP.has(w) || /^\d+$/.test(w)) continue;
                if (seen.has(w)) continue;
                seen.add(w);
                freq.set(w, (freq.get(w) || 0) + 1);
              }
            }
            return Array.from(freq.entries())
              .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]))
              .slice(0, topK)
              .map((e) => e[0]);
          }

          function computeClusters(limit, options) {
            const commits = STATE.dataset?.commits || [];
            const patches = STATE.dataset?.patches || [];
            const mh = STATE.minhashSignatures;
            const threshold = (options && options.threshold) || 0.3;
            const maxClusters = Math.max(1, Number(limit || 12));
            const N = commits.length;
            if (!N) { STATE.clusterData = []; return { clusters: [] }; }

            // Build signature array (prefer precomputed MinHash).
            let effectiveSigLen;
            let sigs;
            if (mh && mh.sigs.length >= N * mh.sigLen) {
              sigs = mh.sigs;
              effectiveSigLen = mh.sigLen;
            } else {
              const seeds = [2166136261, 19088743, 591798841, 2654435761, 40503, 734539, 1889, 2651];
              effectiveSigLen = seeds.length;
              sigs = new Uint32Array(N * effectiveSigLen);
              for (let i = 0; i < N; i++) {
                const c = commits[i];
                const tokens = Array.from(new Set(tokenize((c.subject || "") + " " + (c.author || ""))));
                for (let s = 0; s < effectiveSigLen; s++) {
                  let best = 0xffffffff;
                  for (const tok of tokens) { const h = hash32(seeds[s], tok); if (h < best) best = h; }
                  sigs[i * effectiveSigLen + s] = best >>> 0;
                }
              }
            }

            // Step 1: LSH banding to find candidate pairs (avoids O(N^2)).
            const rowsPerBand = Math.max(1, Math.min(4, Math.floor(effectiveSigLen / 4)));
            const numBands = Math.floor(effectiveSigLen / rowsPerBand);
            const candidatePairs = new Set();
            for (let b = 0; b < numBands; b++) {
              const buckets = new Map();
              for (let i = 0; i < N; i++) {
                const start = i * effectiveSigLen + b * rowsPerBand;
                let key = "";
                for (let r = 0; r < rowsPerBand; r++) key += sigs[start + r] + ",";
                let arr = buckets.get(key);
                if (!arr) { arr = []; buckets.set(key, arr); }
                arr.push(i);
              }
              for (const bucket of buckets.values()) {
                if (bucket.length < 2) continue;
                for (let x = 0; x < bucket.length; x++) {
                  for (let y = x + 1; y < bucket.length; y++) {
                    const lo = Math.min(bucket[x], bucket[y]);
                    const hi = Math.max(bucket[x], bucket[y]);
                    candidatePairs.add(lo * N + hi);
                  }
                }
              }
            }

            // Step 2: Single-linkage threshold clustering via Union-Find.
            const parent = new Int32Array(N);
            const ufRank = new Uint8Array(N);
            for (let i = 0; i < N; i++) parent[i] = i;
            function ufFind(x) { while (parent[x] !== x) { parent[x] = parent[parent[x]]; x = parent[x]; } return x; }
            function ufUnion(a, b) {
              a = ufFind(a); b = ufFind(b);
              if (a === b) return;
              if (ufRank[a] < ufRank[b]) { const t = a; a = b; b = t; }
              parent[b] = a;
              if (ufRank[a] === ufRank[b]) ufRank[a]++;
            }

            for (const pairKey of candidatePairs) {
              const hi = pairKey % N;
              const lo = (pairKey - hi) / N;
              const sigI = sigs.subarray(lo * effectiveSigLen, lo * effectiveSigLen + effectiveSigLen);
              const sigJ = sigs.subarray(hi * effectiveSigLen, hi * effectiveSigLen + effectiveSigLen);
              if (minhashJaccard(sigI, sigJ, effectiveSigLen) >= threshold) ufUnion(lo, hi);
            }

            // Step 3: Collect clusters (min size 2), sort deterministically.
            const groups = new Map();
            for (let i = 0; i < N; i++) {
              const root = ufFind(i);
              let g = groups.get(root);
              if (!g) { g = []; groups.set(root, g); }
              g.push(i);
            }
            let clusterList = [];
            for (const members of groups.values()) {
              if (members.length < 2) continue;
              members.sort((a, b) => a - b);
              clusterList.push(members);
            }
            clusterList.sort((a, b) => b.length - a.length || a[0] - b[0]);
            clusterList = clusterList.slice(0, maxClusters);

            // Step 4: Medoid selection + theme tags per cluster.
            const clusters = clusterList.map((members) => {
              let bestMedoid = members[0];
              let bestAvg = -1;
              if (members.length <= 50) {
                for (const m of members) {
                  let sum = 0;
                  const sigM = sigs.subarray(m * effectiveSigLen, m * effectiveSigLen + effectiveSigLen);
                  for (const o of members) {
                    if (o === m) continue;
                    sum += minhashJaccard(sigM, sigs.subarray(o * effectiveSigLen, o * effectiveSigLen + effectiveSigLen), effectiveSigLen);
                  }
                  const avg = sum / (members.length - 1);
                  if (avg > bestAvg) { bestAvg = avg; bestMedoid = m; }
                }
              }
              const memberTexts = members.map((idx) => {
                const c = commits[idx] || {};
                const patch = patches[idx] || "";
                return (c.subject || "") + " " + addedLinesFromPatch(patch);
              });
              const tags = extractThemeTags(memberTexts, 4);
              return {
                id: clusterStableId(members),
                size: members.length,
                medoid: bestMedoid,
                tags,
                items: members.map((idx) => {
                  const c = commits[idx] || {};
                  return { idx, hash: c.hash, short: c.short, subject: c.subject };
                }),
              };
            });

            STATE.clusterData = clusters;
            return { clusters };
          }

          function median(values) {
            const arr = values.slice().sort((a, b) => a - b);
            if (!arr.length) return 0;
            const mid = Math.floor(arr.length / 2);
            if (arr.length % 2) return arr[mid];
            return (arr[mid - 1] + arr[mid]) / 2;
          }

          function computeOutliers(values, topK) {
            const xs = values.map((v) => Number(v || 0));
            const med = median(xs);
            const absDev = xs.map((x) => Math.abs(x - med));
            const mad = median(absDev) || 1e-9;
            const scored = xs.map((x, idx) => {
              const z = 0.6745 * (x - med) / mad;
              return { idx, value: x, z };
            });
            scored.sort((a, b) => Math.abs(b.z) - Math.abs(a.z));
            return { median: med, mad, top: scored.slice(0, Math.max(1, Number(topK || 10))) };
          }


          /** Enhanced robust outlier scoring with stable tie-breaking + evidence (bd-24q.10.1). */
          function computeOutliersRobust(entries, topK) {
            if (!entries.length) return { median: 0, mad: 0, top: [], all: [] };
            const values = entries.map(e => Number(e.value || 0));
            const sorted = values.slice().sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            const med = sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
            const absDev = values.map(v => Math.abs(v - med));
            const absSorted = absDev.slice().sort((a, b) => a - b);
            const absMid = Math.floor(absSorted.length / 2);
            const mad = absSorted.length % 2 ? absSorted[absMid] : (absSorted[absMid - 1] + absSorted[absMid]) / 2;
            const madSafe = mad || 1e-9;
            const scored = entries.map((e, i) => ({
              idx: e.idx ?? i, value: values[i],
              z: 0.6745 * (values[i] - med) / madSafe,
              ts: e.ts || "", hash: e.hash || "", buckets: e.buckets || [],
            }));
            scored.sort((a, b) => {
              const dz = Math.abs(b.z) - Math.abs(a.z);
              if (Math.abs(dz) > 1e-12) return dz;
              if (a.ts !== b.ts) return a.ts < b.ts ? -1 : 1;
              return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;
            });
            const k = Math.max(1, Math.min(Number(topK) || 10, scored.length));
            const top = scored.slice(0, k).map(e => ({
              idx: e.idx, value: e.value, z: e.z, ts: e.ts, hash: e.hash, buckets: e.buckets,
              evidence: { value: e.value, median: med, mad, z: e.z, contributingBuckets: e.buckets },
            }));
            return { median: med, mad, top, all: scored.map(e => ({ idx: e.idx, value: e.value, z: e.z })) };
          }

          /** Multi-metric outlier computation (bd-24q.10.1). */
          function computeOutliersMultiMetric(metricSeries, topK) {
            const results = {};
            for (const [name, entries] of Object.entries(metricSeries)) {
              results[name] = computeOutliersRobust(Array.isArray(entries) ? entries : [], topK);
            }
            return results;
          }

          function logAddExp(a, b) {
            if (a === -Infinity) return b;
            if (b === -Infinity) return a;
            const m = Math.max(a, b);
            return m + Math.log(Math.exp(a - m) + Math.exp(b - m));
          }

          function updateWelford(st, x) {
            const n1 = st.n + 1;
            const delta = x - st.mean;
            const mean1 = st.mean + delta / n1;
            const delta2 = x - mean1;
            const m21 = st.m2 + delta * delta2;
            return { n: n1, mean: mean1, m2: m21 };
          }

          function logGamma(z) {
            const p = [
              0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313,
              -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6,
              1.5056327351493116e-7,
            ];
            if (z < 0.5) {
              return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - logGamma(1 - z);
            }
            z -= 1;
            let x = p[0];
            for (let i = 1; i < p.length; i++) x += p[i] / (z + i);
            const t = z + 7.5;
            return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x);
          }

          function studentTLogPdf(x, mu, sigma, nu) {
            const z = (x - mu) / (sigma || 1e-9);
            return (
              logGamma((nu + 1) / 2) -
              logGamma(nu / 2) -
              Math.log((sigma || 1e-9) * Math.sqrt(nu * Math.PI)) -
              ((nu + 1) / 2) * Math.log(1 + (z * z) / nu)
            );
          }

          function computePhaseMap(values, hazard) {
            const y = values.map((v) => Number(v || 0));
            const H = Math.max(1e-4, Math.min(0.9999, Number(hazard || 0.03)));
            let mu0 = 0.0;
            let kappa0 = 0.01;
            let alpha0 = 0.5;
            let beta0 = 0.5;
            let logR = [0.0];
            let stats = [{ n: 0, mean: 0.0, m2: 0.0 }];
            const p0 = [];
            const changePoints = [];
            const logHaz = Math.log(H);
            const log1mHaz = Math.log(1.0 - H);
            for (let t = 0; t < y.length; t++) {
              const x = y[t];
              const logPred = [];
              for (let r = 0; r < stats.length; r++) {
                const st = stats[r];
                const n = st.n;
                const mean = st.mean;
                const kappa = kappa0 + n;
                const alpha = alpha0 + n / 2;
                const beta = beta0 + 0.5 * st.m2 + (kappa0 * n * (mean - mu0) * (mean - mu0)) / (2 * (kappa0 + n));
                const dof = 2 * alpha;
                const scale2 = (beta * (kappa + 1)) / (alpha * kappa);
                logPred.push(studentTLogPdf(x, mean, Math.sqrt(scale2), dof));
              }
              const newLogR = new Array(stats.length + 1).fill(-Infinity);
              let logSumCp = -Infinity;
              for (let r = 0; r < logR.length; r++) {
                logSumCp = logAddExp(logSumCp, logR[r] + logPred[r] + logHaz);
              }
              newLogR[0] = logSumCp;
              for (let r = 0; r < logR.length; r++) {
                newLogR[r + 1] = logR[r] + logPred[r] + log1mHaz;
              }
              const logZ = newLogR.reduce((a, b) => logAddExp(a, b), -Infinity);
              for (let i = 0; i < newLogR.length; i++) newLogR[i] -= logZ;
              const p_r0 = Math.exp(newLogR[0]);
              p0.push(p_r0);
              if (p_r0 > 0.5) changePoints.push(t);
              const newStats = new Array(stats.length + 1);
              newStats[0] = { n: 1, mean: x, m2: 0.0 };
              for (let r = 1; r < newStats.length; r++) {
                newStats[r] = updateWelford(stats[r - 1], x);
              }
              const K = 120;
              const idxs = newLogR
                .map((v, i) => [v, i])
                .sort((a, b) => b[0] - a[0])
                .slice(0, K)
                .map((x) => x[1])
                .sort((a, b) => a - b);
              logR = idxs.map((i) => newLogR[i]);
              stats = idxs.map((i) => newStats[i]);
              const logZ2 = logR.reduce((a, b) => logAddExp(a, b), -Infinity);
              logR = logR.map((v) => v - logZ2);
            }
            return { p0, changePoints };
          }

          
          /** Enhanced BOCPD with evidence ledger + segments (bd-24q.11.1). */
          function computePhaseMapEnhanced(values, hazard, metadata) {
            const y = values.map((v) => Number(v || 0));
            const H = Math.max(1e-4, Math.min(0.9999, Number(hazard || 0.03)));
            const meta = Array.isArray(metadata) ? metadata : [];

            // Normal-Gamma prior (Jeffreys-inspired uninformative).
            let mu0 = 0.0, kappa0 = 0.01, alpha0 = 0.5, beta0 = 0.5;
            let logR = [0.0];
            let stats = [{ n: 0, mean: 0.0, m2: 0.0 }];
            const p0 = [];
            const changePoints = [];
            const logHaz = Math.log(H);
            const log1mHaz = Math.log(1.0 - H);

            // Track running stats for evidence: mean/var per run-length 0 (new segment).
            const segmentStats = []; // per-timestep: { mean, var, n } for MAP run length

            for (let t = 0; t < y.length; t++) {
              const x = y[t];
              const logPred = [];
              for (let r = 0; r < stats.length; r++) {
                const st = stats[r];
                const n = st.n;
                const mean = st.mean;
                const kappa = kappa0 + n;
                const alpha = alpha0 + n / 2;
                const beta = beta0 + 0.5 * st.m2 + (kappa0 * n * (mean - mu0) * (mean - mu0)) / (2 * (kappa0 + n));
                const dof = 2 * alpha;
                const scale2 = (beta * (kappa + 1)) / (alpha * kappa);
                logPred.push(studentTLogPdf(x, mean, Math.sqrt(scale2), dof));
              }
              const newLogR = new Array(stats.length + 1).fill(-Infinity);
              let logSumCp = -Infinity;
              for (let r = 0; r < logR.length; r++) {
                logSumCp = logAddExp(logSumCp, logR[r] + logPred[r] + logHaz);
              }
              newLogR[0] = logSumCp;
              for (let r = 0; r < logR.length; r++) {
                newLogR[r + 1] = logR[r] + logPred[r] + log1mHaz;
              }
              const logZ = newLogR.reduce((a, b) => logAddExp(a, b), -Infinity);
              for (let i = 0; i < newLogR.length; i++) newLogR[i] -= logZ;
              const p_r0 = Math.exp(newLogR[0]);
              p0.push(p_r0);
              if (p_r0 > 0.5) changePoints.push(t);

              // Track MAP run-length stats for evidence.
              let mapR = 0, mapLogR = newLogR[0];
              for (let i = 1; i < newLogR.length; i++) {
                if (newLogR[i] > mapLogR) { mapLogR = newLogR[i]; mapR = i; }
              }

              const newStats = new Array(stats.length + 1);
              newStats[0] = { n: 1, mean: x, m2: 0.0 };
              for (let r = 1; r < newStats.length; r++) {
                newStats[r] = updateWelford(stats[r - 1], x);
              }

              const mapSt = newStats[mapR] || newStats[0];
              segmentStats.push({ mean: mapSt.mean, var: mapSt.n > 1 ? mapSt.m2 / (mapSt.n - 1) : 0, n: mapSt.n });

              const K = 120;
              const idxs = newLogR.map((v, i) => [v, i]).sort((a, b) => b[0] - a[0]).slice(0, K).map((x) => x[1]).sort((a, b) => a - b);
              logR = idxs.map((i) => newLogR[i]);
              stats = idxs.map((i) => newStats[i]);
              const logZ2 = logR.reduce((a, b) => logAddExp(a, b), -Infinity);
              logR = logR.map((v) => v - logZ2);
            }

            // Build segments between change points.
            const cpWithBounds = [0, ...changePoints, y.length];
            const segments = [];
            for (let s = 0; s < cpWithBounds.length - 1; s++) {
              const start = cpWithBounds[s];
              const end = cpWithBounds[s + 1];
              const segValues = y.slice(start, end);
              const n = segValues.length;
              if (n === 0) continue;
              const mean = segValues.reduce((a, b) => a + b, 0) / n;
              const variance = n > 1 ? segValues.reduce((a, v) => a + (v - mean) * (v - mean), 0) / (n - 1) : 0;
              // Posterior mass for this segment: average p0 within segment (low = stable).
              const avgP0 = p0.slice(start, end).reduce((a, b) => a + b, 0) / n;
              segments.push({
                start, end: end - 1, length: n, mean, variance, stddev: Math.sqrt(variance),
                avgP0, confidence: 1 - avgP0,
                startMeta: meta[start] || null, endMeta: meta[end - 1] || null,
              });
            }

            // Build evidence ledger per change point.
            const evidence = changePoints.map((cpIdx) => {
              // Before: stats from previous segment.
              const prevEnd = cpIdx;
              const prevStart = Math.max(0, prevEnd - 10); // Look back up to 10 points.
              const beforeValues = y.slice(prevStart, prevEnd);
              const beforeMean = beforeValues.length ? beforeValues.reduce((a, b) => a + b, 0) / beforeValues.length : 0;
              const beforeVar = beforeValues.length > 1 ? beforeValues.reduce((a, v) => a + (v - beforeMean) * (v - beforeMean), 0) / (beforeValues.length - 1) : 0;

              // After: stats from current segment start.
              const afterEnd = Math.min(y.length, cpIdx + 10);
              const afterValues = y.slice(cpIdx, afterEnd);
              const afterMean = afterValues.length ? afterValues.reduce((a, b) => a + b, 0) / afterValues.length : 0;
              const afterVar = afterValues.length > 1 ? afterValues.reduce((a, v) => a + (v - afterMean) * (v - afterMean), 0) / (afterValues.length - 1) : 0;

              const metaEntry = meta[cpIdx] || {};
              return {
                idx: cpIdx,
                posteriorP0: p0[cpIdx],
                before: { mean: beforeMean, variance: beforeVar, stddev: Math.sqrt(beforeVar), n: beforeValues.length },
                after: { mean: afterMean, variance: afterVar, stddev: Math.sqrt(afterVar), n: afterValues.length },
                meanShift: afterMean - beforeMean,
                varianceRatio: beforeVar > 0 ? afterVar / beforeVar : afterVar > 0 ? Infinity : 1,
                ts: metaEntry.ts || "",
                hash: metaEntry.hash || "",
                buckets: metaEntry.buckets || [],
              };
            });

            return { p0, changePoints, segments, evidence, hazard: H, seriesLength: y.length };
          }


          async function computeAllMetrics(reqId, progressCb, includeLev) {
            const d = STATE.dataset;
            const commits = d?.commits || [];
            const patches = d?.patches || [];
            const tokensChanged = {};
            const bytesChanged = {};
            const hunks = {};
            const lev = {};
            const total = commits.length;
            for (let i = 0; i < total; i++) {
              throwIfCancelled(reqId);
              const c = commits[i] || {};
              const patch = patches[i] || "";
              const qm = quickMetricsFromPatch(patch);
              tokensChanged[c.hash] = qm.tokensChanged;
              bytesChanged[c.hash] = qm.bytesChanged;
              hunks[c.hash] = qm.hunks;
              if (includeLev && i > 0) {
                lev[c.hash] = await levenshteinForPatch(patch, reqId);
              }
              if (progressCb && (i === total - 1 || i % 3 === 0)) {
                progressCb({
                  stage: "metrics",
                  done: i + 1,
                  total,
                  haveLev: Object.keys(lev).length,
                  message: "Computing per-commit metrics",
                });
              }
            }
            return { tokensChanged, bytesChanged, hunks, lev, commitCount: total };
          }
          const AB_METRICS_CACHE = new Map();
          async function computeABMetrics(aIdx, bIdx, reqId, progressCb) {
            const key = aIdx + ":" + bIdx;
            if (AB_METRICS_CACHE.has(key)) return AB_METRICS_CACHE.get(key);
            progressCb({ stage: "ab_snapshot", message: "Reconstructing snapshot A" });
            const textA = docTextAtLocal(aIdx, reqId, progressCb);
            throwIfCancelled(reqId);
            progressCb({ stage: "ab_snapshot", message: "Reconstructing snapshot B" });
            const textB = docTextAtLocal(bIdx, reqId, progressCb);
            throwIfCancelled(reqId);
            progressCb({ stage: "ab_diff", message: "Computing A/B line diff" });
            const lA = textA.split("\\n"), lB = textB.split("\\n");
            let addL = 0, delL = 0, hn = 0, tokA = 0, tokD = 0, byA = 0, byD = 0;
            const n = lA.length, m = lB.length;
            let ia = 0, ib = 0, tags = [];
            while (ia < n || ib < m) {
              if (ia < n && ib < m && lA[ia] === lB[ib]) { tags.push(" "); ia++; ib++; }
              else {
                let fA = -1, fB = -1;
                const ahead = Math.min(200, Math.max(n - ia, m - ib));
                for (let k = 1; k <= ahead; k++) {
                  if (fA < 0 && ib + k < m && ia < n && lA[ia] === lB[ib + k]) fA = k;
                  if (fB < 0 && ia + k < n && ib < m && lB[ib] === lA[ia + k]) fB = k;
                  if (fA >= 0 || fB >= 0) break;
                }
                if (fA >= 0 && (fB < 0 || fA <= fB)) {
                  for (let k = 0; k < fA; k++) { const l = lB[ib++]; tags.push("+"); addL++; tokA += countRoughTokens(l); byA += l.length + 1; }
                } else if (fB >= 0) {
                  for (let k = 0; k < fB; k++) { const l = lA[ia++]; tags.push("-"); delL++; tokD += countRoughTokens(l); byD += l.length + 1; }
                } else {
                  if (ia < n) { const l = lA[ia++]; tags.push("-"); delL++; tokD += countRoughTokens(l); byD += l.length + 1; }
                  if (ib < m) { const l = lB[ib++]; tags.push("+"); addL++; tokA += countRoughTokens(l); byA += l.length + 1; }
                }
              }
              if (tags.length % 500 === 0) throwIfCancelled(reqId);
            }
            let prev = " ";
            for (const t of tags) { if (t !== " " && prev === " ") hn++; prev = t; }
            progressCb({ stage: "ab_lev", message: "Computing Levenshtein" });
            let lev = null;
            try { const enc = new TextEncoder(); lev = await levenshteinBytes(enc.encode(textA), enc.encode(textB)); } catch {}
            const res = { addLines: addL, delLines: delL, deltaLines: addL - delL, tokensChanged: tokA + tokD, tokensDelta: tokA - tokD, bytesChanged: byA + byD, bytesDelta: byA - byD, hunks: hn, lev, aIdx, bIdx };
            AB_METRICS_CACHE.set(key, res);
            return res;
          }

          function validateDatasetHash(inputHash) {
            if (!STATE.datasetHash) return;
            if (!inputHash) throw new Error("datasetHash missing on worker request");
            if (inputHash !== STATE.datasetHash) {
              throw new Error("datasetHash mismatch: stale request against a different dataset");
            }
          }

          self.onmessage = async (event) => {
            const msg = event?.data || {};
            const op = msg.op;
            const reqId = msg.reqId;
            const payload = msg.payload || {};
            const incomingHash = msg.datasetHash || "";
            if (!op) return;

            if (op === "cancel") {
              const targetReqId = payload.targetReqId;
              if (targetReqId) CANCELLED_REQS.add(targetReqId);
              self.postMessage({
                op,
                reqId,
                type: "ok",
                datasetHash: STATE.datasetHash || "",
                payload: { cancelledReqId: targetReqId || null },
              });
              return;
            }

            const progressCb = (info) => {
              self.postMessage({
                op,
                reqId,
                type: "progress",
                datasetHash: STATE.datasetHash || "",
                payload: info || {},
              });
            };

            try {
              if (!reqId) throw new Error("reqId is required");
              if (op !== "init_dataset") {
                if (!STATE.dataset) throw new Error("Worker dataset not initialized");
                validateDatasetHash(incomingHash);
              }
              throwIfCancelled(reqId);

              let result = null;
              switch (op) {
                case "init_dataset": {
                  const ds = payload.dataset;
                  const dsHash = payload.datasetHash || incomingHash;
                  if (!ds || !Array.isArray(ds.commits) || !Array.isArray(ds.patches)) {
                    throw new Error("Invalid dataset payload for init_dataset");
                  }
                  STATE.dataset = ds;
                  STATE.datasetHash = dsHash || "";
                  STATE.patchHunks = ds.patches.map((p) => parseUnifiedHunks(p));
                  STATE.snapshotCache.clear();
                  STATE.snapshotCache.set(0, String(ds.base_doc || ""));
                  STATE.snapshotCursorIdx = 0;
                  STATE.snapshotCursorLines = String(ds.base_doc || "").split("\\n");
                  STATE.searchIndex = null;
                  STATE.clusterData = null;
                  STATE.mostEditedSections = null;
                  result = {
                    datasetHash: STATE.datasetHash,
                    commits: ds.commits.length,
                    patches: ds.patches.length,
                  };
                  break;
                }
                case "snapshot_at": {
                  const idx = Number(payload.idx || 0);
                  const text = docTextAtLocal(idx, reqId, progressCb);
                  result = { idx, text };
                  break;
                }
                case "quick_patch_metrics": {
                  result = quickMetricsFromPatch(payload.patch || "");
                  break;
                }
                case "levenshtein_patch": {
                  const lev = await levenshteinForPatch(payload.patch || "", reqId);
                  result = { lev };
                  break;
                }
                case "compute_all_metrics": {
                  const includeLev = payload.includeLev !== false;
                  result = await computeAllMetrics(reqId, progressCb, includeLev);
                  break;
                }
                case "ab_metrics": {
                  const aIdx = Number(payload.aIdx || 0);
                  const bIdx = Number(payload.bIdx || 0);
                  result = await computeABMetrics(aIdx, bIdx, reqId, progressCb);
                  break;
                }
                case "build_search_index": {
                  result = buildSearchIndex(reqId, progressCb);
                  break;
                }
                case "export_search_index": {
                  result = exportSearchIndex();
                  break;
                }
                case "hydrate_search_index": {
                  const ok = hydrateSearchIndex(payload.data);
                  result = { hydrated: ok, docs: ok ? STATE.searchIndex.docs.length : 0, terms: ok ? STATE.searchIndex.postings.size : 0 };
                  break;
                }
                case "query_search": {
                  result = querySearch(payload.q || "", payload.limit || 20);
                  break;
                }
                case "first_introduced": {
                  result = findFirstIntroduced(payload.query || "", { contextLines: payload.contextLines || 3 });
                  break;
                }
                case "most_edited_sections": {
                  result = computeMostEditedSections(reqId, progressCb, { topK: payload.topK || 20 });
                  break;
                }

                case "compute_minhash_signatures": {
                  result = computeMinHashSignatures(reqId, progressCb, {
                    sigLen: payload.sigLen || 64,
                    shingleK: payload.shingleK || 5,
                    mode: payload.mode || "added",
                  });
                  break;
                }
                case "export_minhash_signatures": {
                  result = exportMinHashSignatures();
                  break;
                }
                case "hydrate_minhash_signatures": {
                  const ok = hydrateMinHashSignatures(payload.data);
                  result = { hydrated: ok, docs: ok ? STATE.minhashSignatures.meta.length : 0, sigLen: ok ? STATE.minhashSignatures.sigLen : 0 };
                  break;
                }
                case "compute_clusters": {
                  result = computeClusters(payload.limit || 12);
                  break;
                }
                case "compute_phase_map": {
                  result = computePhaseMap(payload.values || [], payload.hazard);
                  break;
                }
                case "compute_phase_map_enhanced": {
                  result = computePhaseMapEnhanced(payload.values || [], payload.hazard, payload.metadata || []);
                  break;
                }
                case "compute_outliers": {
                  result = computeOutliers(payload.values || [], payload.topK || 10);
                  break;
                }
                case "compute_outliers_robust": {
                  result = computeOutliersRobust(payload.entries || [], payload.topK || 10);
                  break;
                }
                case "compute_outliers_multi": {
                  result = computeOutliersMultiMetric(payload.metricSeries || {}, payload.topK || 10);
                  break;
                }
                case "extract_outline": {
                  const idx = Number(payload.idx || 0);
                  const text = docTextAtLocal(idx, reqId, progressCb);
                  result = { idx, outline: extractOutlineWorker(text) };
                  break;
                }
                case "heading_metrics": {
                  const idx = Number(payload.idx || 0);
                  const text = docTextAtLocal(idx, reqId, progressCb);
                  const outline = extractOutlineWorker(text);
                  const patch = patchForIdx(idx);
                  const totalLines = text.split("\\n").length;
                  const lineMap = buildLineToHeadingMapW(totalLines, outline);
                  const metrics = attributeHunksToHeadingsW(patch, lineMap);
                  result = { idx, outline, metrics };
                  break;
                }
                case "find_first_introduced": {
                  result = findFirstIntroduced(payload.query || "", { contextLines: payload.contextLines || 3 });
                  break;
                }
                case "compute_most_edited_sections": {
                  result = computeMostEditedSections(reqId, progressCb, { topK: payload.topK || 20 });
                  break;
                }
                default:
                  throw new Error("Unknown worker op: " + op);
              }

              throwIfCancelled(reqId);
              self.postMessage({
                op,
                reqId,
                type: "ok",
                datasetHash: STATE.datasetHash || "",
                payload: result,
              });
            } catch (err) {
              if (err?.name === "AbortError" || isCancelled(reqId)) {
                self.postMessage({
                  op,
                  reqId,
                  type: "cancelled",
                  datasetHash: STATE.datasetHash || "",
                  payload: { message: "Request cancelled" },
                });
              } else {
                self.postMessage({
                  op,
                  reqId,
                  type: "error",
                  datasetHash: STATE.datasetHash || "",
                  error: serializeError(err),
                });
              }
            } finally {
              CANCELLED_REQS.delete(reqId);
            }
          };
        `;
      }

      function tearDownWorker() {
        if (WORKER_STATE.worker) {
          try {
            WORKER_STATE.worker.terminate();
          } catch {
            // ignore
          }
        }
        WORKER_STATE.worker = null;
        WORKER_STATE.ready = false;
        for (const [reqId, req] of WORKER_STATE.pending.entries()) {
          if (req?.timeoutId) clearTimeout(req.timeoutId);
          req?.reject?.(new Error(`Worker terminated while handling reqId=${reqId}`));
        }
        WORKER_STATE.pending.clear();
      }

      function handleWorkerMessage(event) {
        const msg = event?.data || {};
        const reqId = msg.reqId;
        if (!reqId) return;
        const pending = WORKER_STATE.pending.get(reqId);
        if (!pending) return;

        if (msg.type === "progress") {
          pending.onProgress?.(msg.payload || {});
          return;
        }

        if (pending.timeoutId) clearTimeout(pending.timeoutId);
        WORKER_STATE.pending.delete(reqId);

        if (msg.type === "ok") {
          pending.resolve(msg.payload);
          return;
        }
        if (msg.type === "cancelled") {
          const abortErr = new DOMException("Worker request cancelled", "AbortError");
          pending.reject(abortErr);
          return;
        }

        const errObj = msg.error || {};
        const err = new Error(errObj.message || `Worker op failed (${msg.op || "unknown"})`);
        err.name = errObj.name || "WorkerError";
        if (errObj.stack) err.stack = errObj.stack;
        pending.reject(err);
      }

      // Ops that are never cached (mutating, init, or streaming-progress).
      const _UNCACHEABLE_OPS = new Set([
        "init_dataset", "cancel", "compute_minhash_signatures",
      ]);

	      function workerRequest(op, payload, opts = {}) {
	        if (!WORKER_STATE.worker || (op !== "init_dataset" && !WORKER_STATE.ready)) {
	          return Promise.reject(new Error(`Worker unavailable for op=${op}`));
	        }

        // --- Cache lookup (bd-24q.5.2) ---
        const useCache = opts.cache !== false && !opts.onProgress && !_UNCACHEABLE_OPS.has(op);
        if (useCache) {
          const hit = WORKER_RESULT_CACHE.get(op, payload);
          if (hit !== undefined) {
            PERF_BUDGET.log(op, 0.1, true);
            return Promise.resolve(hit);
          }
        }

        const reqId = `w${WORKER_STATE.reqSeq++}`;
        const timeoutMs = Number(opts.timeoutMs || 0);
        const signal = opts.signal || null;
        let aborted = false;
        let timeoutId = null;

        return new Promise((resolve, reject) => {
          const abortHandler = () => {
            aborted = true;
            try {
              WORKER_STATE.worker.postMessage({
                op: "cancel",
                reqId: `cancel-${reqId}`,
                datasetHash: WORKER_STATE.datasetHash,
                payload: { targetReqId: reqId },
              });
            } catch {
              // ignore transport errors
            }
            WORKER_STATE.pending.delete(reqId);
            reject(new DOMException("Aborted by caller", "AbortError"));
          };

          if (signal) {
            if (signal.aborted) {
              abortHandler();
              return;
            }
            signal.addEventListener("abort", abortHandler, { once: true });
          }

          if (timeoutMs > 0) {
            timeoutId = setTimeout(() => {
              WORKER_STATE.pending.delete(reqId);
              reject(new Error(`Worker request timed out: op=${op} reqId=${reqId} after ${timeoutMs}ms`));
            }, timeoutMs);
          }

          WORKER_STATE.pending.set(reqId, {
            resolve: (value) => {
              if (signal) signal.removeEventListener("abort", abortHandler);
              if (aborted) return;
              if (useCache) WORKER_RESULT_CACHE.set(op, payload, value);
              resolve(value);
            },
            reject: (err) => {
              if (signal) signal.removeEventListener("abort", abortHandler);
              if (aborted) return;
              reject(err);
            },
            onProgress: opts.onProgress,
            timeoutId,
          });

          WORKER_STATE.worker.postMessage({
            op,
            reqId,
            datasetHash: WORKER_STATE.datasetHash,
            payload: payload || {},
          });
        });
	      }

	      function materializeDatasetForWorker() {
	        if (!DATASET.db) throw new Error("DB not loaded");
	        const commitRows = dbQuery(
	          `SELECT
	             idx,
	             hash,
	             short,
	             date_iso AS dateIso,
	             author,
	             subject,
	             url,
	             add_lines,
	             del_lines,
	             impact
	           FROM commits
	           ORDER BY idx ASC`,
	        );
	        const commits = commitRows.map((r) => ({
	          idx: Number(r.idx || 0),
	          hash: String(r.hash || ""),
	          short: String(r.short || ""),
	          dateIso: String(r.dateIso || ""),
	          author: String(r.author || ""),
	          subject: String(r.subject || ""),
	          url: String(r.url || ""),
	          add: Number(r.add_lines || 0),
	          del: Number(r.del_lines || 0),
	          impact: Number(r.impact || 0),
	        }));

	        const patchRows = dbQuery("SELECT idx, patch FROM patches ORDER BY idx ASC");
	        const patches = new Array(commits.length).fill("");
	        for (const r of patchRows) {
	          const i = Number(r.idx || 0);
	          if (i >= 0 && i < patches.length) patches[i] = String(r.patch || "");
	        }

	        return {
	          base_doc: String(DATASET.baseDoc || ""),
	          commits,
	          patches,
	        };
	      }

	      async function initAnalysisWorker() {
	        if (!supportsAnalysisWorker()) {
	          WORKER_STATE.disabled = true;
	          setWorkerStatus("Web Worker unavailable; using main-thread compute fallback.", "error");
	          return false;
	        }
	        if (WORKER_STATE.ready) return true;
	        if (!DATASET.loaded || !DATASET.db) return false;

	        try {
	          if (!WORKER_STATE.datasetHash) {
	            WORKER_STATE.datasetHash = String(DATASET.meta?.db_hash || DB_STATE.cacheKey || "");
	          }
	          const src = makeAnalysisWorkerSource();
	          const blob = new Blob([src], { type: "text/javascript" });
	          const url = URL.createObjectURL(blob);
	          const worker = new Worker(url, { name: "spec-evolution-worker" });
          URL.revokeObjectURL(url);
          worker.addEventListener("message", handleWorkerMessage);
          worker.addEventListener("error", (event) => {
            setWorkerStatus(`Worker runtime error: ${event.message || "unknown error"}`, "error");
	          });
	          WORKER_STATE.worker = worker;

	          const ds = materializeDatasetForWorker();
	          const initPayload = await workerRequest("init_dataset", {
	            datasetHash: WORKER_STATE.datasetHash,
	            dataset: ds,
	          });

          if (!initPayload || initPayload.datasetHash !== WORKER_STATE.datasetHash) {
            throw new Error("Worker dataset initialization returned an unexpected dataset hash");
          }
          WORKER_STATE.ready = true;
          setWorkerStatus(
            `Worker online · dataset ${WORKER_STATE.datasetHash.slice(0, 12)}… · ${fmtInt(initPayload.commits)} commits`,
            "ok",
          );
          return true;
        } catch (e) {
          WORKER_STATE.disabled = true;
          tearDownWorker();
          setWorkerStatus("Worker init failed; fallback active.", "error", formatErr(e));
          return false;
        }
      }

      // localStorage key for cached search index (bd-24q.9.1).
      const SEARCH_INDEX_LS_KEY = "fsqlite_viz_search_index";
      const SEARCH_INDEX_SCHEMA_VERSION = 2;

      // localStorage key for cached MinHash signatures (bd-24q.14.1).
      const MINHASH_LS_KEY = "fsqlite_viz_minhash_sigs";
      const MINHASH_SCHEMA_VERSION = 1;

      // --- Perf Budget Logger + Progress Controller (bd-24q.5.3) ---
      const PERF_BUDGET = {
        entries: [],
        cacheHits: 0,
        cacheMisses: 0,
        log(op, ms, cached) {
          this.entries.push({ op, ms: Math.round(ms * 100) / 100, cached: !!cached, ts: Date.now() });
          if (cached) this.cacheHits++; else this.cacheMisses++;
          const hitRate = this.cacheHits + this.cacheMisses > 0
            ? ((this.cacheHits / (this.cacheHits + this.cacheMisses)) * 100).toFixed(1)
            : "0.0";
          console.log(`[perf] ${op}: ${ms.toFixed(1)}ms${cached ? " (cache hit)" : ""} · hit rate ${hitRate}%`);
        },
        summary() {
          const total = this.entries.reduce((s, e) => s + e.ms, 0);
          const hitRate = this.cacheHits + this.cacheMisses > 0
            ? ((this.cacheHits / (this.cacheHits + this.cacheMisses)) * 100).toFixed(1)
            : "0.0";
          console.log(`[perf] Summary: ${this.entries.length} ops, ${total.toFixed(0)}ms total, cache hit rate ${hitRate}% (${this.cacheHits}/${this.cacheHits + this.cacheMisses})`);
          return { entries: [...this.entries], totalMs: total, hitRate, hits: this.cacheHits, misses: this.cacheMisses };
        },
      };
      window.__perfBudget = PERF_BUDGET;

      let WARMUP_ABORT_CONTROLLER = null;

      function showWarmupProgress(pct, stage) {
        const wrap = document.getElementById("warmupProgress");
        const bar = document.getElementById("warmupProgressBar");
        const label = document.getElementById("warmupProgressLabel");
        const stageEl = document.getElementById("warmupStage");
        if (!wrap) return;
        wrap.classList.remove("hidden");
        if (bar) bar.style.width = Math.min(100, Math.max(0, pct)) + "%";
        if (label) label.textContent = Math.round(pct) + "%";
        if (stageEl && stage) stageEl.textContent = stage;
      }

      function hideWarmupProgress() {
        const wrap = document.getElementById("warmupProgress");
        if (wrap) wrap.classList.add("hidden");
      }

      async function warmDerivedWorkerArtifacts() {
        if (!WORKER_STATE.ready) return;
        WARMUP_ABORT_CONTROLLER?.abort();
        WARMUP_ABORT_CONTROLLER = new AbortController();
        const _wSignal = WARMUP_ABORT_CONTROLLER.signal;
        const _wT0 = performance.now();
        showWarmupProgress(0, "Starting warmup...");
        try {
          // Try loading cached search index from localStorage (bd-24q.9.1).
          let searchHydrated = false;
          try {
            const raw = localStorage.getItem(SEARCH_INDEX_LS_KEY);
            if (raw) {
              const cached = JSON.parse(raw);
              if (cached && cached.datasetHash === WORKER_STATE.datasetHash && cached.v === SEARCH_INDEX_SCHEMA_VERSION) {
                const res = await workerRequest("hydrate_search_index", { data: cached.index }, { timeoutMs: 10000 });
                if (res?.hydrated) { searchHydrated = true; console.log("[search] Hydrated from localStorage:", res.docs, "docs,", res.terms, "terms"); }
              }
            }
          } catch (e) { console.warn("[search] localStorage hydrate failed, will rebuild:", e); }

          if (_wSignal.aborted) throw new DOMException("Warmup cancelled", "AbortError");
          showWarmupProgress(5, "Building search index...");
          const _sT0 = performance.now();
          if (!searchHydrated) {
            await workerRequest("build_search_index", {}, { timeoutMs: 30000, signal: _wSignal });
            // Export and persist to localStorage.
            try {
              const exported = await workerRequest("export_search_index", {}, { timeoutMs: 10000 });
              if (exported) {
                localStorage.setItem(SEARCH_INDEX_LS_KEY, JSON.stringify({ v: SEARCH_INDEX_SCHEMA_VERSION, datasetHash: WORKER_STATE.datasetHash, index: exported }));
              }
            } catch (e) { console.warn("[search] localStorage persist failed:", e); }
          }
          WORKER_DERIVED.searchReady = true;
          PERF_BUDGET.log("search_index", performance.now() - _sT0, searchHydrated);

          if (_wSignal.aborted) throw new DOMException("Warmup cancelled", "AbortError");
          showWarmupProgress(25, "Computing MinHash signatures...");
          const _mT0 = performance.now();
          // Build or hydrate MinHash signatures (bd-24q.14.1), then cluster.
          let minhashHydrated = false;
          try {
            const raw = localStorage.getItem(MINHASH_LS_KEY);
            if (raw) {
              const cached = JSON.parse(raw);
              if (cached && cached.datasetHash === WORKER_STATE.datasetHash && cached.v === MINHASH_SCHEMA_VERSION) {
                const res = await workerRequest("hydrate_minhash_signatures", { data: cached.index }, { timeoutMs: 10000 });
                if (res?.hydrated) { minhashHydrated = true; console.log("[minhash] Hydrated from localStorage:", res.docs, "docs, sigLen:", res.sigLen); }
              }
            }
          } catch (e) { console.warn("[minhash] localStorage hydrate failed, will rebuild:", e); }

          if (!minhashHydrated) {
            await workerRequest("compute_minhash_signatures", { sigLen: 64, shingleK: 5, mode: "added" }, { timeoutMs: 60000, signal: _wSignal });
            try {
              const exported = await workerRequest("export_minhash_signatures", {}, { timeoutMs: 10000 });
              if (exported) {
                localStorage.setItem(MINHASH_LS_KEY, JSON.stringify({ v: MINHASH_SCHEMA_VERSION, datasetHash: WORKER_STATE.datasetHash, index: exported }));
              }
            } catch (e) { console.warn("[minhash] localStorage persist failed:", e); }
          }

          PERF_BUDGET.log("minhash_signatures", performance.now() - _mT0, minhashHydrated);

          if (_wSignal.aborted) throw new DOMException("Warmup cancelled", "AbortError");
          showWarmupProgress(55, "Computing clusters...");
          const _cT0 = performance.now();
          await workerRequest("compute_clusters", { limit: 12 }, { timeoutMs: 30000, signal: _wSignal });
          WORKER_DERIVED.clusterReady = true;
          void renderClusterPanel();
          PERF_BUDGET.log("compute_clusters", performance.now() - _cT0, false);

          if (_wSignal.aborted) throw new DOMException("Warmup cancelled", "AbortError");
          showWarmupProgress(75, "Computing most-edited sections...");
          const _eT0 = performance.now();
          // Precompute most-edited sections analytics (bd-24q.9.3).
          await workerRequest("compute_most_edited_sections", { topK: 20 }, { timeoutMs: 120000, signal: _wSignal });
          WORKER_DERIVED.mostEditedReady = true;
          PERF_BUDGET.log("most_edited_sections", performance.now() - _eT0, false);

          showWarmupProgress(100, "Done");
          PERF_BUDGET.log("warmup_total", performance.now() - _wT0, false);
          PERF_BUDGET.summary();
          hideWarmupProgress();
          setWorkerStatus("Worker online · search + clustering + analytics ready", "ok");
        } catch (e) {
          hideWarmupProgress();
          if (e?.name === "AbortError") {
            console.log("[warmup] Warmup cancelled by user");
            setWorkerStatus("Warmup cancelled. Some features may be unavailable.", "neutral");
          } else {
            console.error("Worker warmup failed:", e);
            setWorkerStatus("Worker warmup partial failure.", "error", formatErr(e));
          }
        }
      }

      // -------------------------------------------------------
      // Outlier Metric Series Builders (bd-24q.10.1)
      // -------------------------------------------------------

      /**
       * Build metric series entries from commits for outlier analysis.
       * Returns per-metric arrays ready for computeOutliersRobust worker call.
       */
      function buildOutlierMetricSeries(commits) {
        const series = { impact: [], linesAdded: [], linesDeleted: [] };
        const hasTokens = METRICS.tokensChanged.size > 0;
        const hasLev = METRICS.lev.size > 0;
        const hasHunks = METRICS.hunks.size > 0;
        if (hasTokens) series.tokens = [];
        if (hasLev) series.lev = [];
        if (hasHunks) series.hunks = [];

        for (const c of commits) {
          const entry = { ts: c.dateIso || "", hash: c.hash || "", idx: c.idx, buckets: c.labels || [] };
          series.impact.push({ ...entry, value: Number(c.impact || 0) });
          series.linesAdded.push({ ...entry, value: Number(c.add || 0) });
          series.linesDeleted.push({ ...entry, value: Number(c.del || 0) });
          if (hasTokens) series.tokens.push({ ...entry, value: Number(METRICS.tokensChanged.get(c.hash) || 0) });
          if (hasLev) series.lev.push({ ...entry, value: Number(METRICS.lev.get(c.hash) || 0) });
          if (hasHunks) series.hunks.push({ ...entry, value: Number(METRICS.hunks.get(c.hash) || 0) });
        }
        return series;
      }

      /**
       * Build time-bin aggregated series for outlier analysis.
       * Groups commits into bins by date and sums the metric per bin.
       */
      function buildTimeBinSeries(commits, binSize, metricField) {
        const bins = new Map();
        for (const c of commits) {
          if (!c.dateIso) continue;
          const d = new Date(c.dateIso);
          let key;
          if (binSize === "day") key = d.toISOString().slice(0, 10);
          else if (binSize === "week") {
            const ws = new Date(d); ws.setDate(d.getDate() - d.getDay());
            key = ws.toISOString().slice(0, 10);
          } else key = d.toISOString().slice(0, 7);

          if (!bins.has(key)) bins.set(key, { sum: 0, count: 0, ts: c.dateIso, hash: c.hash, idx: c.idx, bucketCounts: new Map() });
          const bin = bins.get(key);
          bin.sum += Number(c[metricField] || 0);
          bin.count++;
          for (const b of (c.labels || [])) bin.bucketCounts.set(b, (bin.bucketCounts.get(b) || 0) + 1);
        }
        return Array.from(bins.entries()).sort(([a], [b]) => a < b ? -1 : 1).map(([, bin]) => ({
          value: bin.sum, ts: bin.ts, hash: bin.hash, idx: bin.idx,
          buckets: Array.from(bin.bucketCounts.entries()).sort((a, b) => b[1] - a[1]).map(([id]) => id),
        }));
      }

      /**
       * Compute multi-metric outliers via worker (or inline fallback).
       * Returns { metricName: { median, mad, top: [...evidence...], all: [...] } }
       */
      async function computeMultiMetricOutliers(commits, topK) {
        const series = buildOutlierMetricSeries(commits);
        if (WORKER_STATE.ready) {
          try {
            return await workerRequest("compute_outliers_multi", { metricSeries: series, topK }, { timeoutMs: 30000 });
          } catch (e) { console.warn("Worker outlier fallback:", e); }
        }
        // Inline fallback (same algorithm, just runs on main thread).
        const results = {};
        for (const [name, entries] of Object.entries(series)) {
          results[name] = _inlineOutliersRobust(entries, topK);
        }
        return results;
      }

      /** Inline fallback for computeOutliersRobust (mirrors worker implementation). */
      function _inlineOutliersRobust(entries, topK) {
        if (!entries.length) return { median: 0, mad: 0, top: [], all: [] };
        const values = entries.map(e => Number(e.value || 0));
        const sorted = values.slice().sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        const med = sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        const absDev = values.map(v => Math.abs(v - med));
        const absSorted = absDev.slice().sort((a, b) => a - b);
        const absMid = Math.floor(absSorted.length / 2);
        const mad = absSorted.length % 2 ? absSorted[absMid] : (absSorted[absMid - 1] + absSorted[absMid]) / 2;
        const madSafe = mad || 1e-9;
        const scored = entries.map((e, i) => ({
          idx: e.idx ?? i, value: values[i], z: 0.6745 * (values[i] - med) / madSafe,
          ts: e.ts || "", hash: e.hash || "", buckets: e.buckets || [],
        }));
        scored.sort((a, b) => {
          const dz = Math.abs(b.z) - Math.abs(a.z);
          if (Math.abs(dz) > 1e-12) return dz;
          if (a.ts !== b.ts) return a.ts < b.ts ? -1 : 1;
          return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;
        });
        const k = Math.max(1, Math.min(Number(topK) || 10, scored.length));
        const top = scored.slice(0, k).map(e => ({
          idx: e.idx, value: e.value, z: e.z, ts: e.ts, hash: e.hash, buckets: e.buckets,
          evidence: { value: e.value, median: med, mad, z: e.z, contributingBuckets: e.buckets },
        }));
        return { median: med, mad, top, all: scored.map(e => ({ idx: e.idx, value: e.value, z: e.z })) };
      }

      // -------------------------------------------------------
      // Phase Map Enhanced: Main-Thread Wrapper (bd-24q.11.1)
      // -------------------------------------------------------

      /**
       * Compute enhanced BOCPD phase map with evidence ledger.
       * Uses worker if available, falls back to inline main-thread version.
       * @param {Array} commits - ALL_COMMITS or FILTERED_COMMITS
       * @param {number} hazard - BOCPD hazard rate (0..1)
       * @param {string} metricField - "impact", "add", "del"
       * @returns {{p0, changePoints, segments, evidence, hazard, seriesLength}}
       */
      async function computePhaseMapWithEvidence(commits, hazard, metricField) {
        const values = commits.map(c => Math.log1p(Number(c[metricField || "impact"] || 0)));
        const metadata = commits.map(c => ({
          ts: c.dateIso || "", hash: c.hash || "", idx: c.idx,
          buckets: c.labels || [], subject: c.subject || "",
        }));
        if (WORKER_STATE.ready) {
          try {
            return await workerRequest("compute_phase_map_enhanced", { values, hazard, metadata }, { timeoutMs: 30000 });
          } catch (e) { console.warn("Worker phase map fallback:", e); }
        }
        // Inline fallback.
        return _inlinePhaseMapEnhanced(values, hazard, metadata);
      }

      /** Inline fallback for computePhaseMapEnhanced. */
      function _inlinePhaseMapEnhanced(values, hazard, metadata) {
        const y = values.map(v => Number(v || 0));
        const H = Math.max(1e-4, Math.min(0.9999, Number(hazard || 0.03)));
        const meta = Array.isArray(metadata) ? metadata : [];
        let mu0 = 0.0, kappa0 = 0.01, alpha0 = 0.5, beta0 = 0.5;
        let logR = [0.0], stats = [{ n: 0, mean: 0.0, m2: 0.0 }];
        const p0 = [], changePoints = [];
        const logHaz = Math.log(H), log1mHaz = Math.log(1.0 - H);
        for (let t = 0; t < y.length; t++) {
          const x = y[t];
          const logPred = [];
          for (let r = 0; r < stats.length; r++) {
            const st = stats[r]; const n = st.n; const mean = st.mean;
            const kappa = kappa0 + n; const alpha = alpha0 + n / 2;
            const beta = beta0 + 0.5 * st.m2 + (kappa0 * n * (mean - mu0) * (mean - mu0)) / (2 * (kappa0 + n));
            logPred.push(studentTLogPdf(x, mean, Math.sqrt((beta * (kappa + 1)) / (alpha * kappa)), 2 * alpha));
          }
          const newLogR = new Array(stats.length + 1).fill(-Infinity);
          let logSumCp = -Infinity;
          for (let r = 0; r < logR.length; r++) logSumCp = logAddExp(logSumCp, logR[r] + logPred[r] + logHaz);
          newLogR[0] = logSumCp;
          for (let r = 0; r < logR.length; r++) newLogR[r + 1] = logR[r] + logPred[r] + log1mHaz;
          const logZ = newLogR.reduce((a, b) => logAddExp(a, b), -Infinity);
          for (let i = 0; i < newLogR.length; i++) newLogR[i] -= logZ;
          const p_r0 = Math.exp(newLogR[0]);
          p0.push(p_r0);
          if (p_r0 > 0.5) changePoints.push(t);
          const newStats = new Array(stats.length + 1);
          newStats[0] = { n: 1, mean: x, m2: 0.0 };
          for (let r = 1; r < newStats.length; r++) newStats[r] = updateWelford(stats[r - 1], x);
          const K = 120;
          const idxs = newLogR.map((v, i) => [v, i]).sort((a, b) => b[0] - a[0]).slice(0, K).map(x => x[1]).sort((a, b) => a - b);
          logR = idxs.map(i => newLogR[i]);
          stats = idxs.map(i => newStats[i]);
          const logZ2 = logR.reduce((a, b) => logAddExp(a, b), -Infinity);
          logR = logR.map(v => v - logZ2);
        }
        // Build segments.
        const cpWithBounds = [0, ...changePoints, y.length];
        const segments = [];
        for (let s = 0; s < cpWithBounds.length - 1; s++) {
          const start = cpWithBounds[s], end = cpWithBounds[s + 1];
          const sv = y.slice(start, end); const n = sv.length;
          if (n === 0) continue;
          const mean = sv.reduce((a, b) => a + b, 0) / n;
          const variance = n > 1 ? sv.reduce((a, v) => a + (v - mean) * (v - mean), 0) / (n - 1) : 0;
          const avgP0 = p0.slice(start, end).reduce((a, b) => a + b, 0) / n;
          segments.push({ start, end: end - 1, length: n, mean, variance, stddev: Math.sqrt(variance), avgP0, confidence: 1 - avgP0, startMeta: meta[start] || null, endMeta: meta[end - 1] || null });
        }
        // Build evidence.
        const evidence = changePoints.map(cpIdx => {
          const bv = y.slice(Math.max(0, cpIdx - 10), cpIdx);
          const bm = bv.length ? bv.reduce((a, b) => a + b, 0) / bv.length : 0;
          const bvar = bv.length > 1 ? bv.reduce((a, v) => a + (v - bm) * (v - bm), 0) / (bv.length - 1) : 0;
          const av = y.slice(cpIdx, Math.min(y.length, cpIdx + 10));
          const am = av.length ? av.reduce((a, b) => a + b, 0) / av.length : 0;
          const avar = av.length > 1 ? av.reduce((a, v) => a + (v - am) * (v - am), 0) / (av.length - 1) : 0;
          const me = meta[cpIdx] || {};
          return { idx: cpIdx, posteriorP0: p0[cpIdx], before: { mean: bm, variance: bvar, stddev: Math.sqrt(bvar), n: bv.length }, after: { mean: am, variance: avar, stddev: Math.sqrt(avar), n: av.length }, meanShift: am - bm, varianceRatio: bvar > 0 ? avar / bvar : avar > 0 ? Infinity : 1, ts: me.ts || "", hash: me.hash || "", buckets: me.buckets || [] };
        });
        return { p0, changePoints, segments, evidence, hazard: H, seriesLength: y.length };
      }


      // -------------------------------------------------------
      // History Search Analytics: Main-Thread API (bd-24q.9.3)
      // -------------------------------------------------------

      /**
       * Find earliest commit where a query appears in added lines.
       * Dispatches to worker; falls back to inline scan of STATE.dataset.
       * @param {string} query - search term or phrase
       * @param {number} contextLines - lines of context around match (default 3)
       * @returns {Promise<{found, query, commitIdx?, hash?, short?, subject?, matchLine?, contextLines?}>}
       */
      async function searchFirstIntroduced(query, contextLines) {
        if (WORKER_STATE.ready) {
          try {
            return await workerRequest("first_introduced", { query, contextLines: contextLines || 3 }, { timeoutMs: 15000 });
          } catch (e) { console.warn("Worker first_introduced fallback:", e); }
        }
        // Inline fallback: scan patches directly.
        const commits = ALL_COMMITS || [];
        const patches = STATE.dataset?.patches || [];
        if (!commits.length || !query) return { found: false, query };
        const q = query.toLowerCase().trim();
        const ctx = Math.max(0, Number(contextLines) || 3);
        for (let i = 0; i < patches.length; i++) {
          const patch = patches[i] || "";
          const lines = String(patch).split("\n");
          for (let j = 0; j < lines.length; j++) {
            const line = lines[j];
            if (!line.startsWith("+") || line.startsWith("+++")) continue;
            const text = line.slice(1);
            if (text.toLowerCase().includes(q)) {
              const ctxLines = [];
              const start = Math.max(0, j - ctx);
              const end = Math.min(lines.length - 1, j + ctx);
              for (let k = start; k <= end; k++) {
                const cl = lines[k];
                if (cl.startsWith("@@") || cl.startsWith("---") || cl.startsWith("+++")) continue;
                ctxLines.push({ line: k, prefix: cl[0] || " ", text: cl.slice(1), isMatch: k === j });
              }
              const c = commits[i] || {};
              return { found: true, query: q, commitIdx: i, hash: c.hash || "", short: c.short || "", subject: c.subject || "", author: c.author || "", matchLine: text, contextLines: ctxLines };
            }
          }
        }
        return { found: false, query: q };
      }

      /**
       * Compute per-heading edit mass across all commits.
       * Dispatches to worker; falls back to returning empty result (requires worker for full scan).
       * @param {number} topK - number of top headings to return (default 20)
       * @returns {Promise<{sections: Array}>}
       */
      async function searchMostEditedSections(topK) {
        if (WORKER_STATE.ready) {
          try {
            return await workerRequest("most_edited_sections", { topK: topK || 20 }, { timeoutMs: 60000 });
          } catch (e) { console.warn("Worker most_edited_sections fallback:", e); }
        }
        // Inline fallback: requires snapshot reconstruction only available in worker.
        console.warn("most_edited_sections requires worker (needs docTextAtLocal)");
        return { sections: [] };
      }

      async function maybeRefreshPhaseAndOutliers(commits) {
        if (!WORKER_STATE.ready || !Array.isArray(commits) || !commits.length) return;
        const hazard = Number(document.getElementById("hazard")?.value || 0.03);
        const values = commits.map((c) => Math.log1p(Number(c.impact || 0)));
        const outlierValues = commits.map((c) => Number(c.impact || 0));
        const phaseKey = `${hazard}|${values.join(",")}`;
        const outlierKey = outlierValues.join(",");

        if (WORKER_DERIVED.phaseKey === phaseKey && WORKER_DERIVED.outlierKey === outlierKey) return;

        PHASE_ABORT_CONTROLLER?.abort();
        OUTLIER_ABORT_CONTROLLER?.abort();
        PHASE_ABORT_CONTROLLER = new AbortController();
        OUTLIER_ABORT_CONTROLLER = new AbortController();

        try {
          const [phase, outliers] = await Promise.all([
            workerRequest(
              "compute_phase_map",
              { values, hazard },
              { signal: PHASE_ABORT_CONTROLLER.signal, timeoutMs: 30000 },
            ),
            workerRequest(
              "compute_outliers",
              { values: outlierValues, topK: 10 },
              { signal: OUTLIER_ABORT_CONTROLLER.signal, timeoutMs: 30000 },
            ),
          ]);
          WORKER_DERIVED.phase = phase || null;
          WORKER_DERIVED.outliers = outliers || null;
          WORKER_DERIVED.phaseKey = phaseKey;
          WORKER_DERIVED.outlierKey = outlierKey;
          setWorkerStatus(
            `Worker online · phase CP ${fmtInt(phase?.changePoints?.length || 0)} · outlier set ${fmtInt(
              outliers?.top?.length || 0,
            )}`,
            "ok",
          );
          renderBocpd(commits);
          renderPhaseOverlay(commits);
          void renderOutlierPanel(commits);
        } catch (e) {
          if (e?.name === "AbortError") return;
          console.error("Phase/outlier worker compute failed:", e);
        }
      }

      // -----------------------------
      // Dataset + WASM loading
      // -----------------------------

      async function initSqlJs() {
        if (DB_STATE.sql) return DB_STATE.sql;
        if (initSqlJs._p) return initSqlJs._p;

        initSqlJs._p = new Promise((resolve, reject) => {
          try {
            const script = document.createElement("script");
            script.async = true;
            script.src = "https://cdn.jsdelivr.net/npm/sql.js@1.10.3/dist/sql-wasm.js";
            script.onload = async () => {
              try {
                const SQL = await window.initSqlJs({
                  locateFile: (file) => `https://cdn.jsdelivr.net/npm/sql.js@1.10.3/dist/${file}`,
                });
                resolve(SQL);
              } catch (e) {
                reject(e);
              }
            };
            script.onerror = () => reject(new Error("Failed to load sql.js"));
            document.head.appendChild(script);
          } catch (e) {
            reject(e);
          }
        });

        DB_STATE.sql = await initSqlJs._p;
        return DB_STATE.sql;
      }

      async function fetchJSON(url, opts = {}) {
        const res = await fetch(url, opts);
        if (!res.ok) throw new Error(`Failed to fetch ${url}: HTTP ${res.status}`);
        return res.json();
      }

      function dbQuery(sql, params = []) {
        if (!DATASET.db) throw new Error("DB not loaded");
        const result = DATASET.db.exec(sql, params);
        if (!result.length) return [];
        const { columns, values } = result[0];
        return values.map((row) => {
          const obj = {};
          for (let i = 0; i < columns.length; i++) obj[columns[i]] = row[i];
          return obj;
        });
      }

      function dbScalar(sql, params = []) {
        if (!DATASET.db) throw new Error("DB not loaded");
        const result = DATASET.db.exec(sql, params);
        if (!result.length || !result[0]?.values?.length) return null;
        return result[0].values[0][0];
      }

      function loadDbMeta() {
        const meta = {};
        for (const row of dbQuery("SELECT key, value FROM meta")) {
          meta[String(row.key)] = String(row.value);
        }
        return meta;
      }

      async function loadFromOPFS(cacheKey) {
        if (!cacheKey) return null;
        if (!("storage" in navigator) || !navigator.storage.getDirectory) return null;
        try {
          const root = await navigator.storage.getDirectory();
          const filename = `fsqlite-spec-evolution-${cacheKey}.sqlite3`;
          const handle = await root.getFileHandle(filename, { create: false });
          const file = await handle.getFile();
          const buf = await file.arrayBuffer();
          return new Uint8Array(buf);
        } catch (e) {
          return null;
        }
      }

      async function cacheToOPFS(bytes, cacheKey) {
        if (!cacheKey) return false;
        if (!("storage" in navigator) || !navigator.storage.getDirectory) return false;
        try {
          const root = await navigator.storage.getDirectory();
          const filename = `fsqlite-spec-evolution-${cacheKey}.sqlite3`;
          const handle = await root.getFileHandle(filename, { create: true });
          const writable = await handle.createWritable();
          await writable.write(bytes);
          await writable.close();
          return true;
        } catch {
          return false;
        }
      }

      async function cleanStaleOPFS(currentCacheKey) {
        if (!currentCacheKey) return;
        if (!("storage" in navigator) || !navigator.storage.getDirectory) return;
        try {
          const root = await navigator.storage.getDirectory();
          const currentFile = `fsqlite-spec-evolution-${currentCacheKey}.sqlite3`;
          const stale = [];
          for await (const [name] of root.entries()) {
            if (name.startsWith("fsqlite-spec-evolution-") && name.endsWith(".sqlite3") && name !== currentFile) {
              stale.push(name);
            }
          }
          for (const name of stale) {
            await root.removeEntry(name);
          }
        } catch {
          // non-critical
        }
      }

      async function loadEvolutionDataset() {
        try {
          const SQL = await initSqlJs();

          // Load config (best-effort) for OPFS cache key.
          try {
            const cfg = await fetchJSON(SPEC_EVOLUTION_DB_CONFIG_URL, { cache: "no-store" });
            DB_STATE.cacheKey = cfg?.hash || null;
          } catch {
            DB_STATE.cacheKey = null;
          }

          let bytes = null;
          if (DB_STATE.cacheKey) {
            bytes = await loadFromOPFS(DB_STATE.cacheKey);
            if (bytes) DB_STATE.source = "cache";
          }

          if (!bytes) {
            const res = await fetch(SPEC_EVOLUTION_DB_URL, { cache: "force-cache" });
            if (!res.ok) throw new Error(`Failed to fetch ${SPEC_EVOLUTION_DB_URL}: HTTP ${res.status}`);
            bytes = new Uint8Array(await res.arrayBuffer());
            DB_STATE.source = "network";
          }

          DATASET.db = new SQL.Database(bytes);
          DATASET.meta = loadDbMeta();
          DATASET.baseDoc = String(dbScalar("SELECT text FROM base_doc WHERE id=1") || "");

          // Verify hash (when config is available).
          if (DB_STATE.cacheKey && DATASET.meta?.db_hash && DATASET.meta.db_hash !== DB_STATE.cacheKey) {
            console.warn("[db] Config hash does not match DB meta db_hash. You may be seeing a cached/stale DB.");
          }

          // Cache for next time.
          if (DB_STATE.source === "network" && DB_STATE.cacheKey) {
            cacheToOPFS(bytes, DB_STATE.cacheKey).then(() => cleanStaleOPFS(DB_STATE.cacheKey)).catch(() => {});
          }

          DATASET.loaded = true;
          DATASET.error = null;
          return true;
        } catch (e) {
          DATASET.error = String(e?.message || e);
          DATASET.loaded = false;
          return false;
        }
      }

      async function initLevWasm() {
        if (LEV_WASM) return LEV_WASM;
        const res = await fetch(LEV_WASM_URL, { cache: "force-cache" });
        if (!res.ok) throw new Error(`Failed to fetch ${LEV_WASM_URL}: HTTP ${res.status}`);
        const buf = await res.arrayBuffer();
        const { instance } = await WebAssembly.instantiate(buf, {});
        LEV_WASM = instance.exports;
        return LEV_WASM;
      }

      async function levenshteinBytes(aBytes, bBytes) {
        const ex = await initLevWasm();
        const { memory, alloc, dealloc, levenshtein } = ex;
        if (!memory || !alloc || !dealloc || !levenshtein) {
          throw new Error("WASM exports missing (expected memory/alloc/dealloc/levenshtein).");
        }

        const a = aBytes || new Uint8Array();
        const b = bBytes || new Uint8Array();

        const ptrA = alloc(a.length);
        let viewA = new Uint8Array(memory.buffer, ptrA, a.length);
        viewA.set(a);

        const ptrB = alloc(b.length);
        let viewB = new Uint8Array(memory.buffer, ptrB, b.length);
        viewB.set(b);

        const d = levenshtein(ptrA, a.length, ptrB, b.length) >>> 0;

        dealloc(ptrA, a.length);
        dealloc(ptrB, b.length);

        return d;
      }

      // -----------------------------
      // Unified diff helpers (single-file)
      // -----------------------------

      function countRoughTokens(s) {
        // Approximate tokens for visualization: words + punctuation runs.
        let n = 0;
        const re = /[A-Za-z0-9_]+|[^\s]/g;
        while (re.exec(String(s))) n++;
        return n;
      }

      function quickMetricsFromPatch(patch) {
        const lines = String(patch || "").split("\n");
        let hunks = 0;
        let addLines = 0;
        let delLines = 0;
        let tokAdd = 0;
        let tokDel = 0;
        let bytesAdd = 0;
        let bytesDel = 0;
        for (const l of lines) {
          if (l.startsWith("@@")) hunks += 1;
          if (l.startsWith("+")) {
            if (l.startsWith("+++")) continue;
            addLines += 1;
            const s = l.slice(1);
            tokAdd += countRoughTokens(s);
            bytesAdd += s.length + 1;
          } else if (l.startsWith("-")) {
            if (l.startsWith("---")) continue;
            delLines += 1;
            const s = l.slice(1);
            tokDel += countRoughTokens(s);
            bytesDel += s.length + 1;
          }
        }
        return {
          hunks,
          addLines,
          delLines,
          tokensChanged: tokAdd + tokDel,
          bytesChanged: bytesAdd + bytesDel,
          tokensDelta: tokAdd - tokDel,
          bytesDelta: bytesAdd - bytesDel,
        };
      }

      function parseUnifiedHunks(patch) {
        const lines = String(patch || "").split("\n");
        const hunks = [];
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (!line.startsWith("@@")) continue;
          const m = /^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/.exec(line);
          if (!m) continue;
          const oldStart = Number(m[1]);
          const oldCount = Number(m[2] || "1");
          const newStart = Number(m[3]);
          const newCount = Number(m[4] || "1");

          const hunkLines = [];
          i++;
          for (; i < lines.length; i++) {
            const l = lines[i];
            if (l.startsWith("@@")) {
              i--;
              break;
            }
            if (l.startsWith("diff --git")) break;
            if (l.startsWith("index ") || l.startsWith("---") || l.startsWith("+++")) continue;
            hunkLines.push(l);
          }

          hunks.push({ oldStart, oldCount, newStart, newCount, lines: hunkLines });
        }
        return hunks;
      }

      const BUCKET_MAP = new Map();
      function bucketById(id) {
        if (BUCKET_MAP.size === 0) {
          for (const b of BUCKETS) BUCKET_MAP.set(b.id, b);
        }
        return BUCKET_MAP.get(id) || BUCKETS[BUCKETS.length - 1];
      }

	      function pickPrimary(labels) {
	        const s = new Set(labels);
	        if (s.has(2)) return 2;
	        if (s.has(3)) return 3;
	        if (s.has(1)) return 1;
	        if (s.has(4)) return 4;
	        if (s.has(8)) return 8;
	        if (s.has(7)) return 7;
	        if (s.has(6)) return 6;
	        if (s.has(5)) return 5;
	        if (s.has(9)) return 9;
	        return 10;
	      }

	      // -----------------------------
	      // Rendering
	      // -----------------------------

      let chartTimeline = null;
      let chartStack = null;
      let chartDonut = null;
      let chartBocpd = null;

      let ALL_COMMITS = [];
      let FILTERED_COMMITS = [];
      let DOCK_READY = false;

      let _lastChartsCommitsHash = "";
      let _lastCommitListCommitsHash = "";
      let _lastCommitListBucketMode = "";
      let _lastSectionIdx = -1;
      let _lastSectionFilter = "";

      // --- Phase 1: Lazy enrichment cache (parse + enrich once) ---
      let ENRICHED_READY = false;
      let ENRICHED_MISSING = [];

      function ensureEnriched() {
        if (ENRICHED_READY) return;
        if (!DATASET.db) throw new Error("DB not loaded");

	        const commits = dbQuery(
	          `SELECT
	             idx,
	             hash,
	             short,
	             date_iso AS dateIso,
	             author,
	             subject,
	             url,
	             add_lines,
	             del_lines,
	             impact,
	             labels_json,
	             primary_bucket,
	             has_classification
	           FROM commits
	           ORDER BY idx ASC`,
	        );

	        const groups = dbQuery(
	          `SELECT
	             commit_hash AS hash,
	             group_idx AS groupIdx,
	             summary,
	             confidence,
	             evidence_json,
	             changed_headings_json,
	             labels_json,
	             primary_bucket
	           FROM change_groups
	           ORDER BY commit_hash ASC, group_idx ASC`,
	        );

        const groupsByHash = new Map();
        for (const g of groups) {
          const h = String(g.hash || "");
          if (!groupsByHash.has(h)) groupsByHash.set(h, []);
          let evidence = [];
          let changed_headings = [];
          let labels = [];
          try { evidence = JSON.parse(String(g.evidence_json || "[]")); } catch { evidence = []; }
          try { changed_headings = JSON.parse(String(g.changed_headings_json || "[]")); } catch { changed_headings = []; }
          try { labels = JSON.parse(String(g.labels_json || "[]")); } catch { labels = []; }
	          groupsByHash.get(h).push({
	            summary: String(g.summary || ""),
	            evidence: Array.isArray(evidence) ? evidence : [],
	            changed_headings: Array.isArray(changed_headings) ? changed_headings : [],
	            confidence: typeof g.confidence === "number" ? g.confidence : Number(g.confidence || 0.55),
	            labels: Array.isArray(labels) ? labels : [],
	            primary: Number(g.primary_bucket || pickPrimary(Array.isArray(labels) ? labels : [10])),
	          });
	        }

        const missing = [];
        ALL_COMMITS = commits.map((c) => {
          const h = String(c.hash || "");
          const hasClassification = Boolean(Number(c.has_classification || 0));
          if (!hasClassification) missing.push(h);
          let labels = [];
          try { labels = JSON.parse(String(c.labels_json || "[]")); } catch { labels = []; }
	          return {
	            idx: Number(c.idx || 0),
	            hash: h,
	            short: String(c.short || ""),
	            dateIso: String(c.dateIso || ""),
	            author: String(c.author || ""),
	            subject: String(c.subject || ""),
	            url: String(c.url || ""),
	            add: Number(c.add_lines || 0),
	            del: Number(c.del_lines || 0),
	            impact: Number(c.impact || 0),
	            labels: Array.isArray(labels) ? labels : [],
	            primary: Number(c.primary_bucket || pickPrimary(Array.isArray(labels) ? labels : [10])),
	            changeGroups: groupsByHash.get(h) || [],
	            hasClassification,
	          };
	        });

        ENRICHED_MISSING = missing;

        ENRICHED_READY = true;
      }

      let _renderRafId = 0;
      function render() {
        if (_renderRafId) return;
        _renderRafId = requestAnimationFrame(() => {
          _renderRafId = 0;
          _doRender();
        });
      }

      const _renderElements = {
        kpiCommits: null,
        kpiGroups: null,
        kpiLines: null,
        kpiMode: null,
        kpiIntegrity: null,
        impact: null,
        impactMobile: null,
        impactLabel: null,
        impactLabelMobile: null,
        rangeLabel: null,
        metaSpan: null,
        showingCount: null
      };

      function _getRenderElement(id) {
        if (!_renderElements[id]) _renderElements[id] = document.getElementById(id);
        return _renderElements[id];
      }

      function _doRender() {
        ensureEnriched();
        const enriched = ALL_COMMITS;
        const missing = ENRICHED_MISSING;

        // KPI
        const kpiCommits = _getRenderElement("kpiCommits");
        const kpiGroups = _getRenderElement("kpiGroups");
        const kpiLines = _getRenderElement("kpiLines");
        const kpiMode = _getRenderElement("kpiMode");
        const kpiIntegrity = _getRenderElement("kpiIntegrity");

        if (kpiCommits) kpiCommits.textContent = fmtInt(enriched.length);
        const totalGroups = enriched.reduce((acc, c) => acc + c.changeGroups.length, 0);
        if (kpiGroups) kpiGroups.textContent = fmtInt(totalGroups);
        const totalLines = enriched.reduce((acc, c) => acc + c.impact, 0);
        if (kpiLines) kpiLines.textContent = fmtInt(totalLines);
        if (kpiMode) kpiMode.textContent = STATE.bucketMode === "primary" ? "Primary" : "Multi";
        if (kpiIntegrity) kpiIntegrity.textContent = missing.length ? `${missing.length} missing` : "OK";

        // Make the impact slider usable even with very large commits: cap at ~p99.
        {
          const impacts = enriched.map((c) => c.impact).slice().sort((a, b) => a - b);
          const idx = Math.max(0, Math.ceil(0.99 * impacts.length) - 1);
          const p99 = impacts[idx] || 200;
          const maxImpact = Math.max(200, p99);
          const impact = _getRenderElement("impact");
          const impactMobile = _getRenderElement("impactMobile");
          const impactLabel = _getRenderElement("impactLabel");
          const impactLabelMobile = _getRenderElement("impactLabelMobile");

          if (impact && impactMobile) {
            impact.max = String(maxImpact);
            impactMobile.max = String(maxImpact);
            if (STATE.minImpact > maxImpact) {
              STATE.minImpact = maxImpact;
              impact.value = String(maxImpact);
              impactMobile.value = String(maxImpact);
              if (impactLabel) impactLabel.textContent = `${fmtInt(maxImpact)} lines`;
              if (impactLabelMobile) impactLabelMobile.textContent = `${fmtInt(maxImpact)} lines`;
            }
          }
        }

        const earliest = enriched[0];
        const latest = enriched[enriched.length - 1];
        if (earliest && latest) {
          const rangeLabel = _getRenderElement("rangeLabel");
          const metaSpan = _getRenderElement("metaSpan");
          if (rangeLabel) rangeLabel.textContent = `${earliest.short} → ${latest.short}`;
          if (metaSpan) metaSpan.textContent = `${dayjs(earliest.dateIso).format("YYYY-MM-DD HH:mm")} to ${dayjs(latest.dateIso).format("HH:mm")}`;
        }

        // Filter
        const q = STATE.q.trim().toLowerCase();
        const filtered = enriched.filter((c) => matchesFilters(c, q));
        FILTERED_COMMITS = filtered;
        const showingCount = _getRenderElement("showingCount");
        if (showingCount) showingCount.textContent = `${fmtInt(filtered.length)} commits`;

        // Charts + list
        renderBucketToggles();
        renderCharts(filtered);
        renderCommitList(filtered);
        syncDockAndDoc();

        // Make sure code highlighting is applied to newly inserted excerpts
        requestIdleCallback(() => {
          document.querySelectorAll("pre code:not(.hljs)").forEach((el) => {
            try {
              hljs.highlightElement(el);
            } catch {
              // ignore
            }
          });
        }, { timeout: 500 });

        // Keep URL in sync with filter/view state.
        syncUrlToState();
      }

      function matchesFilters(commit, q) {
        if (commit.impact < STATE.minImpact) return false;
        if (q) {
          const hay =
            `${commit.hash} ${commit.short} ${commit.author} ${commit.subject} ${commit.changeGroups
              .map((g) => `${g.summary} ${(g.changed_headings || []).join(" ")} ${(g.evidence || []).join(" ")}`)
              .join(" ")}`.toLowerCase();
          if (!hay.includes(q)) return false;
        }

        const enabled = STATE.bucketEnabled;
        if (STATE.bucketMode === "primary") {
          return enabled.has(commit.primary);
        }
        // multi-label: require overlap
        return commit.labels.some((b) => enabled.has(b));
      }

      // -----------------------------
      // Dock + Doc Evolution UI
      // -----------------------------

      const DOC_CURSOR = {
        idx: 0,
        lines: null,
      };

      function setDocTab(tab) {
        DOC.tab = tab;
        // Buttons
        const btnSpec = document.getElementById("docTabSpec");
        const btnDiff = document.getElementById("docTabDiff");
        const btnMetrics = document.getElementById("docTabMetrics");
        const btnSections = document.getElementById("docTabSections");
        const on = "focus-ring rounded-2xl bg-slate-900 px-3 py-2 text-xs font-semibold text-white hover:bg-slate-800";
        const off =
          "focus-ring rounded-2xl border border-slate-900/10 bg-white/70 px-3 py-2 text-xs font-semibold text-slate-900 hover:bg-white";
        if (btnSpec) btnSpec.className = tab === "spec" ? on : off;
        if (btnDiff) btnDiff.className = tab === "diff" ? on : off;
        if (btnMetrics) btnMetrics.className = tab === "metrics" ? on : off;
        if (btnSections) btnSections.className = tab === "sections" ? on : off;
        updateDocPanelVisibility();
        syncUrlToState();
        // Re-render diff/spec if needed.
        void updateDocUI();
      }

      function updateDocPanelVisibility() {
        const spec = document.getElementById("docSpecView");
        const diff = document.getElementById("docDiffView");
        const metrics = document.getElementById("docMetricsView");
        const sections = document.getElementById("docSectionsView");
        if (!spec || !diff || !metrics) return;
        spec.classList.toggle("hidden", DOC.tab !== "spec");
        diff.classList.toggle("hidden", DOC.tab !== "diff");
        metrics.classList.toggle("hidden", DOC.tab !== "metrics");
        if (sections) sections.classList.toggle("hidden", DOC.tab !== "sections");
      }

      const PATCH_CACHE = new Map(); // idx -> patch string
      function patchForIdx(idx) {
        const i = Number(idx || 0);
        if (PATCH_CACHE.has(i)) return PATCH_CACHE.get(i);
        if (!DATASET.db) return "";
        const patch = String(dbScalar("SELECT patch FROM patches WHERE idx = ?", [i]) || "");
        PATCH_CACHE.set(i, patch);
        return patch;
      }

      // --- A/B Compare Typeahead Picker System (bd-24q.1) ---

      /** Format a commit label for the picker button. */
      function fmtPickerLabel(idx) {
        const c = ALL_COMMITS[idx];
        if (!c) return `#${idx}`;
        return `#${idx} ${c.short} – ${c.subject.slice(0, 32)}`;
      }

      /** Render commit items into a picker list element, filtered by query. */
      function renderPickerList(listEl, query, selectedIdx, onSelect) {
        listEl.innerHTML = "";
        const q = (query || "").toLowerCase().trim();
        const items = [];
        for (let i = 0; i < ALL_COMMITS.length; i++) {
          const c = ALL_COMMITS[i];
          const searchable = `#${i} ${c.short} ${c.hash} ${c.subject}`.toLowerCase();
          if (q && !searchable.includes(q)) continue;
          items.push(i);
        }
        if (items.length === 0) {
          const empty = document.createElement("div");
          empty.className = "px-3 py-4 text-center text-[11px] text-slate-400";
          empty.textContent = q ? "No matching commits" : "No commits loaded";
          listEl.appendChild(empty);
          return;
        }
        for (const i of items) {
          const c = ALL_COMMITS[i];
          const div = document.createElement("div");
          div.className = "ab-picker-item" + (i === selectedIdx ? " selected" : "");
          div.dataset.idx = i;
          div.innerHTML = `<span class="idx">#${i}</span><span class="hash">${escapeHtml(c.short)}</span><span class="subject">${escapeHtml(c.subject)}</span>`;
          div.addEventListener("click", () => onSelect(i));
          listEl.appendChild(div);
        }
      }

      /** Open a typeahead picker dropdown. */
      function openPicker(pickerId) {
        const dropdown = document.getElementById(pickerId + "Dropdown");
        const search = document.getElementById(pickerId + "Search");
        if (!dropdown) return;
        // Close any other open picker first.
        document.querySelectorAll(".ab-picker-dropdown").forEach(d => { if (d.id !== pickerId + "Dropdown") d.classList.add("hidden"); });
        dropdown.classList.remove("hidden");
        if (search) { search.value = ""; search.focus(); }
        const isA = pickerId === "pickerA";
        const selectedIdx = isA ? DOC.compareFromIdx : DOC.compareToIdx;
        const listEl = document.getElementById(pickerId + "List");
        if (listEl) {
          renderPickerList(listEl, "", selectedIdx, (idx) => {
            if (isA) DOC.compareFromIdx = idx; else DOC.compareToIdx = idx;
            closePicker(pickerId);
            populateCompareSelects();
            syncUrlToState();
            void updateDocUI();
          });
          // Scroll selected item into view.
          requestAnimationFrame(() => {
            const sel = listEl.querySelector(".selected");
            if (sel) sel.scrollIntoView({ block: "center", behavior: "instant" });
          });
        }
      }

      /** Close a typeahead picker dropdown. */
      function closePicker(pickerId) {
        const dropdown = document.getElementById(pickerId + "Dropdown");
        if (dropdown) dropdown.classList.add("hidden");
      }

      /** Wire up search input filtering for a picker. */
      function wirePickerSearch(pickerId) {
        const search = document.getElementById(pickerId + "Search");
        const listEl = document.getElementById(pickerId + "List");
        if (!search || !listEl) return;
        let debounce = 0;
        const isA = pickerId === "pickerA";
        search.addEventListener("input", () => {
          clearTimeout(debounce);
          debounce = setTimeout(() => {
            const selectedIdx = isA ? DOC.compareFromIdx : DOC.compareToIdx;
            renderPickerList(listEl, search.value, selectedIdx, (idx) => {
              if (isA) DOC.compareFromIdx = idx; else DOC.compareToIdx = idx;
              closePicker(pickerId);
              populateCompareSelects();
              syncUrlToState();
              void updateDocUI();
            });
          }, 80);
        });
        // Keyboard navigation.
        search.addEventListener("keydown", (e) => {
          if (e.key === "Escape") { closePicker(pickerId); return; }
          if (e.key === "ArrowDown" || e.key === "ArrowUp") {
            e.preventDefault();
            const items = listEl.querySelectorAll(".ab-picker-item");
            if (!items.length) return;
            let active = listEl.querySelector(".keyboard-active");
            let nextIdx = 0;
            if (active) {
              active.classList.remove("keyboard-active");
              const arr = Array.from(items);
              const cur = arr.indexOf(active);
              nextIdx = e.key === "ArrowDown" ? Math.min(cur + 1, arr.length - 1) : Math.max(cur - 1, 0);
            }
            items[nextIdx].classList.add("keyboard-active");
            items[nextIdx].scrollIntoView({ block: "nearest" });
          }
          if (e.key === "Enter") {
            const active = listEl.querySelector(".keyboard-active") || listEl.querySelector(".ab-picker-item");
            if (active) active.click();
          }
        });
      }

      /** Populate the A/B compare typeahead pickers from ALL_COMMITS. */
      function populateCompareSelects() {
        if (!ALL_COMMITS.length) return;
        // Update picker button labels.
        const btnA = document.getElementById("pickerABtn");
        const btnB = document.getElementById("pickerBBtn");
        if (btnA) btnA.textContent = fmtPickerLabel(DOC.compareFromIdx);
        if (btnB) btnB.textContent = fmtPickerLabel(DOC.compareToIdx);
      }

      /**
       * Generate a unified diff between two arbitrary commit snapshots.
       * Uses jsdiff (Diff library) to compute and returns a unified-diff string
       * suitable for Diff2Html rendering.
       */
      async function generateABDiff(fromIdx, toIdx) {
        const loading = document.getElementById("abDiffLoading");
        if (loading) loading.classList.remove("hidden");
        try {
          const [textA, textB] = await Promise.all([
            docTextAt(fromIdx),
            docTextAt(toIdx),
          ]);
          const commitA = ALL_COMMITS[fromIdx];
          const commitB = ALL_COMMITS[toIdx];
          const nameA = commitA ? `${commitA.short} (${commitA.subject.slice(0, 30)})` : `commit #${fromIdx}`;
          const nameB = commitB ? `${commitB.short} (${commitB.subject.slice(0, 30)})` : `commit #${toIdx}`;
          // Diff.createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader)
          const patch = Diff.createTwoFilesPatch(
            nameA, nameB,
            textA, textB,
            `commit #${fromIdx}`, `commit #${toIdx}`
          );
          return patch;
        } finally {
          if (loading) loading.classList.add("hidden");
        }
      }

      // -----------------------------
      // Side-by-Side Rendered Markdown (bd-24q.15.1)
      // -----------------------------

      function renderMarkdownToPane(text, paneEl, idPrefix) {
        if (!paneEl) return;
        if (!window._mdSingleton) {
          window._mdSingleton = markdownit({
            html: false, linkify: true, typographer: true,
            highlight: (str, lang) => {
              try {
                if (lang && hljs.getLanguage(lang)) return `<pre class="hljs"><code>${hljs.highlight(str, { language: lang }).value}</code></pre>`;
                return `<pre class="hljs"><code>${hljs.highlightAuto(str).value}</code></pre>`;
              } catch { return `<pre class="hljs"><code>${escapeHtml(str)}</code></pre>`; }
            },
          });
        }
        const outline = extractOutline(text);
        const prefix = idPrefix || "";
        let oIdx = 0;
        const orig = window._mdSingleton.renderer.rules.heading_open;
        window._mdSingleton.renderer.rules.heading_open = (tokens, idx, options, env, self) => {
          const entry = outline[oIdx++];
          if (entry) tokens[idx].attrSet("id", prefix + entry.id);
          return self.renderToken(tokens, idx, options);
        };
        const html = window._mdSingleton.render(text || "");
        paneEl.innerHTML = DOMPurify.sanitize(html, { ADD_ATTR: ["id"] });
        if (orig) window._mdSingleton.renderer.rules.heading_open = orig;
        else delete window._mdSingleton.renderer.rules.heading_open;
      }

      // --- Inline Highlights: Hunk-to-DOM Mapping (bd-24q.16.1) ---
      function parsePatchChangedNewLines(patch) {
        const changed = new Set();
        const lines = String(patch || "").split("\n");
        for (let i = 0; i < lines.length; i++) {
          if (!lines[i].startsWith("@@")) continue;
          const m = /^@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)? @@/.exec(lines[i]);
          if (!m) continue;
          let nl = Number(m[1]);
          for (i++; i < lines.length; i++) {
            const l = lines[i];
            if (l.startsWith("@@") || l.startsWith("diff ")) { i--; break; }
            if (l.startsWith("---") || l.startsWith("+++") || l.startsWith("index ")) continue;
            if (l[0] === "+") { changed.add(nl); nl++; }
            else if (l[0] !== "-") nl++;
          }
        }
        return changed;
      }
      function renderMarkdownWithSentinels(text, paneEl, idPrefix, changedLines) {
        if (!paneEl) return;
        if (!window._mdSingleton) {
          window._mdSingleton = markdownit({ html: false, linkify: true, typographer: true,
            highlight: (str, lang) => { try { if (lang && hljs.getLanguage(lang)) return '<pre class="hljs"><code>' + hljs.highlight(str, { language: lang }).value + "</code></pre>"; return '<pre class="hljs"><code>' + hljs.highlightAuto(str).value + "</code></pre>"; } catch { return '<pre class="hljs"><code>' + escapeHtml(str) + "</code></pre>"; } },
          });
        }
        const outline = extractOutline(text);
        const prefix = idPrefix || "";
        let oIdx = 0;
        const md = window._mdSingleton;
        const origHO = md.renderer.rules.heading_open;
        md.renderer.rules.heading_open = (tokens, idx, options, env, self) => { const entry = outline[oIdx++]; if (entry) tokens[idx].attrSet("id", prefix + entry.id); return self.renderToken(tokens, idx, options); };
        const origRT = md.renderer.renderToken.bind(md.renderer);
        md.renderer.renderToken = function (tokens, idx, options) {
          const tok = tokens[idx];
          if (tok.map && tok.nesting === 1) {
            tok.attrSet("data-srcmap", tok.map[0] + ":" + tok.map[1]);
            if (changedLines) { for (let ln = tok.map[0]; ln < tok.map[1]; ln++) { if (changedLines.has(ln + 1)) { tok.attrSet("data-changed", "true"); break; } } }
          }
          return origRT(tokens, idx, options);
        };
        const html = md.render(text || "");
        paneEl.innerHTML = DOMPurify.sanitize(html, { ADD_ATTR: ["id", "data-srcmap", "data-changed"] });
        md.renderer.renderToken = origRT;
        if (origHO) md.renderer.rules.heading_open = origHO; else delete md.renderer.rules.heading_open;
      }
      function applyInlineHighlights(paneEl) { if (!paneEl) return; for (const el of paneEl.querySelectorAll("[data-changed='true']")) el.classList.add("ih-changed"); }
      function clearInlineHighlights(paneEl) { if (!paneEl) return; for (const el of paneEl.querySelectorAll(".ih-changed")) el.classList.remove("ih-changed"); for (const el of paneEl.querySelectorAll(".ih-debug")) el.classList.remove("ih-debug"); }
      function toggleHighlightDebug(paneEl, enabled) { if (!paneEl) return; for (const el of paneEl.querySelectorAll("[data-srcmap]")) { el.classList.toggle("ih-debug", enabled); if (enabled) el.title = "Lines: " + el.getAttribute("data-srcmap") + (el.dataset.changed ? " [CHANGED]" : ""); else el.removeAttribute("title"); } }
      function navigateChangedBlock(paneEl, direction) {
        if (!paneEl) return null;
        const blocks = Array.from(paneEl.querySelectorAll("[data-changed='true']"));
        if (!blocks.length) return null;
        const thresh = paneEl.scrollTop + (direction === "next" ? 20 : -20);
        const target = direction === "next" ? blocks.find((el) => el.offsetTop > thresh) || blocks[0] : blocks.reverse().find((el) => el.offsetTop < thresh) || blocks[0];
        target.scrollIntoView({ behavior: "smooth", block: "center" });
        return target;
      }

      // --- Inline Highlights: Controller (bd-24q.16.2) ---
      let _ihCurrentIdx = -1;
      let _ihBlocks = [];

      function toggleInlineHighlights() {
        DOC.inlineHighlights = !DOC.inlineHighlights;
        const btn = document.getElementById("btnIHToggle");
        const nav = document.getElementById("ihNav");
        if (btn) { btn.classList.toggle("bg-slate-900", DOC.inlineHighlights); btn.classList.toggle("text-white", DOC.inlineHighlights); }
        if (nav) nav.style.display = DOC.inlineHighlights ? "flex" : "none";
        syncUrlToState();
        applyOrClearSpecHighlights();
      }

      function applyOrClearSpecHighlights() {
        const rendered = document.getElementById("docRendered");
        if (!rendered) return;
        if (DOC.inlineHighlights && DOC.tab === "spec" && DOC.idx > 0) {
          const patch = patchForIdx(DOC.idx);
          const changedLines = parsePatchChangedNewLines(patch);
          if (!rendered.querySelector("[data-srcmap]")) {
            void (async () => {
              const text = await docTextAt(DOC.idx);
              renderMarkdownWithSentinels(text, rendered, "", changedLines);
              applyInlineHighlights(rendered);
              _ihRefreshNav();
              _ihSetupPopover();
            })();
          } else {
            applyInlineHighlights(rendered);
            _ihRefreshNav();
          }
        } else {
          clearInlineHighlights(rendered);
          _ihBlocks = [];
          _ihCurrentIdx = -1;
          _ihUpdateNavLabel();
          _ihHidePopover();
        }
      }

      function _ihRefreshNav() {
        const rendered = document.getElementById("docRendered");
        _ihBlocks = rendered ? Array.from(rendered.querySelectorAll("[data-changed='true']")) : [];
        _ihCurrentIdx = -1;
        _ihUpdateNavLabel();
      }

      function _ihUpdateNavLabel() {
        const lbl = document.getElementById("ihNavLabel");
        if (!lbl) return;
        if (!_ihBlocks.length) { lbl.textContent = "0/0"; return; }
        lbl.textContent = `${_ihCurrentIdx < 0 ? "-" : _ihCurrentIdx + 1}/${_ihBlocks.length}`;
      }

      function ihNavigate(direction) {
        if (!_ihBlocks.length) return;
        if (direction === "next") {
          _ihCurrentIdx = (_ihCurrentIdx + 1) % _ihBlocks.length;
        } else {
          _ihCurrentIdx = _ihCurrentIdx <= 0 ? _ihBlocks.length - 1 : _ihCurrentIdx - 1;
        }
        const el = _ihBlocks[_ihCurrentIdx];
        if (el) {
          el.scrollIntoView({ behavior: "smooth", block: "center" });
          el.classList.add("ih-pulse");
          setTimeout(() => el.classList.remove("ih-pulse"), 600);
        }
        _ihUpdateNavLabel();
      }

      function _ihShowPopover(el) {
        const pop = document.getElementById("ihPopover");
        const rendered = document.getElementById("docRendered");
        if (!pop || !rendered || !el) return;
        const c = ALL_COMMITS[DOC.idx];
        if (!c) return;
        const srcmap = el.getAttribute("data-srcmap") || "";
        const [startLine, endLine] = srcmap.split(":").map(Number);
        const lineCount = (endLine || startLine) - (startLine || 0);
        const bucket = bucketById(c.primary);
        pop.innerHTML = `<div class="ih-pop-row"><span class="ih-pop-label" style="background:${bucket.color}"></span><strong>${escapeHtml(bucket.name)}</strong></div><div class="ih-pop-row mt-1 text-slate-500">Lines ${startLine + 1}\u2013${endLine} (${lineCount} lines)</div><div class="ih-pop-row mt-0.5 text-slate-500">+${fmtInt(c.add)} \u2212${fmtInt(c.del)} | Impact ${fmtInt(c.impact)}</div>`;
        const pRect = rendered.getBoundingClientRect();
        const eRect = el.getBoundingClientRect();
        pop.style.top = (eRect.top - pRect.top + rendered.scrollTop - pop.offsetHeight - 6) + "px";
        pop.style.left = Math.min(eRect.left - pRect.left, pRect.width - 290) + "px";
        pop.classList.add("visible");
        pop.setAttribute("aria-hidden", "false");
      }

      function _ihHidePopover() {
        const pop = document.getElementById("ihPopover");
        if (pop) { pop.classList.remove("visible"); pop.setAttribute("aria-hidden", "true"); }
      }

      function _ihSetupPopover() {
        const rendered = document.getElementById("docRendered");
        if (!rendered) return;
        for (const el of rendered.querySelectorAll("[data-changed='true']")) {
          el.addEventListener("mouseenter", () => { if (DOC.inlineHighlights) _ihShowPopover(el); });
          el.addEventListener("mouseleave", _ihHidePopover);
          el.addEventListener("touchstart", (e) => {
            if (DOC.inlineHighlights) { e.preventDefault(); _ihShowPopover(el); setTimeout(_ihHidePopover, 2500); }
          }, { passive: false });
        }
      }

      // ---- Inline Highlights Unit Tests (bd-24q.16.3) ----
      // Run via console: window.__runInlineHighlightTests()
      window.__runInlineHighlightTests = function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || ""); };

        // --- 1. parsePatchChangedNewLines ---
        (function test_parsePatch_basic() {
          const patch = [
            "@@ -1,3 +1,4 @@",
            " line1",
            "+new line2",
            " line3",
            " line4"
          ].join("\n");
          const changed = parsePatchChangedNewLines(patch);
          A(changed instanceof Set, "parsePatch: returns Set");
          A(changed.has(2), "parsePatch: line 2 is changed (added)", { changed: [...changed] });
          A(!changed.has(1), "parsePatch: line 1 is not changed (context)");
          A(!changed.has(3), "parsePatch: line 3 is not changed");
          A(changed.size === 1, "parsePatch: exactly 1 changed line", { size: changed.size });
        })();

        (function test_parsePatch_deletion_only() {
          const patch = [
            "@@ -1,3 +1,2 @@",
            " line1",
            "-removed",
            " line3"
          ].join("\n");
          const changed = parsePatchChangedNewLines(patch);
          A(changed.size === 0, "parsePatch: deletion-only has no changed new lines", { changed: [...changed] });
        })();

        (function test_parsePatch_multiple_hunks() {
          const patch = [
            "@@ -1,3 +1,4 @@",
            " context",
            "+added1",
            " context",
            " context",
            "@@ -10,3 +11,4 @@",
            " context",
            "+added2",
            " context",
            " context"
          ].join("\n");
          const changed = parsePatchChangedNewLines(patch);
          A(changed.has(2), "parsePatch multi-hunk: line 2 changed", { changed: [...changed] });
          A(changed.has(12), "parsePatch multi-hunk: line 12 changed", { changed: [...changed] });
          A(changed.size === 2, "parsePatch multi-hunk: exactly 2 changed lines", { size: changed.size });
        })();

        (function test_parsePatch_replace() {
          // Replace line 2: delete old, add new
          const patch = [
            "@@ -1,3 +1,3 @@",
            " line1",
            "-old line2",
            "+new line2",
            " line3"
          ].join("\n");
          const changed = parsePatchChangedNewLines(patch);
          A(changed.has(2), "parsePatch replace: new line 2 is changed");
          A(changed.size === 1, "parsePatch replace: exactly 1 changed", { size: changed.size });
        })();

        (function test_parsePatch_empty() {
          A(parsePatchChangedNewLines("").size === 0, "parsePatch: empty string → empty set");
          A(parsePatchChangedNewLines(null).size === 0, "parsePatch: null → empty set");
          A(parsePatchChangedNewLines(undefined).size === 0, "parsePatch: undefined → empty set");
        })();

        (function test_parsePatch_consecutive_adds() {
          const patch = [
            "@@ -1,2 +1,5 @@",
            " line1",
            "+add1",
            "+add2",
            "+add3",
            " line2"
          ].join("\n");
          const changed = parsePatchChangedNewLines(patch);
          A(changed.has(2), "parsePatch consecutive: line 2 added");
          A(changed.has(3), "parsePatch consecutive: line 3 added");
          A(changed.has(4), "parsePatch consecutive: line 4 added");
          A(changed.size === 3, "parsePatch consecutive: 3 lines added", { size: changed.size });
        })();

        // --- 2. renderMarkdownWithSentinels + applyInlineHighlights ---
        (function test_sentinels_basic() {
          const div = document.createElement("div");
          const text = "# Heading\n\nParagraph one\n\nParagraph two\n";
          const changed = new Set([3]); // line 3 = "Paragraph one"
          renderMarkdownWithSentinels(text, div, "test-", changed);
          // Should have data-changed on the paragraph containing line 3
          const changedEls = div.querySelectorAll("[data-changed='true']");
          A(changedEls.length >= 1, "sentinels basic: at least 1 element marked changed", { count: changedEls.length });
          // Unchanged elements should NOT have data-changed
          const allMapped = div.querySelectorAll("[data-srcmap]");
          const unchangedCount = allMapped.length - changedEls.length;
          A(unchangedCount >= 1, "sentinels basic: at least 1 unchanged element", { unchanged: unchangedCount, total: allMapped.length });
        })();

        (function test_sentinels_no_changes() {
          const div = document.createElement("div");
          const text = "# Title\n\nBody text\n";
          renderMarkdownWithSentinels(text, div, "nochange-", new Set());
          const changedEls = div.querySelectorAll("[data-changed='true']");
          A(changedEls.length === 0, "sentinels no-changes: no elements marked changed");
        })();

        (function test_sentinels_null_changedLines() {
          const div = document.createElement("div");
          const text = "# Title\n\nBody\n";
          renderMarkdownWithSentinels(text, div, "null-", null);
          const changedEls = div.querySelectorAll("[data-changed='true']");
          A(changedEls.length === 0, "sentinels null-changedLines: no changed attrs when changedLines is null");
          // But data-srcmap should still be present
          const mapped = div.querySelectorAll("[data-srcmap]");
          A(mapped.length >= 1, "sentinels null: data-srcmap still present", { count: mapped.length });
        })();

        (function test_applyInlineHighlights() {
          const div = document.createElement("div");
          const text = "# H\n\nChanged paragraph\n\nUnchanged\n";
          const changed = new Set([3]);
          renderMarkdownWithSentinels(text, div, "apply-", changed);
          // Before apply, no ih-changed class
          const preBefore = div.querySelectorAll(".ih-changed").length;
          applyInlineHighlights(div);
          const postApply = div.querySelectorAll(".ih-changed").length;
          A(postApply >= 1, "applyInlineHighlights: adds ih-changed class", { before: preBefore, after: postApply });
          // Clear
          clearInlineHighlights(div);
          const postClear = div.querySelectorAll(".ih-changed").length;
          A(postClear === 0, "clearInlineHighlights: removes ih-changed class", { after: postClear });
        })();

        // --- 3. Duplicate lines: correct region mapping ---
        (function test_sentinels_duplicates() {
          // Two identical paragraphs - only the second should be marked
          const text = "Duplicate line\n\nDuplicate line\n\nDuplicate line\n";
          const changed = new Set([3]); // Only middle paragraph (line 3)
          const div = document.createElement("div");
          renderMarkdownWithSentinels(text, div, "dup-", changed);
          const paras = div.querySelectorAll("p");
          // With source maps, only the paragraph spanning line 3 should be changed
          const changedParas = div.querySelectorAll("p[data-changed='true']");
          // We expect exactly 1 paragraph marked (the one spanning line 3)
          A(changedParas.length >= 1, "duplicates: at least 1 changed para for line 3", { changedCount: changedParas.length, totalParas: paras.length });
          // The srcmap should include line 3
          if (changedParas.length > 0) {
            const srcmap = changedParas[0].getAttribute("data-srcmap");
            A(srcmap !== null, "duplicates: changed para has srcmap", { srcmap });
          }
        })();

        // --- 4. Code blocks: syntax highlighting intact ---
        (function test_sentinels_codeblock() {
          const text = "# Intro\n\n```javascript\nconst x = 1;\nconst y = 2;\n```\n\nAfter code\n";
          const changed = new Set([4]); // line inside code block: "const x = 1;"
          const div = document.createElement("div");
          renderMarkdownWithSentinels(text, div, "code-", changed);
          // Code block should exist
          const codeBlocks = div.querySelectorAll("pre code, pre.hljs code");
          A(codeBlocks.length >= 1, "codeblock: syntax-highlighted code block present", { count: codeBlocks.length });
          // Code block content should contain the original code
          const codeText = codeBlocks[0]?.textContent || "";
          A(codeText.includes("const x = 1"), "codeblock: code content preserved", { text: codeText.slice(0, 50) });
          // The pre block spanning the changed line should be marked
          const changedEls = div.querySelectorAll("[data-changed='true']");
          A(changedEls.length >= 1, "codeblock: code block region marked as changed", { count: changedEls.length });
        })();

        // --- 5. navigateChangedBlock ---
        (function test_navigateChangedBlock() {
          const div = document.createElement("div");
          div.style.overflow = "auto";
          div.style.height = "100px";
          div.style.position = "relative";
          // Create some blocks
          for (let i = 0; i < 5; i++) {
            const p = document.createElement("p");
            p.textContent = "Block " + i;
            p.style.height = "50px";
            if (i === 1 || i === 3) p.setAttribute("data-changed", "true");
            div.appendChild(p);
          }
          document.body.appendChild(div);
          const result = navigateChangedBlock(div, "next");
          A(result !== null, "navigateChangedBlock: returns target element");
          document.body.removeChild(div);
        })();

        (function test_navigateChangedBlock_empty() {
          const div = document.createElement("div");
          const result = navigateChangedBlock(div, "next");
          A(result === null, "navigateChangedBlock empty: returns null when no changed blocks");
        })();

        // --- 6. toggleHighlightDebug ---
        (function test_toggleDebug() {
          const div = document.createElement("div");
          const p = document.createElement("p");
          p.setAttribute("data-srcmap", "3:5");
          p.setAttribute("data-changed", "true");
          div.appendChild(p);
          toggleHighlightDebug(div, true);
          A(p.classList.contains("ih-debug"), "toggleDebug on: adds ih-debug class");
          A(p.title.includes("3:5"), "toggleDebug on: sets title with srcmap", { title: p.title });
          A(p.title.includes("[CHANGED]"), "toggleDebug on: title includes [CHANGED]");
          toggleHighlightDebug(div, false);
          A(!p.classList.contains("ih-debug"), "toggleDebug off: removes ih-debug class");
          A(!p.title, "toggleDebug off: clears title");
        })();

        // --- Diagnostics: on failure dump sentinel-marked DOM ---
        const failed = R.filter(r => !r.pass);
        if (failed.length > 0) {
          console.group("Inline Highlight Test Diagnostics");
          // Create a diagnostic dump
          const diagDiv = document.createElement("div");
          const diagText = "# Diag\n\nChanged line\n\nUnchanged line\n";
          renderMarkdownWithSentinels(diagText, diagDiv, "diag-", new Set([3]));
          const nodes = diagDiv.querySelectorAll("[data-srcmap]");
          const dump = Array.from(nodes).map(el => ({
            tag: el.tagName,
            srcmap: el.getAttribute("data-srcmap"),
            changed: el.getAttribute("data-changed"),
            text: el.textContent?.slice(0, 60)
          }));
          console.table(dump);
          console.groupEnd();
        }

        // Summary
        const p = R.filter(r => r.pass).length;
        const f = R.filter(r => !r.pass).length;
        const summary = "Inline Highlight Tests: " + p + " passed, " + f + " failed, " + R.length + " total";
        if (f > 0) { console.warn(summary); R.filter(r => !r.pass).forEach(r => console.error("  FAIL:", r.msg, r.ctx || "")); }
        else console.log("%c" + summary, "color: green; font-weight: bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Inline Highlights Unit Tests ----


      // ---- Inline Highlights E2E Tests (bd-24q.16.4) ----
      // Run via console: window.__runInlineHighlightE2ETests()
      window.__runInlineHighlightE2ETests = async function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || ""); };
        const wait = (ms) => new Promise(r => setTimeout(r, ms));
        const log = (m) => console.log("  [ih-e2e]", m);

        if (!DATASET.loaded || !ALL_COMMITS.length) {
          console.error("IH E2E: Need loaded dataset.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded" }] };
        }

        // Save state.
        const savedIdx = DOC.idx;
        const savedTab = DOC.tab;
        const savedIH = DOC.inlineHighlights;
        const savedIhIdx = _ihCurrentIdx;
        const savedIhBlocks = _ihBlocks.slice();

        // Find a commit with changes (idx > 0 with a non-empty patch).
        let testIdx = -1;
        for (let i = 1; i < ALL_COMMITS.length && i < 20; i++) {
          const patch = patchForIdx(i);
          if (patch && patch.length > 50) { testIdx = i; break; }
        }
        if (testIdx < 0) {
          console.error("IH E2E: No commit with changes found.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "No commit with patch data" }] };
        }
        log("Using test commit idx=" + testIdx);

        // --- E2E 1: Toggle inline highlights ON ---
        await (async function testToggleOn() {
          // Ensure off first.
          DOC.inlineHighlights = false;
          selectCommitIdx(testIdx);
          setDocTab("spec");
          await wait(500);
          // Toggle on.
          DOC.inlineHighlights = false; // ensure clean state
          toggleInlineHighlights();
          await wait(1500); // wait for async render with sentinels
          A(DOC.inlineHighlights === true, "e2e-1: DOC.inlineHighlights is true after toggle");
          const btn = document.getElementById("btnIHToggle");
          A(btn && btn.classList.contains("bg-slate-900"), "e2e-1: toggle button shows active state");
          const nav = document.getElementById("ihNav");
          A(nav && nav.style.display !== "none", "e2e-1: ihNav visible when highlights on");
          log("Toggle on: OK");
        })();

        // --- E2E 2: Highlighted blocks exist for commit with changes ---
        await (async function testHighlightBlocksExist() {
          const rendered = document.getElementById("docRendered");
          const changed = rendered?.querySelectorAll("[data-changed='true']") || [];
          const highlighted = rendered?.querySelectorAll(".ih-changed") || [];
          A(changed.length > 0, "e2e-2: data-changed elements exist", { count: changed.length });
          A(highlighted.length > 0, "e2e-2: ih-changed elements exist", { count: highlighted.length });
          A(_ihBlocks.length > 0, "e2e-2: _ihBlocks populated", { len: _ihBlocks.length });
          log("Highlighted blocks: " + highlighted.length + " elements, " + _ihBlocks.length + " nav blocks");
        })();

        // --- E2E 3: Nav label shows correct count ---
        await (async function testNavLabelCount() {
          const lbl = document.getElementById("ihNavLabel");
          if (!lbl) { log("Skipping nav label (no element)"); return; }
          // Before navigation, should show -/N or 0/0.
          A(lbl.textContent.includes("/" + _ihBlocks.length), "e2e-3: nav label includes total count", { got: lbl.textContent, expected: "/" + _ihBlocks.length });
          log("Nav label: " + lbl.textContent);
        })();

        // --- E2E 4: Next change navigation scrolls and updates label ---
        await (async function testNextChangeNav() {
          if (_ihBlocks.length < 1) { log("Skipping next nav (no blocks)"); return; }
          ihNavigate("next");
          await wait(400);
          A(_ihCurrentIdx === 0, "e2e-4: ihNavigate next sets _ihCurrentIdx to 0", { got: _ihCurrentIdx });
          const lbl = document.getElementById("ihNavLabel");
          A(lbl && lbl.textContent === "1/" + _ihBlocks.length, "e2e-4: nav label shows 1/N after first next", { got: lbl?.textContent });
          // Navigate again.
          if (_ihBlocks.length >= 2) {
            ihNavigate("next");
            await wait(400);
            A(_ihCurrentIdx === 1, "e2e-4: ihNavigate next advances to 1", { got: _ihCurrentIdx });
            A(lbl && lbl.textContent === "2/" + _ihBlocks.length, "e2e-4: nav label shows 2/N", { got: lbl?.textContent });
          }
          log("Next change nav: OK (idx=" + _ihCurrentIdx + ")");
        })();

        // --- E2E 5: Prev change navigation works ---
        await (async function testPrevChangeNav() {
          if (_ihBlocks.length < 2) { log("Skipping prev nav (< 2 blocks)"); return; }
          // Set to index 1, then navigate prev.
          _ihCurrentIdx = 1;
          ihNavigate("prev");
          await wait(400);
          A(_ihCurrentIdx === 0, "e2e-5: ihNavigate prev from 1 goes to 0", { got: _ihCurrentIdx });
          // Navigate prev at 0 wraps to last.
          ihNavigate("prev");
          await wait(400);
          A(_ihCurrentIdx === _ihBlocks.length - 1, "e2e-5: ihNavigate prev from 0 wraps to last", { got: _ihCurrentIdx, expected: _ihBlocks.length - 1 });
          log("Prev change nav: OK");
        })();

        // --- E2E 6: Next wraps around at end ---
        await (async function testNextWrapAround() {
          if (_ihBlocks.length < 1) { log("Skipping wrap (no blocks)"); return; }
          _ihCurrentIdx = _ihBlocks.length - 1;
          ihNavigate("next");
          await wait(300);
          A(_ihCurrentIdx === 0, "e2e-6: ihNavigate next wraps from last to 0", { got: _ihCurrentIdx });
          log("Wrap around: OK");
        })();

        // --- E2E 7: Switch commit → highlights refresh, no stale highlights ---
        await (async function testSwitchCommitRefreshes() {
          // Record blocks at current commit.
          const blockCountBefore = _ihBlocks.length;
          const firstBlockText = _ihBlocks.length > 0 ? _ihBlocks[0].textContent?.slice(0, 40) : "";
          // Switch to a different commit.
          let otherIdx = testIdx + 1;
          if (otherIdx >= ALL_COMMITS.length) otherIdx = testIdx - 1;
          if (otherIdx < 1) { log("Skipping switch (only one commit)"); return; }
          selectCommitIdx(otherIdx);
          await wait(1500); // wait for render
          // Re-apply highlights (the render pipeline should handle this).
          applyOrClearSpecHighlights();
          await wait(500);
          // Check that _ihBlocks was refreshed.
          const rendered = document.getElementById("docRendered");
          const currentChanged = rendered?.querySelectorAll("[data-changed='true']") || [];
          log("Commit switch: idx=" + otherIdx + ", changed=" + currentChanged.length + " (was " + blockCountBefore + " at idx=" + testIdx + ")");
          // If the other commit has changes, blocks should be refreshed.
          // If no changes, blocks should be empty.
          const otherPatch = patchForIdx(otherIdx);
          if (otherPatch && otherPatch.length > 50) {
            A(_ihBlocks.length >= 0, "e2e-7: _ihBlocks refreshed for new commit", { len: _ihBlocks.length });
          } else {
            A(_ihBlocks.length === 0 || currentChanged.length === 0, "e2e-7: no stale highlights on commit without changes");
          }
          A(true, "e2e-7: commit switch completed without error");
          // Switch back.
          selectCommitIdx(testIdx);
          await wait(1000);
          applyOrClearSpecHighlights();
          await wait(500);
        })();

        // --- E2E 8: Toggle OFF clears highlights ---
        await (async function testToggleOff() {
          // Ensure on first.
          if (!DOC.inlineHighlights) toggleInlineHighlights();
          await wait(500);
          A(DOC.inlineHighlights === true, "e2e-8: highlights on before toggle off");
          // Toggle off.
          toggleInlineHighlights();
          await wait(500);
          A(DOC.inlineHighlights === false, "e2e-8: DOC.inlineHighlights is false after toggle off");
          const rendered = document.getElementById("docRendered");
          const highlighted = rendered?.querySelectorAll(".ih-changed") || [];
          A(highlighted.length === 0, "e2e-8: no ih-changed elements after toggle off", { count: highlighted.length });
          A(_ihBlocks.length === 0, "e2e-8: _ihBlocks cleared after toggle off", { len: _ihBlocks.length });
          const nav = document.getElementById("ihNav");
          A(nav && nav.style.display === "none", "e2e-8: ihNav hidden after toggle off");
          log("Toggle off: OK");
        })();

        // --- E2E 9: Permalink round-trip preserves inline highlight state ---
        await (async function testPermalinkRoundTrip() {
          DOC.inlineHighlights = true;
          const encoded = encodeUrlState();
          A(encoded.includes("ih=1"), "e2e-9: URL includes ih=1 when highlights on", { encoded: encoded.slice(0, 100) });
          DOC.inlineHighlights = false;
          const encoded2 = encodeUrlState();
          A(!encoded2.includes("ih=1"), "e2e-9: URL omits ih when highlights off");
          // Decode round-trip.
          const decoded = decodeUrlState("?" + encoded);
          A(decoded.ih === true, "e2e-9: decoded ih = true", { got: decoded.ih });
          const decoded2 = decodeUrlState("?" + encoded2);
          A(decoded2.ih === false, "e2e-9: decoded ih = false when omitted", { got: decoded2.ih });
          log("Permalink round-trip: OK");
        })();

        // Restore state.
        DOC.inlineHighlights = savedIH;
        _ihCurrentIdx = savedIhIdx;
        _ihBlocks = savedIhBlocks;
        selectCommitIdx(savedIdx);
        if (savedTab) setDocTab(savedTab);
        applyOrClearSpecHighlights();
        await wait(300);

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Inline Highlight E2E Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Inline Highlights E2E Tests ----


      let _sbsRenderedKey = "";

      async function renderSbsPanes() {
        const key = `${DOC.compareFromIdx}:${DOC.compareToIdx}`;
        if (_sbsRenderedKey === key) return; // already rendered for these indices
        const paneA = document.getElementById("sbsPaneA");
        const paneB = document.getElementById("sbsPaneB");
        const loading = document.getElementById("abDiffLoading");
        if (!paneA || !paneB) return;
        if (loading) loading.classList.remove("hidden");
        try {
          const [textA, textB] = await Promise.all([
            docTextAt(DOC.compareFromIdx),
            docTextAt(DOC.compareToIdx),
          ]);
          renderMarkdownToPane(textA, paneA, "sbs-a-");
          renderMarkdownToPane(textB, paneB, "sbs-b-");
          _sbsRenderedKey = key;
          // Update pane labels with commit info (bd-24q.15.1).
          const cA = ALL_COMMITS[DOC.compareFromIdx];
          const cB = ALL_COMMITS[DOC.compareToIdx];
          const lblA = document.getElementById("sbsLabelA");
          const lblB = document.getElementById("sbsLabelB");
          if (lblA) lblA.textContent = `A: #${DOC.compareFromIdx} ${cA?.short || ""} \u2014 ${cA?.subject || ""}`;
          if (lblB) lblB.textContent = `B: #${DOC.compareToIdx} ${cB?.short || ""} \u2014 ${cB?.subject || ""}`;
          setupSbsDivider();
          setupSbsSyncScroll();
        } finally {
          if (loading) loading.classList.add("hidden");
        }
      }

      function setupSbsDivider() {
        const divider = document.getElementById("sbsDivider");
        const container = divider?.parentElement; // inner flex row containing panes + divider
        const paneA = document.getElementById("sbsPaneA");
        const paneB = document.getElementById("sbsPaneB");
        if (!divider || !container || !paneA || !paneB) return;
        if (divider._sbsSetup) return;
        divider._sbsSetup = true;
        let dragging = false;
        divider.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          dragging = true;
          divider.setPointerCapture(e.pointerId);
          document.body.style.cursor = "col-resize";
          document.body.style.userSelect = "none";
        });
        document.addEventListener("pointermove", (e) => {
          if (!dragging) return;
          const rect = container.getBoundingClientRect();
          const offset = e.clientX - rect.left;
          const pct = Math.max(15, Math.min(85, (offset / rect.width) * 100));
          paneA.style.flex = "none";
          paneA.style.width = `calc(${pct}% - 2.5px)`;
          paneB.style.flex = "none";
          paneB.style.width = `calc(${100 - pct}% - 2.5px)`;
        });
        const stopDrag = () => { if (!dragging) return; dragging = false; document.body.style.cursor = ""; document.body.style.userSelect = ""; };
        document.addEventListener("pointerup", stopDrag);
        document.addEventListener("pointercancel", stopDrag);
      }

      let _sbsScrollCleanup = null;
      let _sbsHeadingMap = null;

      /** Normalize heading text for fuzzy matching. */
      function normalizeHeadingText(text) {
        return String(text || "").toLowerCase().replace(/[^\p{L}\p{N}]+/gu, " ").trim();
      }

      /**
       * Build bidirectional heading match map between outlines A and B (bd-24q.15.2).
       * Pass 1: exact match (normalized text + level). Pass 2: fuzzy (longest common prefix >= 60%).
       */
      function buildHeadingMatchMap(outlineA, outlineB, prefixA, prefixB) {
        const matchAtoB = new Map();
        const matchBtoA = new Map();
        const normA = outlineA.map(h => ({ id: prefixA + h.id, norm: normalizeHeadingText(h.text), level: h.level }));
        const normB = outlineB.map(h => ({ id: prefixB + h.id, norm: normalizeHeadingText(h.text), level: h.level }));
        const usedB = new Set();
        for (const a of normA) {
          for (const b of normB) {
            if (!usedB.has(b.id) && a.norm === b.norm && a.level === b.level) {
              matchAtoB.set(a.id, b.id); matchBtoA.set(b.id, a.id); usedB.add(b.id); break;
            }
          }
        }
        for (const a of normA) {
          if (matchAtoB.has(a.id)) continue;
          let bestId = null, bestScore = 0;
          for (const b of normB) {
            if (usedB.has(b.id) || a.level !== b.level) continue;
            let cp = 0;
            const minLen = Math.min(a.norm.length, b.norm.length);
            while (cp < minLen && a.norm[cp] === b.norm[cp]) cp++;
            const score = minLen > 0 ? cp / Math.max(a.norm.length, b.norm.length) : 0;
            if (score > bestScore && score >= 0.6) { bestScore = score; bestId = b.id; }
          }
          if (bestId) { matchAtoB.set(a.id, bestId); matchBtoA.set(bestId, a.id); usedB.add(bestId); }
        }
        return { matchAtoB, matchBtoA };
      }

      /** Cache heading element offsets within a pane. */
      function cachePaneHeadingOffsets(pane, prefix) {
        const offsets = [];
        if (!pane) return offsets;
        for (const el of pane.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]")) {
          if (el.id.startsWith(prefix)) offsets.push({ id: el.id, top: el.offsetTop });
        }
        return offsets;
      }

      function setupSbsSyncScroll() {
        if (_sbsScrollCleanup) { _sbsScrollCleanup(); _sbsScrollCleanup = null; }
        _sbsHeadingMap = null;
        if (!DOC.sbsSyncScroll) return;
        const paneA = document.getElementById("sbsPaneA");
        const paneB = document.getElementById("sbsPaneB");
        if (!paneA || !paneB) return;

        // Build heading match map from rendered outlines.
        const outlineA = OUTLINE_CACHE.get(DOC.compareFromIdx) || [];
        const outlineB = OUTLINE_CACHE.get(DOC.compareToIdx) || [];
        const { matchAtoB, matchBtoA } = buildHeadingMatchMap(outlineA, outlineB, "sbs-a-", "sbs-b-");
        const offsetsA = cachePaneHeadingOffsets(paneA, "sbs-a-");
        const offsetsB = cachePaneHeadingOffsets(paneB, "sbs-b-");
        _sbsHeadingMap = { matchAtoB, matchBtoA, offsetsA, offsetsB };

        let syncing = false;
        let rafId = 0;

        /** Anchor-based sync with proportional fallback (bd-24q.15.2). */
        const syncFrom = (source, target, srcOffsets, srcToTgt, tgtOffsets) => {
          if (syncing) return;
          syncing = true;
          cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(() => {
            const viewTop = source.scrollTop + source.clientHeight * 0.15;
            let srcHeading = null, srcIdx = -1;
            for (let i = srcOffsets.length - 1; i >= 0; i--) {
              if (srcOffsets[i].top <= viewTop) { srcHeading = srcOffsets[i]; srcIdx = i; break; }
            }
            if (srcHeading && srcToTgt.has(srcHeading.id)) {
              const tgtId = srcToTgt.get(srcHeading.id);
              const tgtEntry = tgtOffsets.find(o => o.id === tgtId);
              if (tgtEntry) {
                const srcEnd = (srcIdx + 1 < srcOffsets.length) ? srcOffsets[srcIdx + 1].top : source.scrollHeight;
                const srcLen = srcEnd - srcHeading.top;
                const within = srcLen > 0 ? (viewTop - srcHeading.top) / srcLen : 0;
                const tgtIdx = tgtOffsets.indexOf(tgtEntry);
                const tgtEnd = (tgtIdx + 1 < tgtOffsets.length) ? tgtOffsets[tgtIdx + 1].top : target.scrollHeight;
                const tgtLen = tgtEnd - tgtEntry.top;
                target.scrollTop = tgtEntry.top + within * tgtLen - target.clientHeight * 0.15;
                syncing = false;
                return;
              }
            }
            // Proportional fallback.
            const maxS = source.scrollHeight - source.clientHeight;
            const maxT = target.scrollHeight - target.clientHeight;
            if (maxS > 0 && maxT > 0) target.scrollTop = (source.scrollTop / maxS) * maxT;
            syncing = false;
          });
        };

        const onScrollA = () => syncFrom(paneA, paneB, offsetsA, matchAtoB, offsetsB);
        const onScrollB = () => syncFrom(paneB, paneA, offsetsB, matchBtoA, offsetsA);
        paneA.addEventListener("scroll", onScrollA, { passive: true });
        paneB.addEventListener("scroll", onScrollB, { passive: true });
        _sbsScrollCleanup = () => {
          paneA.removeEventListener("scroll", onScrollA);
          paneB.removeEventListener("scroll", onScrollB);
          cancelAnimationFrame(rafId);
        };
      }

      /** Update button styling to reflect current abViewMode. */
      function updateSbsButtonStyles() {
        const sbsBtn = document.getElementById("btnSbsRendered");
        const active = DOC.abViewMode === "rendered";
        if (sbsBtn) {
          sbsBtn.classList.toggle("bg-slate-900", active);
          sbsBtn.classList.toggle("text-white", active);
          sbsBtn.classList.toggle("bg-white/70", !active);
          sbsBtn.classList.toggle("text-slate-900", !active);
        }
      }

      // --- Side-by-Side Mobile UX (bd-24q.15.3) ---
      const _sbsMobileScroll = { a: 0, b: 0 };
      function switchSbsMobilePane(pane) {
        const target = pane === "b" ? "b" : "a";
        const prev = DOC.sbsMobilePane;
        if (prev === target) return;
        const paneA = document.getElementById("sbsPaneA");
        const paneB = document.getElementById("sbsPaneB");
        if (!paneA || !paneB) return;
        if (prev === "a") _sbsMobileScroll.a = paneA.scrollTop;
        else _sbsMobileScroll.b = paneB.scrollTop;
        DOC.sbsMobilePane = target;
        paneA.classList.toggle("sbs-pane-visible", target === "a");
        paneB.classList.toggle("sbs-pane-visible", target === "b");
        document.getElementById("sbsTabA")?.classList.toggle("active", target === "a");
        document.getElementById("sbsTabB")?.classList.toggle("active", target === "b");
        if (target === "a") paneA.scrollTop = _sbsMobileScroll.a;
        else paneB.scrollTop = _sbsMobileScroll.b;
        showSbsJumpCta(prev, target);
      }
      function showSbsJumpCta(fromPane, toPane) {
        const cta = document.getElementById("sbsJumpCta");
        if (!cta || window.innerWidth > 639) return;
        const fromEl = document.getElementById(fromPane === "a" ? "sbsPaneA" : "sbsPaneB");
        if (!fromEl) { cta.classList.remove("visible"); return; }
        const fromPrefix = fromPane === "a" ? "sbs-a-" : "sbs-b-";
        const toPrefix = toPane === "a" ? "sbs-a-" : "sbs-b-";
        const headings = fromEl.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]");
        let topH = null;
        const thresh = fromEl.scrollTop + fromEl.clientHeight * 0.15;
        for (const h of headings) { if (h.offsetTop <= thresh) topH = h; else break; }
        if (!topH || !topH.id.startsWith(fromPrefix)) { cta.classList.remove("visible"); return; }
        const targetId = toPrefix + topH.id.slice(fromPrefix.length);
        const targetEl = document.getElementById(targetId);
        if (!targetEl) { cta.classList.remove("visible"); return; }
        const txt = topH.textContent.trim();
        cta.textContent = "\u2192 Jump to \u201C" + (txt.length > 30 ? txt.slice(0, 30) + "\u2026" : txt) + "\u201D";
        cta.classList.add("visible");
        cta.onclick = () => { targetEl.scrollIntoView({ behavior: "smooth", block: "start" }); cta.classList.remove("visible"); };
        clearTimeout(cta._hideTimer);
        cta._hideTimer = setTimeout(() => cta.classList.remove("visible"), 4000);
      }
      function applySbsMobilePaneState() {
        if (window.innerWidth > 639) return;
        const pA = document.getElementById("sbsPaneA");
        const pB = document.getElementById("sbsPaneB");
        if (!pA || !pB) return;
        const isA = DOC.sbsMobilePane === "a";
        pA.classList.toggle("sbs-pane-visible", isA);
        pB.classList.toggle("sbs-pane-visible", !isA);
      }

      // --- History Search Palette (bd-24q.9.2) ---
      let _spOpen = false;
      let _spActiveIdx = -1;
      let _spResults = [];
      let _spDebounce = 0;
      let _spAbort = null;

      function openSearchPalette() {
        const ov = document.getElementById("searchPaletteOverlay");
        const inp = document.getElementById("searchPaletteInput");
        if (!ov || _spOpen) return;
        _spOpen = true;
        _spActiveIdx = -1;
        _spResults = [];
        ov.classList.remove("hidden");
        inp.value = "";
        document.getElementById("searchPaletteResults").innerHTML =
          '<div class="search-palette-hint">Type to search across all commits</div>';
        requestAnimationFrame(() => inp.focus());
      }

      function closeSearchPalette() {
        const ov = document.getElementById("searchPaletteOverlay");
        if (!ov) return;
        _spOpen = false;
        ov.classList.add("hidden");
        if (_spAbort) { _spAbort.abort(); _spAbort = null; }
        clearTimeout(_spDebounce);
      }

	      async function searchPaletteQuery(q) {
	        if (_spAbort) { _spAbort.abort(); _spAbort = null; }
	        const container = document.getElementById("searchPaletteResults");
	        if (!container) return;
	        const trimmed = q.trim();
	        if (!trimmed) {
	          _spResults = [];
	          _spActiveIdx = -1;
	          container.innerHTML = '<div class="search-palette-hint">Type to search across all commits</div>';
	          return;
	        }
	        container.innerHTML = '<div class="search-palette-hint">Searching\u2026</div>';
	        _spAbort = new AbortController();
	        try {
	          // Fast main-thread fallback (137 commits): avoids initializing the heavy worker.
	          if (!WORKER_STATE.ready) {
	            ensureEnriched();
	            const ql = trimmed.toLowerCase();
	            const hits = [];
	            for (const c of ALL_COMMITS) {
	              const cg = (c.changeGroups || []).map((g) => `${g.summary || ""} ${(g.changed_headings || []).join(" ")} ${(g.evidence || []).join(" ")}`).join(" ");
	              const hay = `${c.idx} ${c.short} ${c.hash} ${c.author} ${c.subject} ${cg}`.toLowerCase();
	              if (!hay.includes(ql)) continue;
	              hits.push({ idx: c.idx, short: c.short, subject: c.subject });
	              if (hits.length >= 30) break;
	            }
	            _spResults = hits;
	            _spActiveIdx = _spResults.length ? 0 : -1;
	            if (!_spResults.length) {
	              container.innerHTML = '<div class="search-palette-hint">No results</div>';
	              return;
	            }
	            container.innerHTML = _spResults.map((h, i) =>
	              `<div class="search-palette-item${i === _spActiveIdx ? " active" : ""}" data-sp-idx="${i}">` +
	              `<span class="font-medium text-slate-900 truncate">#${h.idx} ${h.short}</span>` +
	              `<span class="text-xs text-slate-500 truncate">${h.subject}</span>` +
	              `</div>`
	            ).join("");
	            return;
	          }

	          const res = await workerRequest("query_search", { q: trimmed, limit: 30 }, { signal: _spAbort.signal });
	          _spResults = res.hits || [];
	          _spActiveIdx = _spResults.length ? 0 : -1;
	          if (!_spResults.length) {
	            container.innerHTML = '<div class="search-palette-hint">No results</div>';
            return;
          }
          container.innerHTML = _spResults.map((h, i) =>
            `<div class="search-palette-item${i === _spActiveIdx ? " active" : ""}" data-sp-idx="${i}">` +
            `<span class="font-medium text-slate-900 truncate">#${h.idx} ${h.short}</span>` +
            `<span class="text-xs text-slate-500 truncate">${h.subject}</span>` +
            `</div>`
          ).join("");
        } catch (err) {
          if (err.name === "AbortError") return;
          container.innerHTML = '<div class="search-palette-hint">Search error</div>';
        }
      }

      function selectSearchResult(i) {
        const hit = _spResults[i];
        if (!hit) return;
        closeSearchPalette();
        selectCommitIdx(hit.idx);
        setDocTab("diff");
      }

      function spNavigate(delta) {
        if (!_spResults.length) return;
        const container = document.getElementById("searchPaletteResults");
        if (!container) return;
        const prev = _spActiveIdx;
        _spActiveIdx = Math.max(0, Math.min(_spResults.length - 1, _spActiveIdx + delta));
        if (prev === _spActiveIdx) return;
        const items = container.querySelectorAll(".search-palette-item");
        if (items[prev]) items[prev].classList.remove("active");
        if (items[_spActiveIdx]) {
          items[_spActiveIdx].classList.add("active");
          items[_spActiveIdx].scrollIntoView({ block: "nearest" });
        }
      }

      const AB_METRICS_MAIN_CACHE = new Map();
      let AB_METRICS_ABORT = null;
      async function computeAndShowABMetrics(aIdx, bIdx) {
        const bar = document.getElementById("abMetricsBar");
        if (!bar) return;
        if (aIdx === bIdx) { bar.classList.add("hidden"); return; }
        bar.classList.remove("hidden");
        const chips = ["abmLines", "abmTokens", "abmLev", "abmHunks", "abmBytes"];
        for (const id of chips) { const el = document.getElementById(id); if (el) el.textContent = "..."; }
        if (AB_METRICS_ABORT) AB_METRICS_ABORT.abort();
        AB_METRICS_ABORT = new AbortController();
        const cacheKey = `${WORKER_STATE.datasetHash}:${aIdx}:${bIdx}`;
        const cached = AB_METRICS_MAIN_CACHE.get(cacheKey);
        if (cached) { renderABMetricChips(cached); return; }
        try {
          let metrics;
          if (WORKER_STATE.ready) {
            metrics = await workerRequest("ab_metrics", { aIdx, bIdx }, { timeoutMs: 120000, signal: AB_METRICS_ABORT.signal });
          } else {
            const patch = await generateABDiff(aIdx, bIdx);
            metrics = quickMetricsFromPatch(patch);
            metrics.lev = null;
          }
          AB_METRICS_MAIN_CACHE.set(cacheKey, metrics);
          renderABMetricChips(metrics);
        } catch (e) {
          if (e?.name !== "AbortError") {
            console.error("A/B metrics failed:", e);
            for (const id of chips) { const el = document.getElementById(id); if (el) el.textContent = "ERR"; }
          }
        }
      }
      function renderABMetricChips(m) {
        const sign = (v) => v > 0 ? "+" + fmtInt(v) : v < 0 ? fmtInt(v) : "0";
        const el = (id) => document.getElementById(id);
        if (el("abmLines")) el("abmLines").textContent = `\u0394lines ${sign(m.deltaLines || 0)} (+${fmtInt(m.addLines || 0)} -${fmtInt(m.delLines || 0)})`;
        if (el("abmTokens")) el("abmTokens").textContent = `\u0394tokens ${sign(m.tokensDelta || 0)} (${fmtInt(m.tokensChanged || 0)} touched)`;
        if (el("abmLev")) el("abmLev").textContent = `Lev ${m.lev != null ? fmtInt(m.lev) : "?"}`;
        if (el("abmHunks")) el("abmHunks").textContent = `Hunks ${fmtInt(m.hunks || 0)}`;
        if (el("abmBytes")) el("abmBytes").textContent = `\u0394bytes ${sign(m.bytesDelta || 0)} (${fmtInt(m.bytesChanged || 0)} touched)`;
      }

      function applyPatchLines(prevLines, patch) {
        const hunks = parseUnifiedHunks(patch);
        let out = prevLines.slice();
        let offset = 0;
        for (const h of hunks) {
          let at = (h.oldStart - 1) + offset;
          at = clamp(at, 0, out.length);
          let cursor = at;
          const next = [];
          for (const hl of h.lines) {
            if (!hl) continue;
            const p = hl[0];
            const content = hl.slice(1);
            if (p === " ") {
              next.push(content);
              cursor += 1;
            } else if (p === "-") {
              cursor += 1;
            } else if (p === "+") {
              next.push(content);
            } else {
              // "\ No newline at end of file" or other metadata
            }
          }
          out.splice(at, cursor - at, ...next);
          offset += next.length - (cursor - at);
        }
        return out;
      }

      async function docTextAtLocal(idx) {
        if (!DATASET.loaded) return "";
        if (idx <= 0) return String(DATASET.baseDoc || "");

        const cached = DOC_CACHE.get(idx);
        if (cached?.text) return cached.text;

        // Fast path: sequential scrub.
        if (DOC_CURSOR.lines && idx === DOC_CURSOR.idx + 1) {
          const nextLines = applyPatchLines(DOC_CURSOR.lines, patchForIdx(idx));
          DOC_CURSOR.idx = idx;
          DOC_CURSOR.lines = nextLines;
          const text = nextLines.join("\n");
          DOC_CACHE.set(idx, { text });
          return text;
        }

        // Rebuild from nearest cached anchor.
        let anchor = 0;
        for (let j = idx - 1; j > 0; j--) {
          if (DOC_CACHE.has(j)) {
            anchor = j;
            break;
          }
        }

        let lines = String(DATASET.baseDoc || "").split("\n");
        if (anchor > 0) lines = String(DOC_CACHE.get(anchor)?.text || "").split("\n");

        for (let k = Math.max(1, anchor + 1); k <= idx; k++) {
          lines = applyPatchLines(lines, patchForIdx(k));
          // Keep sparse anchors to accelerate non-linear scrubs.
          if (k === idx || k % 10 === 0) DOC_CACHE.set(k, { text: lines.join("\n") });
        }

        DOC_CURSOR.idx = idx;
        DOC_CURSOR.lines = lines;
        return DOC_CACHE.get(idx)?.text || lines.join("\n");
      }

      async function docTextAt(idx) {
        if (WORKER_STATE.ready) {
          try {
            const res = await workerRequest("snapshot_at", { idx }, { timeoutMs: 45000 });
            if (typeof res?.text === "string") return res.text;
          } catch (e) {
            console.error("Worker snapshot reconstruction failed; falling back to local path:", e);
          }
        }
        return docTextAtLocal(idx);
      }

      // -----------------------------
      // Heading Outline Extraction (bd-24q.8.1)
      // -----------------------------

      /**
       * Generate a URL-safe slug from heading text.
       * Deterministic: same input always yields same output.
       */
      function slugifyHeading(text) {
        return String(text || "")
          .toLowerCase()
          .replace(/[^\p{L}\p{N}]+/gu, "-")
          .replace(/^-+|-+$/g, "")
          || "heading";
      }

      /**
       * Extract an outline from markdown text using markdown-it's token stream.
       * Returns: [{ text: string, level: number, id: string }]
       *
       * Anchor IDs are deterministic and disambiguated: if two headings
       * produce the same slug, a numeric suffix (-1, -2, ...) is appended.
       */
      function extractOutline(markdownText) {
        if (!window._mdSingleton) {
          window._mdSingleton = markdownit({
            html: false,
            linkify: true,
            typographer: true,
            highlight: (str, lang) => {
              try {
                if (lang && hljs.getLanguage(lang)) {
                  return `<pre class="hljs"><code>${hljs.highlight(str, { language: lang }).value}</code></pre>`;
                }
                return `<pre class="hljs"><code>${hljs.highlightAuto(str).value}</code></pre>`;
              } catch {
                return `<pre class="hljs"><code>${escapeHtml(str)}</code></pre>`;
              }
            },
          });
        }
        const tokens = window._mdSingleton.parse(markdownText || "", {});
        const outline = [];
        const slugCounts = new Map(); // slug -> count for disambiguation

        for (let i = 0; i < tokens.length; i++) {
          const tok = tokens[i];
          if (tok.type !== "heading_open") continue;

          // Level from tag: "h1" -> 1, "h2" -> 2, etc.
          const level = Number(tok.tag?.slice(1)) || 1;

          // Source line (1-based) from markdown-it token map.
          const line = tok.map ? tok.map[0] + 1 : null;

          // Next token should be the inline content.
          const inlineTok = tokens[i + 1];
          let text = "";
          if (inlineTok?.type === "inline") {
            // Collect all text children (handles bold, code, etc. inside headings).
            text = (inlineTok.children || [])
              .filter((c) => c.type === "text" || c.type === "code_inline")
              .map((c) => c.content)
              .join("");
            if (!text) text = inlineTok.content || "";
          }

          // Generate stable, disambiguated slug.
          const baseSlug = slugifyHeading(text);
          const count = slugCounts.get(baseSlug) || 0;
          slugCounts.set(baseSlug, count + 1);
          const id = count === 0 ? baseSlug : `${baseSlug}-${count}`;

          outline.push({ text: text.trim(), level, id, line });
        }
        return outline;
      }

      /**
       * Get the heading outline for a given commit index.
       * Caches results; uses docTextAt to reconstruct the spec.
       *
       * Returns: Promise<[{ text: string, level: number, id: string }]>
       */
      async function getOutline(commitIdx) {
        const idx = Number(commitIdx || 0);
        if (OUTLINE_CACHE.has(idx)) return OUTLINE_CACHE.get(idx);

        const text = await docTextAt(idx);
        const outline = extractOutline(text);
        OUTLINE_CACHE.set(idx, outline);
        return outline;
      }

      /**
       * Resolve offsetTop values for outline entries by querying the DOM.
       * Call this AFTER rendering markdown to get accurate positions.
       * Returns: [{ text, level, id, offsetTop }]
       */
      function resolveOutlineOffsets(outline, containerEl) {
        if (!containerEl || !outline?.length) return outline || [];
        return outline.map((entry) => {
          const el = containerEl.querySelector(`#${CSS.escape(entry.id)}`);
          return {
            ...entry,
            offsetTop: el ? el.offsetTop : null,
          };
        });
      }

      // -----------------------------
      // Per-Heading Change Metrics (bd-24q.8.2)
      // -----------------------------

      const HEADING_METRICS_CACHE = new Map(); // idx -> Map<headingId, metrics>

      /**
       * Build a lookup: 1-based line number -> heading ID.
       * Lines before the first heading map to "__preamble__".
       */
      function buildLineToHeadingMap(totalLines, outline) {
        const map = new Array(totalLines + 1);
        map[0] = "__preamble__";

        // Determine the heading boundary for each line by walking
        // through the outline's sorted line numbers.
        let ptr = 0;
        let currentId = "__preamble__";
        for (let ln = 1; ln <= totalLines; ln++) {
          while (ptr < outline.length && outline[ptr].line != null && outline[ptr].line <= ln) {
            currentId = outline[ptr].id;
            ptr++;
          }
          map[ln] = currentId;
        }
        return map;
      }

      /**
       * Attribute each added/removed line in a unified diff to the
       * nearest preceding heading in the new (current) snapshot.
       *
       * Returns: Map<headingId, { addLines, delLines, tokensAdded, tokensDeleted }>
       */
      function attributeHunksToHeadings(patch, lineToHeading) {
        const hunks = parseUnifiedHunks(patch);
        const metrics = new Map();

        const ensure = (id) => {
          if (!metrics.has(id)) {
            metrics.set(id, { addLines: 0, delLines: 0, tokensAdded: 0, tokensDeleted: 0 });
          }
          return metrics.get(id);
        };

        for (const hunk of hunks) {
          let newLineNum = hunk.newStart;
          for (const hl of hunk.lines) {
            if (!hl) continue;
            const p = hl[0];
            const content = hl.slice(1);
            const headingId = lineToHeading[newLineNum] || "__preamble__";

            if (p === "+") {
              const m = ensure(headingId);
              m.addLines++;
              m.tokensAdded += countRoughTokens(content);
              newLineNum++;
            } else if (p === "-") {
              const m = ensure(headingId);
              m.delLines++;
              m.tokensDeleted += countRoughTokens(content);
              // Deleted lines don't advance the new-file cursor.
            } else if (p === " ") {
              newLineNum++;
            }
          }
        }
        return metrics;
      }

      /**
       * Get per-heading change metrics for a commit.
       *
       * Returns: Promise<Map<headingId, { addLines, delLines, tokensAdded, tokensDeleted }>>
       */
      async function getHeadingMetrics(commitIdx) {
        const idx = Number(commitIdx || 0);
        if (HEADING_METRICS_CACHE.has(idx)) return HEADING_METRICS_CACHE.get(idx);

        const outline = await getOutline(idx);
        const text = await docTextAt(idx);
        const patch = patchForIdx(idx);

        if (!patch || !outline.length) {
          const empty = new Map();
          HEADING_METRICS_CACHE.set(idx, empty);
          return empty;
        }

        const totalLines = text.split("\n").length;
        const lineToHeading = buildLineToHeadingMap(totalLines, outline);
        const metrics = attributeHunksToHeadings(patch, lineToHeading);
        HEADING_METRICS_CACHE.set(idx, metrics);
        return metrics;
      }

      /**
       * Render the mini-map outline panel for the current commit.
       *
       * Features (bd-24q.2.2):
       * - Heading hierarchy with change-heat indicators
       * - Follow-along: tracks visible heading while scrolling docRendered
       * - Search/filter headings by text
       * - Keyboard navigation (arrow keys, Enter to jump)
       */
      let _miniMapOutline = [];
      let _miniMapScrollCleanup = null;
      let _miniMapLastIdx = -1;
      let _miniMapLastFilter = "";

      async function updateMiniMap() {
        const mm = document.getElementById("miniMap");
        if (!mm || mm.classList.contains("hidden")) return;

        const itemsContainer = document.getElementById("miniMapItems") || mm;
        const searchInput = document.getElementById("miniMapSearch");
        const filterText = (searchInput?.value || "").toLowerCase().trim();

        if (_miniMapLastIdx === DOC.idx && _miniMapLastFilter === filterText) return;

        const outline = await getOutline(DOC.idx);
        _miniMapOutline = outline;

        if (!outline.length) {
          itemsContainer.innerHTML = '<div class="text-xs text-slate-400 italic p-2">No headings</div>';
          return;
        }

        // In A/B compare mode, compute metrics between A and B; otherwise parent→current.
        let headingMetrics = null;
        if (DOC.compareMode && DOC.compareToIdx > 0) {
          try { headingMetrics = await getHeadingMetrics(DOC.compareToIdx); } catch { /* best-effort */ }
        } else if (DOC.idx > 0) {
          try { headingMetrics = await getHeadingMetrics(DOC.idx); } catch { /* best-effort */ }
        }

        // Bucket accent: use current commit's primary bucket color.
        const commitForAccent = DOC.compareMode
          ? ALL_COMMITS[DOC.compareToIdx]
          : ALL_COMMITS[DOC.idx];
        const accentColor = commitForAccent ? bucketById(commitForAccent.primary)?.color : null;

        const docEl = document.getElementById("docRendered");

        const filtered = filterText
          ? outline.filter((e) => e.text.toLowerCase().includes(filterText))
          : outline;

        const items = filtered.map((entry, i) => {
          const indent = Math.max(0, entry.level - 1) * 12;
          const hasChange = headingMetrics?.has(entry.id);
          const m = hasChange ? headingMetrics.get(entry.id) : null;
          const changeTotal = m ? m.addLines + m.delLines : 0;
          const tokenTotal = m ? m.tokensAdded + m.tokensDeleted : 0;
          // Intensity: use token count for size, line count for color.
          const dotSize = tokenTotal > 50 ? 10 : tokenTotal > 10 ? 8 : 6;
          const dotColor = changeTotal > 20 ? '#dc2626' : changeTotal > 5 ? '#d97706' : '#059669';
          const borderStyle = accentColor && hasChange && changeTotal > 0
            ? `; border: 1.5px solid ${accentColor}` : "";
          const marker = hasChange && changeTotal > 0
            ? `<span class="inline-block rounded-full mr-1.5 shrink-0" style="width: ${dotSize}px; height: ${dotSize}px; background: ${dotColor}${borderStyle}" title="+${m.addLines} -${m.delLines} lines, ~${tokenTotal} tokens"></span>`
            : "";
          return `<a href="#${escapeHtml(entry.id)}" role="treeitem" tabindex="${i === 0 ? '0' : '-1'}" class="minimap-item flex items-center py-0.5 text-[11px] leading-tight text-slate-700 hover:text-slate-900 hover:bg-slate-100/60 rounded px-1 cursor-pointer no-underline transition-colors" style="padding-left: ${indent}px" data-heading-id="${escapeHtml(entry.id)}" title="${escapeHtml(entry.text)}">${marker}<span class="truncate">${escapeHtml(entry.text)}</span></a>`;
        });
        itemsContainer.innerHTML = items.join("");

        // Click handlers: smooth-scroll to heading in doc.
        itemsContainer.querySelectorAll(".minimap-item").forEach((a) => {
          a.addEventListener("click", (e) => {
            e.preventDefault();
            const hid = a.dataset.headingId;
            if (!hid || !docEl) return;
            const target = docEl.querySelector(`#${CSS.escape(hid)}`);
            if (target) target.scrollIntoView({ behavior: "smooth", block: "start" });
            miniMapSetActive(a);
          });
        });

        // Keyboard navigation on items container.
        itemsContainer.onkeydown = (e) => {
          const links = [...itemsContainer.querySelectorAll(".minimap-item")];
          if (!links.length) return;
          const cur = itemsContainer.querySelector(".minimap-item[tabindex='0']");
          const idx = cur ? links.indexOf(cur) : 0;
          if (e.key === "ArrowDown" || e.key === "ArrowUp") {
            e.preventDefault();
            const next = e.key === "ArrowDown" ? Math.min(idx + 1, links.length - 1) : Math.max(idx - 1, 0);
            if (cur) cur.tabIndex = -1;
            links[next].tabIndex = 0;
            links[next].focus();
          } else if (e.key === "Enter") {
            e.preventDefault();
            if (cur) cur.click();
          } else if (e.key === "Home") {
            e.preventDefault();
            if (cur) cur.tabIndex = -1;
            links[0].tabIndex = 0;
            links[0].focus();
          } else if (e.key === "End") {
            e.preventDefault();
            if (cur) cur.tabIndex = -1;
            links[links.length - 1].tabIndex = 0;
            links[links.length - 1].focus();
          }
        };

        // Follow-along: highlight current heading while scrolling docRendered.
        setupMiniMapFollowAlong(docEl, itemsContainer, outline);

        _miniMapLastIdx = DOC.idx;
        _miniMapLastFilter = filterText;
      }

      /** Highlight a mini-map item as active and scroll it into view. */
      function miniMapSetActive(el) {
        const container = el?.closest("#miniMapItems") || el?.closest("#miniMap");
        if (!container) return;
        container.querySelectorAll(".minimap-item.minimap-active").forEach((a) => {
          a.classList.remove("minimap-active", "bg-slate-200/80", "font-semibold", "text-slate-900");
        });
        if (el) {
          el.classList.add("minimap-active", "bg-slate-200/80", "font-semibold", "text-slate-900");
          el.scrollIntoView({ block: "nearest", behavior: "smooth" });
        }
      }

      /** Attach a scroll listener on docRendered to track the current heading. */
      function setupMiniMapFollowAlong(docEl, itemsContainer, outline) {
        if (_miniMapScrollCleanup) { _miniMapScrollCleanup(); _miniMapScrollCleanup = null; }
        if (!docEl || !outline.length) return;

        // Cache heading offsets to avoid O(N) DOM queries per scroll.
        const headingOffsets = [];
        for (const entry of outline) {
          const el = docEl.querySelector(`#${CSS.escape(entry.id)}`);
          headingOffsets.push({ id: entry.id, top: el ? el.offsetTop : 0 });
        }

        let rafId = 0;
        const onScroll = () => {
          cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(() => {
            const viewportMid = docEl.scrollTop + docEl.clientHeight * 0.25;
            let activeId = headingOffsets[0]?.id;
            for (const h of headingOffsets) {
              if (h.top <= viewportMid) activeId = h.id;
            }
            const activeLink = activeId ? itemsContainer.querySelector(`[data-heading-id="${CSS.escape(activeId)}"]`) : null;
            if (activeLink && !activeLink.classList.contains("minimap-active")) miniMapSetActive(activeLink);
          });
        };
        docEl.addEventListener("scroll", onScroll, { passive: true });
        onScroll();
        _miniMapScrollCleanup = () => { docEl.removeEventListener("scroll", onScroll); cancelAnimationFrame(rafId); };
      }

      // ---- Section Summary Panel (bd-24q.8.3) ----
      const SECTION_SORT = { key: "impact", asc: false };
      function sectionSparkline(headingId, currentIdx) {
        const range = 5, startIdx = Math.max(1, currentIdx - range + 1), vals = [];
        for (let i = startIdx; i <= currentIdx; i++) {
          const cached = HEADING_METRICS_CACHE.get(i);
          if (cached && cached.has(headingId)) { const m = cached.get(headingId); vals.push(m.addLines + m.delLines); }
          else vals.push(0);
        }
        const maxVal = Math.max(1, ...vals);
        return vals.map(v => {
          const h = Math.max(1, Math.round((v / maxVal) * 14));
          const color = v === 0 ? "#cbd5e1" : v > 20 ? "#dc2626" : v > 5 ? "#d97706" : "#059669";
          return `<span class="sparkline-bar" style="width:3px;height:${h}px;background:${color};"><\/span>`;
        }).join("");
      }
      async function updateSectionSummary() {
        const view = document.getElementById("docSectionsView");
        if (!view || view.classList.contains("hidden")) return;
        
        const filter = (document.getElementById("sectionFilter")?.value || "").trim().toLowerCase();
        if (_lastSectionIdx === DOC.idx && _lastSectionFilter === filter) return;
        _lastSectionIdx = DOC.idx;
        _lastSectionFilter = filter;

        const tbody = document.getElementById("sectionTableBody");
        const empty = document.getElementById("sectionEmpty");
        const wrap = document.getElementById("sectionTableWrap");
        if (!tbody) return;
        const outline = await getOutline(DOC.idx);
        const metrics = DOC.idx > 0 ? await getHeadingMetrics(DOC.idx) : new Map();
        const rows = [];
        for (const entry of outline) {
          if (filter && !entry.text.toLowerCase().includes(filter)) continue;
          const m = metrics.get(entry.id) || { addLines: 0, delLines: 0, tokensAdded: 0, tokensDeleted: 0 };
          rows.push({ id: entry.id, text: entry.text, level: entry.level, add: m.addLines, del: m.delLines, tokens: m.tokensAdded + m.tokensDeleted, impact: m.addLines + m.delLines });
        }
        const sortKey = SECTION_SORT.key, dir = SECTION_SORT.asc ? 1 : -1;
        rows.sort((a, b) => sortKey === "name" ? dir * a.text.localeCompare(b.text) : dir * ((a[sortKey] || 0) - (b[sortKey] || 0)));
        if (!rows.length) { tbody.innerHTML = ""; if (wrap) wrap.classList.add("hidden"); if (empty) empty.classList.remove("hidden"); return; }
        if (wrap) wrap.classList.remove("hidden");
        if (empty) empty.classList.add("hidden");
        const maxImpact = Math.max(1, ...rows.map(r => r.impact));
        tbody.innerHTML = rows.map(r => {
          const indent = Math.max(0, r.level - 1) * 10;
          const barW = Math.round((r.impact / maxImpact) * 100);
          const spark = sectionSparkline(r.id, DOC.idx);
          const ic = r.impact === 0 ? "text-slate-400" : r.impact > 20 ? "text-red-600" : r.impact > 5 ? "text-amber-600" : "text-emerald-600";
          return `<tr class="border-b border-slate-100 hover:bg-slate-50/60 cursor-pointer transition-colors" data-heading-id="${escapeHtml(r.id)}"><td class="px-3 py-2 text-left"><div class="flex items-center gap-1.5" style="padding-left:${indent}px"><span class="truncate max-w-[240px]" title="${escapeHtml(r.text)}">${escapeHtml(r.text)}<\/span><span class="flex items-end gap-px ml-1">${spark}<\/span><\/div><\/td><td class="px-3 py-2 text-right mono text-emerald-600">${r.add > 0 ? "+" + r.add : ""}<\/td><td class="px-3 py-2 text-right mono text-red-500">${r.del > 0 ? "-" + r.del : ""}<\/td><td class="px-3 py-2 text-right mono text-slate-600">${r.tokens || ""}<\/td><td class="px-3 py-2 text-right"><div class="flex items-center justify-end gap-1.5"><span class="mono ${ic} font-semibold">${r.impact || ""}<\/span><span class="inline-block h-1.5 rounded-full bg-slate-200" style="width:40px"><span class="inline-block h-1.5 rounded-full" style="width:${barW}%;background:${r.impact > 20 ? '#dc2626' : r.impact > 5 ? '#d97706' : '#059669'}"><\/span><\/span><\/div><\/td><\/tr>`;
        }).join("");
        tbody.querySelectorAll("tr[data-heading-id]").forEach(tr => {
          tr.addEventListener("click", () => {
            const hid = tr.dataset.headingId;
            if (!hid) return;
            if (DOC.tab !== "spec") setDocTab("spec");
            setTimeout(() => {
              const docEl = document.getElementById("docRendered");
              if (!docEl) return;
              const target = docEl.querySelector(`#${CSS.escape(hid)}`);
              if (target) { target.scrollIntoView({ behavior: "smooth", block: "start" }); target.classList.remove("section-highlight"); void target.offsetWidth; target.classList.add("section-highlight"); }
            }, 350);
          });
        });
      }
      document.addEventListener("click", e => {
        const th = e.target.closest("#sectionTable th[data-sort]");
        if (!th) return;
        const key = th.dataset.sort;
        if (SECTION_SORT.key === key) SECTION_SORT.asc = !SECTION_SORT.asc;
        else { SECTION_SORT.key = key; SECTION_SORT.asc = key === "name"; }
        th.closest("thead")?.querySelectorAll("th[data-sort]").forEach(h => {
          const arrow = SECTION_SORT.key === h.dataset.sort ? (SECTION_SORT.asc ? " \u25B2" : " \u25BC") : "";
          h.textContent = h.textContent.replace(/\s*[\u25B2\u25BC]$/, "") + arrow;
        });
        void updateSectionSummary();
      });
      document.addEventListener("input", e => {
        if (e.target?.id === "sectionFilter") { clearTimeout(e.target._debounce); e.target._debounce = setTimeout(() => void updateSectionSummary(), 150); }
      });
      // Mobile section sheet open/close.
      function openSectionSheet() {
        const sheet = document.getElementById("sectionSheet");
        const overlay = document.getElementById("sectionSheetOverlay");
        if (sheet) { sheet.classList.remove("hidden"); requestAnimationFrame(() => sheet.classList.add("open")); }
        if (overlay) overlay.classList.remove("hidden");
        void updateSectionSheetList();
      }
      function closeSectionSheet() {
        const sheet = document.getElementById("sectionSheet");
        const overlay = document.getElementById("sectionSheetOverlay");
        if (sheet) { sheet.classList.remove("open"); setTimeout(() => sheet.classList.add("hidden"), 220); }
        if (overlay) overlay.classList.add("hidden");
      }
      async function updateSectionSheetList() {
        const list = document.getElementById("sectionSheetList");
        if (!list) return;
        const outline = await getOutline(DOC.idx);
        const metrics = DOC.idx > 0 ? await getHeadingMetrics(DOC.idx) : new Map();
        const filter = (document.getElementById("sectionFilterMobile")?.value || "").trim().toLowerCase();
        const items = [];
        for (const entry of outline) {
          if (filter && !entry.text.toLowerCase().includes(filter)) continue;
          const m = metrics.get(entry.id) || { addLines: 0, delLines: 0, tokensAdded: 0, tokensDeleted: 0 };
          const total = m.addLines + m.delLines;
          const color = total === 0 ? "bg-slate-100 text-slate-400" : total > 20 ? "bg-red-50 text-red-700" : total > 5 ? "bg-amber-50 text-amber-700" : "bg-emerald-50 text-emerald-700";
          const indent = Math.max(0, entry.level - 1) * 12;
          items.push(`<button class="w-full text-left rounded-2xl px-4 py-3 ${color} hover:brightness-95 transition-colors" data-heading-id="${escapeHtml(entry.id)}" style="padding-left:${indent + 16}px"><div class="text-sm font-semibold">${escapeHtml(entry.text)}<\/div><div class="mt-0.5 text-[11px]">+${m.addLines} -${m.delLines} lines \u00b7 ${m.tokensAdded + m.tokensDeleted} tokens<\/div><\/button>`);
        }
        list.innerHTML = items.length ? items.join("") : '<div class="text-xs text-slate-400 italic p-3">No section changes<\/div>';
        list.querySelectorAll("button[data-heading-id]").forEach(btn => {
          btn.addEventListener("click", () => {
            closeSectionSheet();
            setDocTab("spec");
            setTimeout(() => {
              const docEl = document.getElementById("docRendered");
              if (!docEl) return;
              const target = docEl.querySelector(`#${CSS.escape(btn.dataset.headingId)}`);
              if (target) { target.scrollIntoView({ behavior: "smooth", block: "start" }); target.classList.remove("section-highlight"); void target.offsetWidth; target.classList.add("section-highlight"); }
            }, 300);
          });
        });
      }
      document.getElementById("btnOpenSectionSheet")?.addEventListener("click", openSectionSheet);
      document.getElementById("btnCloseSectionSheet")?.addEventListener("click", closeSectionSheet);
      document.getElementById("sectionSheetOverlay")?.addEventListener("click", closeSectionSheet);
      document.getElementById("sectionFilterMobile")?.addEventListener("input", e => {
        clearTimeout(e.target._debounce);
        e.target._debounce = setTimeout(() => void updateSectionSheetList(), 150);
      });

      // ---- End Section Summary Panel ----

      // ---- Section Summary Unit Tests (bd-24q.8.4) ----
      // Run via console: window.__runSectionTests()
      window.__runSectionTests = function () {
        const results = [];
        const assert = (cond, msg, ctx) => {
          if (!cond) { results.push({ pass: false, msg, ctx }); console.error("FAIL:", msg, ctx || ""); }
          else results.push({ pass: true, msg });
        };

        // --- extractOutline tests ---
        (function testOutline_basic() {
          const md = "# Title\n\nSome text\n\n## Section A\n\nBody\n\n## Section B\n\nMore body\n\n### Subsection B.1\n";
          const o = extractOutline(md);
          assert(o.length === 4, "outline: 4 headings", { got: o.length });
          assert(o[0].text === "Title" && o[0].level === 1, "outline: h1 Title");
          assert(o[1].text === "Section A" && o[1].level === 2, "outline: h2 Section A");
          assert(o[2].text === "Section B" && o[2].level === 2, "outline: h2 Section B");
          assert(o[3].text === "Subsection B.1" && o[3].level === 3, "outline: h3 Subsection B.1");
        })();

        (function testOutline_duplicateSlugs() {
          const md = "## Intro\n\nText\n\n## Intro\n\nText\n\n## Intro\n";
          const o = extractOutline(md);
          assert(o.length === 3, "duplicate: 3 headings");
          assert(o[0].id === "intro", "duplicate: first is 'intro'", { got: o[0].id });
          assert(o[1].id === "intro-1", "duplicate: second is 'intro-1'", { got: o[1].id });
          assert(o[2].id === "intro-2", "duplicate: third is 'intro-2'", { got: o[2].id });
        })();

        (function testOutline_weirdPunctuation() {
          const md = "# Hello, World! (v2.0)\n\n## 日本語の見出し\n\n## `code_heading`\n";
          const o = extractOutline(md);
          assert(o.length === 3, "punctuation: 3 headings");
          assert(o[0].id.length > 0, "punctuation: non-empty slug for punctuated heading");
          assert(o[1].id.length > 0, "punctuation: non-empty slug for Unicode heading");
        })();

        (function testOutline_emptyHeading() {
          const md = "## \n\n## Real\n";
          const o = extractOutline(md);
          assert(o.length === 2, "empty: 2 headings (one empty)");
          assert(o[0].id === "heading", "empty: empty heading gets fallback slug 'heading'", { got: o[0].id });
        })();

        (function testOutline_deepNesting() {
          const md = "# H1\n## H2\n### H3\n#### H4\n##### H5\n###### H6\n";
          const o = extractOutline(md);
          assert(o.length === 6, "deep: 6 levels");
          assert(o[5].level === 6, "deep: h6 detected", { got: o[5].level });
        })();

        // --- slugifyHeading tests ---
        (function testSlug_basic() {
          assert(slugifyHeading("Hello World") === "hello-world", "slug: basic");
          assert(slugifyHeading("") === "heading", "slug: empty string fallback");
          assert(slugifyHeading("  ") === "heading", "slug: whitespace fallback");
          assert(slugifyHeading("CamelCase") === "camelcase", "slug: lowercased");
          assert(slugifyHeading("a--b") === "a-b", "slug: collapsed hyphens");
        })();

        // --- buildLineToHeadingMap tests ---
        (function testLineMap_basic() {
          const outline = [
            { text: "A", level: 1, id: "a", line: 1 },
            { text: "B", level: 2, id: "b", line: 5 },
            { text: "C", level: 2, id: "c", line: 10 },
          ];
          const map = buildLineToHeadingMap(15, outline);
          assert(map[1] === "a", "linemap: line 1 -> a", { got: map[1] });
          assert(map[4] === "a", "linemap: line 4 -> a (before B)", { got: map[4] });
          assert(map[5] === "b", "linemap: line 5 -> b", { got: map[5] });
          assert(map[9] === "b", "linemap: line 9 -> b", { got: map[9] });
          assert(map[10] === "c", "linemap: line 10 -> c", { got: map[10] });
          assert(map[15] === "c", "linemap: line 15 -> c", { got: map[15] });
        })();

        (function testLineMap_preamble() {
          const outline = [{ text: "A", level: 1, id: "a", line: 5 }];
          const map = buildLineToHeadingMap(10, outline);
          assert(map[1] === "__preamble__", "preamble: line 1 before any heading", { got: map[1] });
          assert(map[4] === "__preamble__", "preamble: line 4 before first heading", { got: map[4] });
          assert(map[5] === "a", "preamble: line 5 at first heading", { got: map[5] });
        })();

        // --- attributeHunksToHeadings tests ---
        (function testAttribution_basic() {
          const patch = `--- a/doc.md
+++ b/doc.md
@@ -3,2 +3,3 @@
 unchanged
+new line in section A
+another new line
@@ -8,1 +9,2 @@
 unchanged
+added in section B`;
          const lineToHeading = new Array(12);
          for (let i = 0; i <= 11; i++) lineToHeading[i] = i < 7 ? "a" : "b";
          const m = attributeHunksToHeadings(patch, lineToHeading);
          assert(m.has("a"), "attr: section a has metrics");
          assert(m.get("a").addLines === 2, "attr: section a +2 lines", { got: m.get("a")?.addLines });
          assert(m.has("b"), "attr: section b has metrics");
          assert(m.get("b").addLines === 1, "attr: section b +1 line", { got: m.get("b")?.addLines });
        })();

        (function testAttribution_deletions() {
          const patch = `--- a/doc.md
+++ b/doc.md
@@ -3,3 +3,1 @@
 unchanged
-removed line 1
-removed line 2`;
          const lineToHeading = new Array(8);
          for (let i = 0; i <= 7; i++) lineToHeading[i] = "section";
          const m = attributeHunksToHeadings(patch, lineToHeading);
          assert(m.has("section"), "del: section has metrics");
          assert(m.get("section").delLines === 2, "del: 2 lines deleted", { got: m.get("section")?.delLines });
          assert(m.get("section").addLines === 0, "del: 0 lines added", { got: m.get("section")?.addLines });
        })();

        (function testAttribution_empty_patch() {
          const m = attributeHunksToHeadings("", []);
          assert(m.size === 0, "empty: no metrics for empty patch");
        })();

        // --- countRoughTokens tests ---
        (function testTokens() {
          assert(countRoughTokens("hello world") === 2, "tokens: 2 words");
          assert(countRoughTokens("a + b = c") === 5, "tokens: operators count", { got: countRoughTokens("a + b = c") });
          assert(countRoughTokens("") === 0, "tokens: empty string");
          assert(countRoughTokens("single") === 1, "tokens: single word");
        })();

        // --- sectionSparkline tests ---
        (function testSparkline() {
          const html = sectionSparkline("nonexistent", 3);
          assert(html.includes("sparkline-bar"), "sparkline: contains bar spans");
          assert(!html.includes("undefined"), "sparkline: no undefined in output");
        })();

        // --- Performance sanity ---
        (function testPerformance_attribution() {
          // Generate a large synthetic diff.
          const lines = [];
          lines.push("--- a/big.md", "+++ b/big.md", "@@ -1,500 +1,600 @@");
          for (let i = 0; i < 500; i++) lines.push(" unchanged line " + i);
          for (let i = 0; i < 100; i++) lines.push("+added line " + i);
          const bigPatch = lines.join("\n");
          const bigMap = new Array(700);
          for (let i = 0; i < 700; i++) bigMap[i] = "section-" + Math.floor(i / 100);
          const t0 = performance.now();
          attributeHunksToHeadings(bigPatch, bigMap);
          const elapsed = performance.now() - t0;
          assert(elapsed < 100, "perf: 600-line attribution < 100ms", { elapsed: elapsed.toFixed(1) + "ms" });
        })();

        // Summary
        const passed = results.filter(r => r.pass).length;
        const failed = results.filter(r => !r.pass).length;
        const summary = `Section Summary Tests: ${passed} passed, ${failed} failed, ${results.length} total`;
        if (failed > 0) {
          console.warn(summary);
          results.filter(r => !r.pass).forEach(r => console.error("  FAIL:", r.msg, r.ctx || ""));
        } else {
          console.log("%c" + summary, "color: green; font-weight: bold");
        }
        return { passed, failed, total: results.length, results };
      };
      // ---- End Section Summary Unit Tests ----

      // ---- Section Summary E2E Tests (bd-24q.8.5) ----
      // Run via console: window.__runSectionE2ETests()
      // Requires dataset to be loaded and at least one commit with changes.
      window.__runSectionE2ETests = async function () {
        const results = [];
        const log = (msg, ctx) => console.log("  [E2E]", msg, ctx || "");
        const assert = (cond, msg, ctx) => {
          if (!cond) { results.push({ pass: false, msg, ctx }); console.error("  FAIL:", msg, ctx || ""); }
          else { results.push({ pass: true, msg }); log("PASS: " + msg); }
        };

        if (!DATASET.loaded || !ALL_COMMITS.length) {
          console.error("E2E: Dataset not loaded. Cannot run tests.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded" }] };
        }

        // Find a commit with actual changes for meaningful testing.
        let testIdx = -1;
        for (let i = 1; i < ALL_COMMITS.length; i++) {
          if (ALL_COMMITS[i].impact > 10) { testIdx = i; break; }
        }
        if (testIdx < 0) testIdx = Math.min(1, ALL_COMMITS.length - 1);
        log("Using commit idx=" + testIdx + " (" + ALL_COMMITS[testIdx].short + ")");

        // E2E 1: Switch to sections tab and verify table renders.
        await (async function testE2E_sectionsTabRenders() {
          selectCommitIdx(testIdx);
          setDocTab("sections");
          // Give async updateSectionSummary time to complete.
          await new Promise(r => setTimeout(r, 500));
          const view = document.getElementById("docSectionsView");
          assert(view && !view.classList.contains("hidden"), "e2e: sections view is visible");
          const tbody = document.getElementById("sectionTableBody");
          const rowCount = tbody ? tbody.querySelectorAll("tr").length : 0;
          log("Table has " + rowCount + " rows");
          assert(rowCount > 0, "e2e: section table has rows", { rowCount });
        })();

        // E2E 2: Sort by impact and verify order changes.
        await (async function testE2E_sortByImpact() {
          const th = document.querySelector('#sectionTable th[data-sort="impact"]');
          if (th) {
            th.click();
            await new Promise(r => setTimeout(r, 300));
            const rows = document.querySelectorAll("#sectionTableBody tr");
            if (rows.length >= 2) {
              const first = rows[0].querySelector("td:last-child .mono")?.textContent?.trim() || "0";
              const last = rows[rows.length - 1].querySelector("td:last-child .mono")?.textContent?.trim() || "0";
              log("First row impact: " + first + ", last row: " + last);
              assert(true, "e2e: sort by impact executed without error");
            } else {
              assert(true, "e2e: sort by impact (not enough rows to verify order)");
            }
          } else {
            assert(false, "e2e: impact sort header not found");
          }
        })();

        // E2E 3: Filter headings.
        await (async function testE2E_filterHeadings() {
          const input = document.getElementById("sectionFilter");
          if (input) {
            const tbody = document.getElementById("sectionTableBody");
            const beforeCount = tbody ? tbody.querySelectorAll("tr").length : 0;
            input.value = "xyznonexistent";
            input.dispatchEvent(new Event("input", { bubbles: true }));
            await new Promise(r => setTimeout(r, 300));
            const afterCount = tbody ? tbody.querySelectorAll("tr").length : 0;
            log("Before filter: " + beforeCount + " rows, after: " + afterCount);
            assert(afterCount <= beforeCount, "e2e: filter reduces or maintains row count");
            // Reset filter.
            input.value = "";
            input.dispatchEvent(new Event("input", { bubbles: true }));
            await new Promise(r => setTimeout(r, 300));
          } else {
            assert(false, "e2e: filter input not found");
          }
        })();

        // E2E 4: Click row jumps to spec tab with heading.
        await (async function testE2E_clickRowJumps() {
          setDocTab("sections");
          await new Promise(r => setTimeout(r, 500));
          const firstRow = document.querySelector("#sectionTableBody tr[data-heading-id]");
          if (firstRow) {
            const hid = firstRow.dataset.headingId;
            log("Clicking row for heading: " + hid);
            firstRow.click();
            await new Promise(r => setTimeout(r, 600));
            assert(DOC.tab === "spec", "e2e: after click, tab switched to spec", { got: DOC.tab });
            const docEl = document.getElementById("docRendered");
            const target = docEl ? docEl.querySelector("#" + CSS.escape(hid)) : null;
            assert(target !== null, "e2e: heading element exists in rendered doc", { hid });
            if (target) {
              const hasHighlight = target.classList.contains("section-highlight");
              log("Heading has highlight class: " + hasHighlight);
              assert(true, "e2e: heading element found (highlight animation triggered)");
            }
          } else {
            assert(false, "e2e: no rows in section table to click");
          }
        })();

        // E2E 5: Mobile sheet open/close.
        await (async function testE2E_mobileSheet() {
          const sheet = document.getElementById("sectionSheet");
          const overlay = document.getElementById("sectionSheetOverlay");
          if (sheet && overlay) {
            // Open.
            if (typeof openSectionSheet === "function") {
              openSectionSheet();
              await new Promise(r => setTimeout(r, 300));
              assert(!sheet.classList.contains("hidden"), "e2e: mobile sheet opened");
              const list = document.getElementById("sectionSheetList");
              const itemCount = list ? list.querySelectorAll("button[data-heading-id]").length : 0;
              log("Mobile sheet has " + itemCount + " items");
              assert(itemCount > 0, "e2e: mobile sheet has items", { itemCount });
              // Close.
              closeSectionSheet();
              await new Promise(r => setTimeout(r, 300));
              assert(overlay.classList.contains("hidden"), "e2e: mobile sheet overlay hidden after close");
            } else {
              assert(false, "e2e: openSectionSheet function not found");
            }
          } else {
            assert(false, "e2e: mobile sheet elements not found");
          }
        })();

        // E2E 6: Mobile sheet tap navigates.
        await (async function testE2E_mobileSheetTap() {
          if (typeof openSectionSheet === "function") {
            openSectionSheet();
            await new Promise(r => setTimeout(r, 300));
            const firstBtn = document.querySelector("#sectionSheetList button[data-heading-id]");
            if (firstBtn) {
              const hid = firstBtn.dataset.headingId;
              log("Mobile: tapping heading " + hid);
              firstBtn.click();
              await new Promise(r => setTimeout(r, 600));
              assert(DOC.tab === "spec", "e2e: mobile tap switched to spec", { got: DOC.tab });
              const sheet = document.getElementById("sectionSheet");
              // Sheet may still be animating closed.
              log("Sheet hidden: " + sheet?.classList.contains("hidden"));
              assert(true, "e2e: mobile tap navigation executed");
            } else {
              assert(false, "e2e: no mobile sheet items to tap");
            }
          }
        })();

        // E2E 7: No dock overlap check.
        await (async function testE2E_noDockOverlap() {
          const sheet = document.getElementById("sectionSheet");
          const dock = document.getElementById("dock");
          if (sheet && dock) {
            if (typeof openSectionSheet === "function") {
              openSectionSheet();
              await new Promise(r => setTimeout(r, 300));
              const sheetRect = sheet.getBoundingClientRect();
              const dockRect = dock.getBoundingClientRect();
              // Sheet z-index (50) should be above dock z-index (30).
              const sheetZ = parseInt(getComputedStyle(sheet).zIndex) || 0;
              const dockZ = parseInt(getComputedStyle(dock).zIndex) || 0;
              log("Sheet z-index: " + sheetZ + ", dock z-index: " + dockZ);
              assert(sheetZ > dockZ, "e2e: sheet z-index above dock", { sheetZ, dockZ });
              closeSectionSheet();
              await new Promise(r => setTimeout(r, 300));
            }
          }
        })();

        // Summary.
        const passed = results.filter(r => r.pass).length;
        const failed = results.filter(r => !r.pass).length;
        const summary = `Section E2E Tests: ${passed} passed, ${failed} failed, ${results.length} total`;
        if (failed > 0) {
          console.warn(summary);
          results.filter(r => !r.pass).forEach(r => console.error("  FAIL:", r.msg, r.ctx || ""));
        } else {
          console.log("%c" + summary, "color: green; font-weight: bold");
        }
        return { passed, failed, total: results.length, results };
      };
      // ---- End Section Summary E2E Tests ----

      // ---- A/B Compare Unit Tests (bd-24q.1.5) ----
      window.__runABCompareTests = async function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || ""); };
        A(quickMetricsFromPatch("").hunks === 0, "empty patch: 0 hunks");
        let m = quickMetricsFromPatch("--- a/f\n+++ b/f\n@@ -1,2 +1,3 @@\n l1\n+added\n l2\n");
        A(m.hunks === 1 && m.addLines === 1 && m.delLines === 0, "simple add", m);
        m = quickMetricsFromPatch("--- a/f\n+++ b/f\n@@ -1,3 +1,3 @@\n ctx\n-old\n+new\n ctx2\n");
        A(m.addLines === 1 && m.delLines === 1, "replace 1+1", m);
        m = quickMetricsFromPatch("--- a/f\n+++ b/f\n@@ -1 +1 @@\n-x\n+y\n@@ -5 +5 @@\n-a\n+b\n");
        A(m.hunks === 2, "multi-hunk", m);
        let h = parseUnifiedHunks("@@ -1,3 +1,4 @@\n l1\n+ins\n l2\n l3\n");
        A(h.length === 1 && h[0].oldStart === 1, "hunks basic");
        h = parseUnifiedHunks("@@ -5 +5 @@\n-old\n+new\n");
        A(h.length === 1 && h[0].oldCount === 1, "hunks no-count");
        let r = applyPatchLines(["a","b","c"], "@@ -2,2 +2,3 @@\n b\n+ins\n c\n");
        A(r.length === 4 && r[2] === "ins", "apply add");
        r = applyPatchLines(["a","b","c"], "@@ -1,3 +1,2 @@\n a\n-b\n c\n");
        A(r.length === 2 && r[1] === "c", "apply del");
        r = applyPatchLines(["a","b","c"], "@@ -2,1 +2,1 @@\n-b\n+B\n");
        A(r.length === 3 && r[1] === "B", "apply replace");
	        if (DATASET.loaded && DATASET.db) {
	          const base = String(DATASET.baseDoc || "");
	          A((await docTextAtLocal(0)) === base, "snapshot 0==base");
	          if (ALL_COMMITS.length > 1) { DOC_CACHE.delete(1); DOC_CURSOR.idx=-1; DOC_CURSOR.lines=null; const a=await docTextAtLocal(1); DOC_CACHE.delete(1); DOC_CURSOR.idx=-1; DOC_CURSOR.lines=null; A(a===(await docTextAtLocal(1)), "snapshot 1 deterministic"); }
	          if (ALL_COMMITS.length > 5) { DOC_CACHE.clear(); DOC_CURSOR.idx=-1; DOC_CURSOR.lines=null; const d=await docTextAtLocal(5); DOC_CACHE.clear(); DOC_CURSOR.idx=-1; DOC_CURSOR.lines=null; let ln=base.split("\n"); for(let i=1;i<=5;i++) ln=applyPatchLines(ln,patchForIdx(i)); A(d===ln.join("\n"), "snapshot 5 far-jump"); }
	          if (typeof Diff!=="undefined" && ALL_COMMITS.length>3) {
	            A((await generateABDiff(0,2))===(await generateABDiff(0,2)), "diff deterministic");
            const ms=quickMetricsFromPatch(await generateABDiff(1,1)); A(ms.addLines===0&&ms.delLines===0, "diff same: 0");
            const mAB=quickMetricsFromPatch(await generateABDiff(0,3)); const mBA=quickMetricsFromPatch(await generateABDiff(3,0));
            A(mAB.addLines===mBA.delLines&&mAB.delLines===mBA.addLines, "diff swap symmetry");
            A(quickMetricsFromPatch(await generateABDiff(0,ALL_COMMITS.length-1)).tokensDelta>0, "spec grew");
          }
        }
        (() => { const c=document.createElement("div"); c.innerHTML='<span id="abmLines"></span><span id="abmTokens"></span><span id="abmLev"></span><span id="abmHunks"></span><span id="abmBytes"></span>'; document.body.appendChild(c); renderABMetricChips({addLines:100,delLines:50,deltaLines:50,tokensChanged:300,tokensDelta:100,bytesChanged:5000,bytesDelta:2000,hunks:5,lev:42}); A(document.getElementById("abmLines").textContent.includes("+100"),"chip +100"); A(document.getElementById("abmLev").textContent.includes("42"),"chip lev"); document.body.removeChild(c); })();
        (() => { const c=document.createElement("div"); c.innerHTML='<span id="abmLines"></span><span id="abmTokens"></span><span id="abmLev"></span><span id="abmHunks"></span><span id="abmBytes"></span>'; document.body.appendChild(c); renderABMetricChips({addLines:0,delLines:0,deltaLines:0,tokensChanged:0,tokensDelta:0,bytesChanged:0,bytesDelta:0,hunks:0,lev:null}); A(document.getElementById("abmLev").textContent.includes("?"),"chip null lev"); document.body.removeChild(c); })();
        const p=R.filter(x=>x.pass).length, f=R.filter(x=>!x.pass).length;
        const s=`A/B Compare Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if(f>0){console.warn(s);R.filter(x=>!x.pass).forEach(x=>console.error("  FAIL:",x.msg,x.ctx||""));}else console.log("%c"+s,"color:green;font-weight:bold");
        return{passed:p,failed:f,total:R.length,results:R};
      };
      // ---- End A/B Compare Unit Tests ----

      // ---- A/B Compare E2E Tests (bd-24q.1.6) ----
      // Run via console: window.__runABCompareE2ETests()
      // Requires dataset to be loaded with at least 3 commits.
      window.__runABCompareE2ETests = async function () {
        const results = [];
        const log = (msg, ctx) => console.log("  [AB-E2E]", msg, ctx || "");
        const assert = (cond, msg, ctx) => {
          if (!cond) { results.push({ pass: false, msg, ctx }); console.error("  FAIL:", msg, ctx || ""); }
          else { results.push({ pass: true, msg }); log("PASS: " + msg); }
        };
        const wait = (ms) => new Promise((r) => setTimeout(r, ms));

        if (!DATASET.loaded || ALL_COMMITS.length < 3) {
          console.error("AB-E2E: Need loaded dataset with >= 3 commits.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded or < 3 commits" }] };
        }

        const origIdx = DOC.idx;
        const origTab = DOC.tab;
        const origCompare = DOC.compareMode;
        const origFromIdx = DOC.compareFromIdx;
        const origToIdx = DOC.compareToIdx;
        const origLayout = DOC.diffLayout;

        // --- E2E 1: Enable compare mode via toggle ---
        await (async function testE2E_enableCompare() {
          DOC.compareMode = false;
          setDocTab("diff");
          await wait(200);
          const btn = document.getElementById("btnCompareToggle");
          if (btn) {
            btn.click();
            await wait(400);
            assert(DOC.compareMode === true, "ab-e2e: compare mode enabled after toggle click");
            const bar = document.getElementById("abCompareBar");
            assert(bar && !bar.classList.contains("hidden"), "ab-e2e: abCompareBar is visible");
            log("compareFromIdx=" + DOC.compareFromIdx + " compareToIdx=" + DOC.compareToIdx);
          } else {
            assert(false, "ab-e2e: btnCompareToggle not found");
          }
        })();

        // --- E2E 2: Pick A and B, verify diff renders ---
        await (async function testE2E_pickAB() {
          DOC.compareFromIdx = 0;
          DOC.compareToIdx = Math.min(2, ALL_COMMITS.length - 1);
          DOC.compareMode = true;
          populateCompareSelects();
          setDocTab("diff");
          await wait(1500);
          const diffEl = document.getElementById("diffPretty");
          const hasContent = diffEl && diffEl.innerHTML.length > 50;
          assert(hasContent, "ab-e2e: diffPretty has content after picking A=0 B=2", { htmlLen: diffEl?.innerHTML.length });
          const btnA = document.getElementById("pickerABtn");
          const btnB = document.getElementById("pickerBBtn");
          assert(btnA && btnA.textContent.length > 2, "ab-e2e: picker A has label text");
          assert(btnB && btnB.textContent.length > 2, "ab-e2e: picker B has label text");
        })();

        // --- E2E 3: Metrics bar appears for different A/B ---
        await (async function testE2E_metricsBar() {
          DOC.compareFromIdx = 0;
          DOC.compareToIdx = 2;
          DOC.compareMode = true;
          setDocTab("diff");
          await wait(2000);
          const bar = document.getElementById("abMetricsBar");
          const visible = bar && !bar.classList.contains("hidden");
          assert(visible, "ab-e2e: abMetricsBar visible for A!=B");
          if (visible) {
            const linesChip = document.getElementById("abmLines");
            const hunksChip = document.getElementById("abmHunks");
            log("Lines chip: " + (linesChip?.textContent || "(empty)"));
            log("Hunks chip: " + (hunksChip?.textContent || "(empty)"));
            assert(linesChip && linesChip.textContent.length > 0 && linesChip.textContent !== "...", "ab-e2e: lines chip populated");
            assert(hunksChip && hunksChip.textContent.length > 0 && hunksChip.textContent !== "...", "ab-e2e: hunks chip populated");
          }
        })();

        // --- E2E 4: Swap A and B, verify indices swap ---
        await (async function testE2E_swap() {
          DOC.compareFromIdx = 0;
          DOC.compareToIdx = 2;
          DOC.compareMode = true;
          populateCompareSelects();
          syncUrlToState();
          await wait(200);
          const swapBtn = document.getElementById("btnSwapAB");
          if (swapBtn) {
            swapBtn.click();
            await wait(800);
            assert(DOC.compareFromIdx === 2, "ab-e2e: after swap, fromIdx=2", { got: DOC.compareFromIdx });
            assert(DOC.compareToIdx === 0, "ab-e2e: after swap, toIdx=0", { got: DOC.compareToIdx });
          } else {
            assert(false, "ab-e2e: btnSwapAB not found");
          }
        })();

        // --- E2E 5: Toggle diff layout ---
        await (async function testE2E_diffLayout() {
          DOC.compareMode = true;
          DOC.compareFromIdx = 0;
          DOC.compareToIdx = 2;
          DOC.diffLayout = "side-by-side";
          setDocTab("diff");
          await wait(800);
          const layoutBtn = document.getElementById("btnDiffLayout");
          if (layoutBtn) {
            const beforeLayout = DOC.diffLayout;
            layoutBtn.click();
            await wait(800);
            assert(DOC.diffLayout !== beforeLayout, "ab-e2e: layout toggled");
            assert(DOC.diffLayout === "line-by-line", "ab-e2e: layout is now line-by-line");
            layoutBtn.click();
            await wait(400);
            assert(DOC.diffLayout === "side-by-side", "ab-e2e: layout back to side-by-side");
          } else {
            assert(false, "ab-e2e: btnDiffLayout not found");
          }
        })();

        // --- E2E 6: Switch tabs while in compare mode ---
        await (async function testE2E_tabSwitch() {
          DOC.compareMode = true;
          DOC.compareFromIdx = 0;
          DOC.compareToIdx = 2;
          for (const tab of ["spec", "diff", "metrics", "sections", "diff"]) {
            try {
              setDocTab(tab);
              await wait(300);
              assert(DOC.tab === tab, "ab-e2e: tab switch to " + tab + " ok");
            } catch (e) {
              assert(false, "ab-e2e: tab switch to " + tab + " threw", { error: String(e) });
            }
          }
        })();

        // --- E2E 7: Permalink round-trip ---
        await (async function testE2E_permalink() {
          DOC.compareMode = true;
          DOC.compareFromIdx = 1;
          DOC.compareToIdx = Math.min(3, ALL_COMMITS.length - 1);
          DOC.diffLayout = "line-by-line";
          setDocTab("diff");
          await wait(200);
          const encoded = encodeUrlState();
          log("Encoded URL state: " + encoded);
          assert(encoded.includes("cmp=1"), "ab-e2e: permalink has cmp=1");
          assert(encoded.includes("ca=1"), "ab-e2e: permalink has ca=1");
          assert(encoded.includes("cb="), "ab-e2e: permalink has cb=");
          assert(encoded.includes("dl=line-by-line"), "ab-e2e: permalink has dl=line-by-line");
          const decoded = decodeUrlState(encoded);
          assert(decoded !== null, "ab-e2e: decoded is not null");
          assert(decoded.cmp === true, "ab-e2e: decoded.cmp is true");
          assert(decoded.ca === 1, "ab-e2e: decoded.ca is 1", { got: decoded?.ca });
          assert(decoded.cb === DOC.compareToIdx, "ab-e2e: decoded.cb matches", { got: decoded?.cb });
          assert(decoded.dl === "line-by-line", "ab-e2e: decoded.dl is line-by-line");
          const savedFrom = DOC.compareFromIdx;
          const savedTo = DOC.compareToIdx;
          DOC.compareMode = false; DOC.compareFromIdx = 0; DOC.compareToIdx = 0; DOC.diffLayout = "side-by-side";
          applyUrlState(decoded);
          assert(DOC.compareMode === true, "ab-e2e: applyUrlState restored compareMode");
          assert(DOC.compareFromIdx === savedFrom, "ab-e2e: applyUrlState restored fromIdx");
          assert(DOC.compareToIdx === savedTo, "ab-e2e: applyUrlState restored toIdx");
          assert(DOC.diffLayout === "line-by-line", "ab-e2e: applyUrlState restored diffLayout");
        })();

        // --- E2E 8: Disable compare mode ---
        await (async function testE2E_disableCompare() {
          DOC.compareMode = true;
          setDocTab("diff");
          await wait(200);
          const btn = document.getElementById("btnCompareToggle");
          if (btn) {
            if (!DOC.compareMode) { btn.click(); await wait(200); }
            btn.click();
            await wait(400);
            assert(DOC.compareMode === false, "ab-e2e: compare mode disabled after toggle");
            const bar = document.getElementById("abCompareBar");
            assert(bar && bar.classList.contains("hidden"), "ab-e2e: abCompareBar hidden after disable");
            const metricsBar = document.getElementById("abMetricsBar");
            assert(!metricsBar || metricsBar.classList.contains("hidden"), "ab-e2e: abMetricsBar hidden after disable");
          } else {
            assert(false, "ab-e2e: btnCompareToggle not found");
          }
        })();

        // Restore original state.
        DOC.compareMode = origCompare;
        DOC.compareFromIdx = origFromIdx;
        DOC.compareToIdx = origToIdx;
        DOC.diffLayout = origLayout;
        DOC.idx = origIdx;
        setDocTab(origTab);
        await wait(300);

        const passed = results.filter((r) => r.pass).length;
        const failed = results.filter((r) => !r.pass).length;
        const summary = `A/B Compare E2E Tests: ${passed} passed, ${failed} failed, ${results.length} total`;
        if (failed > 0) {
          console.warn(summary);
          results.filter((r) => !r.pass).forEach((r) => console.error("  FAIL:", r.msg, r.ctx || ""));
        } else {
          console.log("%c" + summary, "color: green; font-weight: bold");
        }
        return { passed, failed, total: results.length, results };
      };
      // ---- End A/B Compare E2E Tests ----

      // ---- Permalink Unit Tests (bd-24q.3.4) ----
      // Run via console: window.__runPermalinkTests()
      window.__runPermalinkTests=function(){const R=[];const A=(c,m,x)=>{R.push(c?{pass:true,msg:m}:{pass:false,msg:m,ctx:x});if(!c)console.error("FAIL:",m,x||"")};const oD={idx:DOC.idx,tab:DOC.tab,rawSpec:DOC.rawSpec,diffMode:DOC.diffMode,compareMode:DOC.compareMode,compareFromIdx:DOC.compareFromIdx,compareToIdx:DOC.compareToIdx,diffLayout:DOC.diffLayout};const oS={q:STATE.q,minImpact:STATE.minImpact,bucketMode:STATE.bucketMode,bucketEnabled:new Set(STATE.bucketEnabled)};const mx=Math.max(0,(ALL_COMMITS?.length||1)-1);A(decodeUrlState("")===null,"decode:empty->null");A(decodeUrlState("c=5")===null,"decode:no-v->null");A(decodeUrlState("v=999")===null,"decode:bad-v->null");let d=decodeUrlState("v=1");A(d!==null,"decode:v=1 ok");A(d.c===-1,"decode:c=-1",{got:d?.c});A(d.t==="spec","decode:t=spec");A(d.raw===false,"decode:raw=false");A(d.dm==="pretty","decode:dm=pretty");A(d.q==="","decode:q=empty");A(d.mi===0,"decode:mi=0");A(d.bm==="primary","decode:bm=primary");A(d.b===null,"decode:b=null");A(d.cmp===false,"decode:cmp=false");d=decodeUrlState("v=1&c=5&t=diff&raw=1&dm=raw&q=hello&mi=10&bm=multi&b=1,2,3&cmp=1&ca=2&cb=7&dl=line-by-line");A(d.c===5,"decode:c=5");A(d.t==="diff","decode:t=diff");A(d.raw===true,"decode:raw=1");A(d.dm==="raw","decode:dm=raw");A(d.q==="hello","decode:q=hello");A(d.mi===10,"decode:mi=10");A(d.bm==="multi","decode:bm=multi");A(d.b instanceof Set&&d.b.size===3,"decode:b=3ids");A(d.cmp===true,"decode:cmp=true");A(d.ca===2,"decode:ca=2");A(d.cb===7,"decode:cb=7");A(d.dl==="line-by-line","decode:dl=l-b-l");A(decodeUrlState("v=1&t=bogus").t==="spec","decode:bad-tab->spec");A(decodeUrlState("v=1&dm=bogus").dm==="pretty","decode:bad-dm->pretty");A(decodeUrlState("v=1&c=-5").c===-1,"decode:neg-c->-1");A(decodeUrlState("v=1&c=3.7").c===3,"decode:float-c->3");A(decodeUrlState("v=1&c=abc").c===-1,"decode:nan-c->-1");d=decodeUrlState("v=1&b=abc,def");A(d.b instanceof Set&&d.b.size===URL_ALL_BUCKET_IDS.size,"decode:bad-b->all");d=decodeUrlState("v=1&cmp=1");A(d.cmp===true&&d.ca===0&&d.cb===0,"decode:partial-cmp");A(d.dl==="side-by-side","decode:no-dl->sbs");A(decodeUrlState("v=1&cmp=1&dl=bogus").dl==="side-by-side","decode:bad-dl->sbs");DOC.idx=mx;DOC.tab="spec";DOC.rawSpec=false;DOC.diffMode="pretty";DOC.compareMode=false;STATE.q="";STATE.minImpact=0;STATE.bucketMode="primary";STATE.bucketEnabled=new Set(URL_ALL_BUCKET_IDS);A(encodeUrlState()==="","encode:defaults->empty");DOC.tab="diff";let enc=encodeUrlState();A(enc.includes("v=1"),"encode:has-v");A(enc.includes("t=diff"),"encode:t=diff");A(!enc.includes("c="),"encode:no-c@max");DOC.tab="spec";DOC.idx=3;enc=encodeUrlState();A(enc.includes("c=3"),"encode:c=3");DOC.idx=mx;DOC.tab="diff";DOC.compareMode=true;DOC.compareFromIdx=1;DOC.compareToIdx=5;DOC.diffLayout="line-by-line";enc=encodeUrlState();A(enc.includes("cmp=1"),"encode:cmp");A(enc.includes("ca=1"),"encode:ca");A(enc.includes("cb=5"),"encode:cb");A(enc.includes("dl=line-by-line"),"encode:dl");DOC.diffLayout="side-by-side";DOC.compareFromIdx=0;DOC.compareToIdx=1;enc=encodeUrlState();A(!enc.includes("dl="),"encode:sbs-omit");DOC.compareMode=false;DOC.tab="spec";STATE.q="MVCC";enc=encodeUrlState();A(enc.includes("q=MVCC"),"encode:q");STATE.q="";const ids=[...URL_ALL_BUCKET_IDS];STATE.bucketEnabled=new Set(ids.slice(0,2));enc=encodeUrlState();A(enc.includes("b="),"encode:subset-b");STATE.bucketEnabled=new Set(URL_ALL_BUCKET_IDS);DOC.idx=2;DOC.tab="diff";DOC.rawSpec=true;DOC.diffMode="raw";DOC.compareMode=false;STATE.q="test query";STATE.minImpact=5;STATE.bucketMode="multi";const e1=encodeUrlState();applyUrlState(decodeUrlState(e1));const e2=encodeUrlState();A(e1===e2,"roundtrip:basic",{e1,e2});DOC.idx=0;DOC.tab="diff";DOC.rawSpec=false;DOC.diffMode="pretty";DOC.compareMode=true;DOC.compareFromIdx=1;DOC.compareToIdx=Math.min(4,mx);DOC.diffLayout="line-by-line";STATE.q="";STATE.minImpact=0;STATE.bucketMode="primary";STATE.bucketEnabled=new Set(URL_ALL_BUCKET_IDS);const e3=encodeUrlState();applyUrlState(decodeUrlState(e3));const e4=encodeUrlState();A(e3===e4,"roundtrip:compare",{e3,e4});A(DOC.compareMode===true&&DOC.compareFromIdx===1&&DOC.diffLayout==="line-by-line","roundtrip:cmp-ok");DOC.idx=2;DOC.tab="diff";DOC.rawSpec=true;DOC.diffMode="raw";DOC.compareMode=true;DOC.compareFromIdx=0;DOC.compareToIdx=1;DOC.diffLayout="line-by-line";STATE.q="foo";STATE.minImpact=3;STATE.bucketMode="multi";STATE.bucketEnabled=new Set(URL_ALL_BUCKET_IDS);enc=encodeUrlState();const keys=[...new URLSearchParams(enc).keys()];const ord=["v","c","t","raw","dm","cmp","ca","cb","dl","q","mi","bm"];let pv=-1,ok=true;for(const k of ord){const p=keys.indexOf(k);if(p>=0){if(p<pv){ok=false;break}pv=p}}A(ok,"canonical:order",{keys});A(keys[0]==="v","canonical:v-first");A(decodeUrlState("v=1&mi=0").mi===0,"edge:mi=0");A(decodeUrlState("v=1&mi=-5").mi===0,"edge:neg-mi");A(decodeUrlState("v=1&raw=1").raw===true,"edge:raw=1");A(decodeUrlState("v=1&raw=0").raw===false,"edge:raw=0");A(decodeUrlState("v=1&raw=yes").raw===false,"edge:raw=yes");d=decodeUrlState("v=1&b=");A(d.b instanceof Set&&d.b.size===URL_ALL_BUCKET_IDS.size,"edge:empty-b->all");Object.assign(DOC,oD);Object.assign(STATE,oS);const p=R.filter(x=>x.pass).length,f=R.filter(x=>!x.pass).length;const s=`Permalink Tests: ${p} passed, ${f} failed, ${R.length} total`;if(f>0){console.warn(s);R.filter(x=>!x.pass).forEach(x=>console.error("  FAIL:",x.msg,x.ctx||""))}else console.log("%c"+s,"color:green;font-weight:bold");return{passed:p,failed:f,total:R.length,results:R}};
      // ---- End Permalink Unit Tests ----

      // ---- Permalink E2E Tests (bd-24q.3.5) ----
      // Run via console: window.__runPermalinkE2ETests()
      // Requires dataset to be loaded.
      window.__runPermalinkE2ETests = async function () {
        const results = [];
        const log = (msg, ctx) => console.log("  [PL-E2E]", msg, ctx || "");
        const assert = (cond, msg, ctx) => {
          if (!cond) { results.push({ pass: false, msg, ctx }); console.error("  FAIL:", msg, ctx || ""); }
          else { results.push({ pass: true, msg }); log("PASS: " + msg); }
        };
        const wait = (ms) => new Promise((r) => setTimeout(r, ms));

        if (!DATASET.loaded || ALL_COMMITS.length < 3) {
          console.error("PL-E2E: Need loaded dataset with >= 3 commits.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded or < 3 commits" }] };
        }

        const maxIdx = ALL_COMMITS.length - 1;
        // Save original state.
        const origDoc = { idx: DOC.idx, tab: DOC.tab, rawSpec: DOC.rawSpec, diffMode: DOC.diffMode, compareMode: DOC.compareMode, compareFromIdx: DOC.compareFromIdx, compareToIdx: DOC.compareToIdx, diffLayout: DOC.diffLayout, abViewMode: DOC.abViewMode };
        const origState = { q: STATE.q, minImpact: STATE.minImpact, bucketMode: STATE.bucketMode, bucketEnabled: new Set(STATE.bucketEnabled) };

        // --- E2E 1: Complex state round-trip via encode/decode/apply ---
        await (async function testE2E_complexRoundTrip() {
          log("Setting complex state...");
          DOC.idx = 2; DOC.tab = "diff"; DOC.rawSpec = true; DOC.diffMode = "raw";
          DOC.compareMode = true; DOC.compareFromIdx = 0; DOC.compareToIdx = Math.min(3, maxIdx);
          DOC.diffLayout = "line-by-line"; DOC.abViewMode = "rendered";
          STATE.q = "MVCC concurrency"; STATE.minImpact = 5; STATE.bucketMode = "multi";
          const ids = [...URL_ALL_BUCKET_IDS];
          STATE.bucketEnabled = new Set(ids.slice(0, Math.min(3, ids.length)));

          const encoded = encodeUrlState();
          log("Encoded URL: " + encoded);
          assert(encoded.length > 20, "pl-e2e: complex state produces non-trivial URL", { len: encoded.length });

          // Summarize state before.
          const stateBefore = { idx: DOC.idx, tab: DOC.tab, raw: DOC.rawSpec, dm: DOC.diffMode, cmp: DOC.compareMode, ca: DOC.compareFromIdx, cb: DOC.compareToIdx, dl: DOC.diffLayout, avm: DOC.abViewMode, q: STATE.q, mi: STATE.minImpact, bm: STATE.bucketMode, bCount: STATE.bucketEnabled.size };
          log("State before: " + JSON.stringify(stateBefore));

          // Reset to defaults.
          DOC.idx = maxIdx; DOC.tab = "spec"; DOC.rawSpec = false; DOC.diffMode = "pretty";
          DOC.compareMode = false; DOC.compareFromIdx = 0; DOC.compareToIdx = 0;
          DOC.diffLayout = "side-by-side"; DOC.abViewMode = "diff";
          STATE.q = ""; STATE.minImpact = 0; STATE.bucketMode = "primary";
          STATE.bucketEnabled = new Set(URL_ALL_BUCKET_IDS);

          // Decode and apply.
          const decoded = decodeUrlState(encoded);
          assert(decoded !== null, "pl-e2e: decoded is not null");
          applyUrlState(decoded);

          // Summarize state after.
          const stateAfter = { idx: DOC.idx, tab: DOC.tab, raw: DOC.rawSpec, dm: DOC.diffMode, cmp: DOC.compareMode, ca: DOC.compareFromIdx, cb: DOC.compareToIdx, dl: DOC.diffLayout, q: STATE.q, mi: STATE.minImpact, bm: STATE.bucketMode, bCount: STATE.bucketEnabled.size };
          log("State after: " + JSON.stringify(stateAfter));

          assert(DOC.idx === 2, "pl-e2e: idx restored to 2", { got: DOC.idx });
          assert(DOC.tab === "diff", "pl-e2e: tab restored to diff");
          assert(DOC.rawSpec === true, "pl-e2e: rawSpec restored");
          assert(DOC.diffMode === "raw", "pl-e2e: diffMode restored");
          assert(DOC.compareMode === true, "pl-e2e: compareMode restored");
          assert(DOC.compareFromIdx === 0, "pl-e2e: fromIdx restored");
          assert(DOC.compareToIdx === Math.min(3, maxIdx), "pl-e2e: toIdx restored");
          assert(DOC.diffLayout === "line-by-line", "pl-e2e: diffLayout restored");
          assert(STATE.q === "MVCC concurrency", "pl-e2e: query restored");
          assert(STATE.minImpact === 5, "pl-e2e: minImpact restored");
          assert(STATE.bucketMode === "multi", "pl-e2e: bucketMode restored");
          assert(STATE.bucketEnabled.size <= 3, "pl-e2e: bucket subset restored", { got: STATE.bucketEnabled.size });
        })();

        // --- E2E 2: URL updates when commit changes via selectCommitIdx ---
        await (async function testE2E_commitChangeUpdatesUrl() {
          DOC.compareMode = false;
          DOC.tab = "spec"; DOC.rawSpec = false; DOC.diffMode = "pretty";
          STATE.q = ""; STATE.minImpact = 0; STATE.bucketMode = "primary";
          STATE.bucketEnabled = new Set(URL_ALL_BUCKET_IDS);
          selectCommitIdx(3);
          await wait(200); // Wait for rAF debounce in syncUrlToState.
          const qs = encodeUrlState();
          log("After selectCommitIdx(3), URL: " + qs);
          assert(qs.includes("c=3"), "pl-e2e: URL has c=3 after selectCommitIdx(3)", { got: qs });

          selectCommitIdx(maxIdx);
          await wait(200);
          const qs2 = encodeUrlState();
          log("After selectCommitIdx(max), URL: " + qs2);
          assert(!qs2.includes("c=") || qs2 === "", "pl-e2e: URL omits c at maxIdx", { got: qs2 });
        })();

        // --- E2E 3: Tab switch persists in URL ---
        await (async function testE2E_tabPersists() {
          DOC.compareMode = false;
          setDocTab("metrics");
          await wait(200);
          const qs = encodeUrlState();
          log("After setDocTab(metrics), URL: " + qs);
          assert(qs.includes("t=metrics"), "pl-e2e: URL has t=metrics", { got: qs });

          setDocTab("spec");
          await wait(200);
          const qs2 = encodeUrlState();
          assert(!qs2.includes("t=") || qs2 === "", "pl-e2e: URL omits t=spec (default)", { got: qs2 });
        })();

        // --- E2E 4: Compare mode toggle persists in URL ---
        await (async function testE2E_comparePersists() {
          const btn = document.getElementById("btnCompareToggle");
          if (!btn) { assert(false, "pl-e2e: btnCompareToggle not found"); return; }
          // Ensure off first.
          if (DOC.compareMode) { btn.click(); await wait(300); }
          assert(!DOC.compareMode, "pl-e2e: compare off before test");

          btn.click();
          await wait(300);
          const qs = encodeUrlState();
          log("After compare on, URL: " + qs);
          assert(qs.includes("cmp=1"), "pl-e2e: URL has cmp=1 after toggle on", { got: qs });
          assert(qs.includes("ca="), "pl-e2e: URL has ca= after toggle on");
          assert(qs.includes("cb="), "pl-e2e: URL has cb= after toggle on");

          btn.click();
          await wait(300);
          const qs2 = encodeUrlState();
          assert(!qs2.includes("cmp="), "pl-e2e: URL omits cmp after toggle off", { got: qs2 });
        })();

        // --- E2E 5: Multiple rapid changes produce stable URL ---
        await (async function testE2E_rapidChangesStable() {
          DOC.compareMode = false; DOC.tab = "spec";
          selectCommitIdx(1);
          selectCommitIdx(2);
          selectCommitIdx(5 < maxIdx ? 5 : maxIdx);
          await wait(300); // Let debounce settle.
          const qs = encodeUrlState();
          const decoded = decodeUrlState(qs);
          if (decoded) {
            applyUrlState(decoded);
            const qs2 = encodeUrlState();
            assert(qs === qs2, "pl-e2e: rapid changes produce stable URL", { qs, qs2 });
          } else {
            assert(qs === "", "pl-e2e: rapid changes at default produce empty URL");
          }
        })();

        // --- E2E 6: copyPermalink function produces valid URL ---
        await (async function testE2E_copyPermalink() {
          if (typeof copyPermalink !== "function") {
            assert(false, "pl-e2e: copyPermalink function not found");
            return;
          }
          DOC.idx = 2; DOC.tab = "diff"; DOC.compareMode = false;
          STATE.q = "test"; STATE.minImpact = 0; STATE.bucketMode = "primary";
          STATE.bucketEnabled = new Set(URL_ALL_BUCKET_IDS);
          // copyPermalink writes to clipboard; we can't easily read it, but
          // we can verify encodeUrlState produces the expected result.
          const qs = encodeUrlState();
          assert(qs.includes("c=2"), "pl-e2e: permalink would have c=2");
          assert(qs.includes("t=diff"), "pl-e2e: permalink would have t=diff");
          assert(qs.includes("q=test"), "pl-e2e: permalink would have q=test");
          log("Permalink URL would be: ?" + qs);
        })();

        // --- E2E 7: Console warnings logged for diagnostic ---
        await (async function testE2E_diagnosticLog() {
          // Verify we can log state summaries without errors.
          try {
            const state = { idx: DOC.idx, tab: DOC.tab, cmp: DOC.compareMode, ca: DOC.compareFromIdx, cb: DOC.compareToIdx, q: STATE.q };
            const url = encodeUrlState();
            log("Diagnostic state: " + JSON.stringify(state));
            log("Diagnostic URL: " + url);
            assert(true, "pl-e2e: diagnostic logging works");
          } catch (e) {
            assert(false, "pl-e2e: diagnostic logging threw", { error: String(e) });
          }
        })();

        // --- Restore original state ---
        DOC.compareMode = origDoc.compareMode;
        DOC.compareFromIdx = origDoc.compareFromIdx;
        DOC.compareToIdx = origDoc.compareToIdx;
        DOC.diffLayout = origDoc.diffLayout;
        DOC.abViewMode = origDoc.abViewMode;
        DOC.rawSpec = origDoc.rawSpec;
        DOC.diffMode = origDoc.diffMode;
        DOC.idx = origDoc.idx;
        STATE.q = origState.q;
        STATE.minImpact = origState.minImpact;
        STATE.bucketMode = origState.bucketMode;
        STATE.bucketEnabled = origState.bucketEnabled;
        setDocTab(origDoc.tab);
        await wait(300);

        const passed = results.filter((r) => r.pass).length;
        const failed = results.filter((r) => !r.pass).length;
        const summary = `Permalink E2E Tests: ${passed} passed, ${failed} failed, ${results.length} total`;
        if (failed > 0) {
          console.warn(summary);
          results.filter((r) => !r.pass).forEach((r) => console.error("  FAIL:", r.msg, r.ctx || ""));
        } else {
          console.log("%c" + summary, "color: green; font-weight: bold");
        }
        return { passed, failed, total: results.length, results };
      };
      // ---- End Permalink E2E Tests ----

      // ---- Playback Unit Tests (bd-24q.7.3) ----
      // Run via console: window.__runPlaybackTests()
      window.__runPlaybackTests = function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || "") };

        // --- playbackTicksForElapsed ---
        (function testTicks_basic() {
          // 1000ms at speed=1 => exactly 1 tick, 0 remainder.
          const r = playbackTicksForElapsed(1000, 1, 0);
          A(r.ticks === 1, "ticks: 1000ms@1x = 1 tick", r);
          A(r.remainder === 0, "ticks: 1000ms@1x = 0 remainder", r);
        })();

        (function testTicks_subTick() {
          // 500ms at speed=1 => 0 ticks, 500 remainder.
          const r = playbackTicksForElapsed(500, 1, 0);
          A(r.ticks === 0, "ticks: 500ms@1x = 0 ticks", r);
          A(Math.abs(r.remainder - 500) < 0.01, "ticks: 500ms remainder", r);
        })();

        (function testTicks_accumulation() {
          // 600ms at speed=1 with 500ms accumulated => 1 tick, 100ms remainder.
          const r = playbackTicksForElapsed(600, 1, 500);
          A(r.ticks === 1, "ticks: 600ms+500ms@1x = 1 tick", r);
          A(Math.abs(r.remainder - 100) < 0.01, "ticks: remainder 100ms", r);
        })();

        (function testTicks_fastSpeed() {
          // 1000ms at speed=4 => 4 ticks.
          const r = playbackTicksForElapsed(1000, 4, 0);
          A(r.ticks === 4, "ticks: 1000ms@4x = 4 ticks", r);
          A(r.remainder === 0, "ticks: 4x remainder = 0", r);
        })();

        (function testTicks_slowSpeed() {
          // 1000ms at speed=0.5 => 0 ticks, 1000 remainder (interval=2000ms).
          const r = playbackTicksForElapsed(1000, 0.5, 0);
          A(r.ticks === 0, "ticks: 1000ms@0.5x = 0 ticks", r);
          A(Math.abs(r.remainder - 1000) < 0.01, "ticks: 0.5x remainder = 1000", r);
        })();

        (function testTicks_slowSpeedCrossThreshold() {
          // 2500ms at speed=0.5 => 1 tick (interval=2000ms), 500ms remainder.
          const r = playbackTicksForElapsed(2500, 0.5, 0);
          A(r.ticks === 1, "ticks: 2500ms@0.5x = 1 tick", r);
          A(Math.abs(r.remainder - 500) < 0.01, "ticks: 0.5x remainder = 500", r);
        })();

        (function testTicks_zeroElapsed() {
          const r = playbackTicksForElapsed(0, 1, 0);
          A(r.ticks === 0, "ticks: 0ms = 0 ticks", r);
          A(r.remainder === 0, "ticks: 0ms remainder = 0", r);
        })();

        (function testTicks_quarterSpeed() {
          // 4000ms at speed=0.25 => 1 tick (interval=4000ms).
          const r = playbackTicksForElapsed(4000, 0.25, 0);
          A(r.ticks === 1, "ticks: 4000ms@0.25x = 1 tick", r);
        })();

        (function testTicks_multipleTicks() {
          // 5500ms at speed=2 => 11 ticks (interval=500ms), 0 remainder.
          const r = playbackTicksForElapsed(5500, 2, 0);
          A(r.ticks === 11, "ticks: 5500ms@2x = 11 ticks", r);
          A(r.remainder === 0, "ticks: 5500ms@2x remainder = 0", r);
        })();

        // --- playbackNextIndex ---
        (function testNext_basic() {
          const r = playbackNextIndex(5, 1, 100, false);
          A(r.idx === 6, "next: 5+1 = 6", r);
          A(r.stopped === false, "next: not stopped", r);
        })();

        (function testNext_clampAtMax() {
          const r = playbackNextIndex(98, 5, 100, false);
          A(r.idx === 100, "next: 98+5 clamped to 100", r);
          A(r.stopped === true, "next: stopped at max", r);
        })();

        (function testNext_loopWrap() {
          const r = playbackNextIndex(98, 5, 100, true);
          A(r.idx === 2, "next: 98+5 loops to 2 (mod 101)", r);
          A(r.stopped === false, "next: loop no stop", r);
        })();

        (function testNext_zeroTicks() {
          const r = playbackNextIndex(50, 0, 100, false);
          A(r.idx === 50, "next: 0 ticks = same idx", r);
          A(r.stopped === false, "next: 0 ticks not stopped", r);
        })();

        (function testNext_exactMax() {
          const r = playbackNextIndex(99, 1, 100, false);
          A(r.idx === 100, "next: 99+1 = 100 (max)", r);
          A(r.stopped === true, "next: stopped at exact max", r);
        })();

        (function testNext_loopFromMax() {
          const r = playbackNextIndex(100, 1, 100, true);
          A(r.idx === 0, "next: 100+1 loops to 0", r);
          A(r.stopped === false, "next: loop from max", r);
        })();

        (function testNext_largeTicks() {
          const r = playbackNextIndex(0, 500, 100, true);
          A(r.idx === 500 % 101, "next: 0+500 loops mod 101 = " + (500 % 101), r);
        })();

        // --- playbackTransition (state machine) ---
        (function testTransition_pausedPlay() {
          A(playbackTransition("paused", "play") === "playing", "trans: paused+play->playing");
        })();

        (function testTransition_pausedSeek() {
          A(playbackTransition("paused", "seek") === "seeking", "trans: paused+seek->seeking");
        })();

        (function testTransition_pausedPause() {
          A(playbackTransition("paused", "pause") === null, "trans: paused+pause->null");
        })();

        (function testTransition_playingPause() {
          A(playbackTransition("playing", "pause") === "paused", "trans: playing+pause->paused");
        })();

        (function testTransition_playingSeek() {
          A(playbackTransition("playing", "seek") === "seeking", "trans: playing+seek->seeking");
        })();

        (function testTransition_playingStop() {
          A(playbackTransition("playing", "stop") === "paused", "trans: playing+stop->paused");
        })();

        (function testTransition_playingEnd() {
          A(playbackTransition("playing", "end") === "paused", "trans: playing+end->paused");
        })();

        (function testTransition_seekingStop() {
          A(playbackTransition("seeking", "stop") === "paused", "trans: seeking+stop->paused");
        })();

        (function testTransition_seekingResume() {
          // Resume depends on PLAYBACK._preSeekState.
          const orig = PLAYBACK._preSeekState;
          PLAYBACK._preSeekState = "playing";
          A(playbackTransition("seeking", "resume") === "playing", "trans: seeking+resume(was playing)->playing");
          PLAYBACK._preSeekState = "paused";
          A(playbackTransition("seeking", "resume") === "paused", "trans: seeking+resume(was paused)->paused");
          PLAYBACK._preSeekState = orig;
        })();

        (function testTransition_invalidAction() {
          A(playbackTransition("paused", "resume") === null, "trans: paused+resume->null");
          A(playbackTransition("playing", "play") === null, "trans: playing+play->null");
          A(playbackTransition("seeking", "play") === null, "trans: seeking+play->null");
        })();

        (function testTransition_invalidState() {
          A(playbackTransition("bogus", "play") === null, "trans: bogus+play->null");
        })();

        // --- Drift correction simulation ---
        (function testDrift_sequence() {
          // Simulate a sequence of frames with jittery timing.
          const speed = 2; // 500ms interval
          let accum = 0;
          let idx = 0;
          const maxIdx = 20;
          const frames = [450, 550, 480, 520, 510, 490, 500, 500, 500]; // ~500ms avg
          const idxHistory = [idx];
          for (const elapsed of frames) {
            const { ticks, remainder } = playbackTicksForElapsed(elapsed, speed, accum);
            accum = remainder;
            if (ticks > 0) {
              const { idx: next } = playbackNextIndex(idx, ticks, maxIdx, false);
              idx = next;
            }
            idxHistory.push(idx);
          }
          console.log("  [Drift] idx history:", idxHistory.join(","), "final accum:", accum.toFixed(1) + "ms");
          const totalElapsed = frames.reduce((a, b) => a + b, 0);
          const expectedTicks = Math.floor(totalElapsed / 500);
          A(idx === expectedTicks, "drift: total advancement matches expected", { idx, expectedTicks, totalElapsed });
          A(accum < 500, "drift: accumulator < interval", { accum });
        })();

        // --- Loop boundary ---
        (function testLoop_boundary() {
          const maxIdx = 10;
          // One tick past max with loop.
          let r = playbackNextIndex(10, 1, maxIdx, true);
          A(r.idx === 0, "loop-boundary: max+1 wraps to 0", r);
          // Exactly at max, no ticks.
          r = playbackNextIndex(10, 0, maxIdx, true);
          A(r.idx === 10, "loop-boundary: max+0 stays", r);
          // Two ticks past max.
          r = playbackNextIndex(10, 2, maxIdx, true);
          A(r.idx === 1, "loop-boundary: max+2 wraps to 1", r);
          // No loop: clamp.
          r = playbackNextIndex(10, 1, maxIdx, false);
          A(r.idx === 10, "loop-boundary: no-loop max+1 clamped", r);
          A(r.stopped === true, "loop-boundary: stopped at clamp", r);
        })();

        // --- PLAYBACK_SPEEDS constant ---
        (function testSpeeds() {
          A(Array.isArray(PLAYBACK_SPEEDS), "speeds: is array");
          A(PLAYBACK_SPEEDS.length >= 3, "speeds: at least 3 options", { len: PLAYBACK_SPEEDS.length });
          A(PLAYBACK_SPEEDS.includes(1), "speeds: includes 1x");
          A(PLAYBACK_SPEEDS[0] < 1, "speeds: first < 1 (slow)");
          A(PLAYBACK_SPEEDS[PLAYBACK_SPEEDS.length - 1] > 1, "speeds: last > 1 (fast)");
        })();

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Playback Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Playback Unit Tests ----
      // ---- Binning Unit Tests (bd-24q.12.3) ----
      // Run via console: window.__runBinningTests()
      window.__runBinningTests = function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || "") };

        // --- wallClockBinMinutes ---
        (function testBinMinutes() {
          A(wallClockBinMinutes("day") === 1440, "binMin: day=1440");
          A(wallClockBinMinutes("hour") === 60, "binMin: hour=60");
          A(wallClockBinMinutes("15m") === 15, "binMin: 15m=15");
          A(wallClockBinMinutes("5m") === 5, "binMin: 5m=5");
          A(wallClockBinMinutes("minute") === 1, "binMin: default=1");
          A(wallClockBinMinutes("commit") === 1, "binMin: commit=1 (default)");
        })();

        // --- wallClockBinKey format ---
        (function testBinKey_day() {
          const t = dayjs("2025-03-09T14:37:00");
          A(wallClockBinKey(t, "day") === "2025-03-09", "binKey: day format", { got: wallClockBinKey(t, "day") });
        })();

        (function testBinKey_hour() {
          const t = dayjs("2025-03-09T14:37:00");
          A(wallClockBinKey(t, "hour") === "2025-03-09 14:00", "binKey: hour format", { got: wallClockBinKey(t, "hour") });
        })();

        (function testBinKey_15m() {
          const t = dayjs("2025-03-09T14:37:00");
          A(wallClockBinKey(t, "15m") === "2025-03-09 14:30", "binKey: 15m floors to :30", { got: wallClockBinKey(t, "15m") });
        })();

        (function testBinKey_15m_exact() {
          const t = dayjs("2025-03-09T14:45:00");
          A(wallClockBinKey(t, "15m") === "2025-03-09 14:45", "binKey: 15m exact :45", { got: wallClockBinKey(t, "15m") });
        })();

        (function testBinKey_5m() {
          const t = dayjs("2025-03-09T14:37:00");
          A(wallClockBinKey(t, "5m") === "2025-03-09 14:35", "binKey: 5m floors to :35", { got: wallClockBinKey(t, "5m") });
        })();

        (function testBinKey_5m_exact() {
          const t = dayjs("2025-03-09T14:00:00");
          A(wallClockBinKey(t, "5m") === "2025-03-09 14:00", "binKey: 5m exact :00", { got: wallClockBinKey(t, "5m") });
        })();

        (function testBinKey_minute() {
          const t = dayjs("2025-03-09T14:37:22");
          A(wallClockBinKey(t, "minute") === "2025-03-09 14:37", "binKey: minute format", { got: wallClockBinKey(t, "minute") });
        })();

        // --- wallClockFloor ---
        (function testFloor_day() {
          const t = dayjs("2025-06-15T23:59:59");
          const f = wallClockFloor(t, "day");
          A(f.hour() === 0 && f.minute() === 0, "floor: day zeros time", { h: f.hour(), m: f.minute() });
          A(f.date() === 15, "floor: day preserves date", { got: f.date() });
        })();

        (function testFloor_hour() {
          const t = dayjs("2025-06-15T14:47:33");
          const f = wallClockFloor(t, "hour");
          A(f.hour() === 14 && f.minute() === 0, "floor: hour zeros minutes", { h: f.hour(), m: f.minute() });
        })();

        (function testFloor_15m() {
          const t = dayjs("2025-06-15T14:47:33");
          const f = wallClockFloor(t, "15m");
          A(f.hour() === 14 && f.minute() === 45, "floor: 15m -> :45", { h: f.hour(), m: f.minute() });
        })();

        (function testFloor_15m_boundary() {
          const t = dayjs("2025-06-15T14:14:59");
          const f = wallClockFloor(t, "15m");
          A(f.minute() === 0, "floor: 15m 14:14->14:00", { m: f.minute() });
        })();

        (function testFloor_5m() {
          const t = dayjs("2025-06-15T14:47:33");
          const f = wallClockFloor(t, "5m");
          A(f.hour() === 14 && f.minute() === 45, "floor: 5m -> :45", { h: f.hour(), m: f.minute() });
        })();

        (function testFloor_5m_exact() {
          const t = dayjs("2025-06-15T14:43:00");
          const f = wallClockFloor(t, "5m");
          A(f.minute() === 40, "floor: 5m 14:43->14:40", { m: f.minute() });
        })();

        // --- buildWallClockBins: commit mode returns null ---
        (function testBuild_commitMode() {
          const result = buildWallClockBins([{ dateIso: "2025-01-01T00:00:00Z" }], "commit", "utc");
          A(result === null, "build: commit mode returns null");
        })();

        // --- buildWallClockBins: empty array returns null ---
        (function testBuild_empty() {
          const result = buildWallClockBins([], "hour", "utc");
          A(result === null, "build: empty array returns null");
        })();

        // --- buildWallClockBins: single commit ---
        (function testBuild_singleCommit() {
          const commits = [{ dateIso: "2025-06-15T14:30:00Z" }];
          const result = buildWallClockBins(commits, "hour", "utc");
          A(result !== null, "build: single commit not null");
          A(result.labels.length === 1, "build: single commit = 1 bin", { got: result.labels.length });
          A(result.bins[0].commits.length === 1, "build: single commit in bin");
        })();

        // --- buildWallClockBins: empty bins between sparse commits ---
        (function testBuild_emptyBinsHour() {
          const commits = [
            { dateIso: "2025-06-15T10:00:00Z" },
            { dateIso: "2025-06-15T13:30:00Z" },
          ];
          const result = buildWallClockBins(commits, "hour", "utc");
          A(result.labels.length === 4, "build: 4 hourly bins for 10-13", { got: result.labels.length, labels: result.labels });
          A(result.bins[0].commits.length === 1, "build: first bin has 1 commit");
          A(result.bins[1].commits.length === 0, "build: 11:00 bin is empty");
          A(result.bins[2].commits.length === 0, "build: 12:00 bin is empty");
          A(result.bins[3].commits.length === 1, "build: 13:00 bin has 1 commit");
        })();

        // --- buildWallClockBins: empty bins between sparse commits (day) ---
        (function testBuild_emptyBinsDay() {
          const commits = [
            { dateIso: "2025-06-10T12:00:00Z" },
            { dateIso: "2025-06-13T12:00:00Z" },
          ];
          const result = buildWallClockBins(commits, "day", "utc");
          A(result.labels.length === 4, "build: 4 daily bins for June 10-13", { got: result.labels.length, labels: result.labels });
          A(result.bins[0].commits.length === 1, "build: June 10 has 1");
          A(result.bins[1].commits.length === 0, "build: June 11 empty");
          A(result.bins[2].commits.length === 0, "build: June 12 empty");
          A(result.bins[3].commits.length === 1, "build: June 13 has 1");
        })();

        // --- buildWallClockBins: multiple commits in same bin ---
        (function testBuild_multiplePerBin() {
          const commits = [
            { dateIso: "2025-06-15T14:05:00Z" },
            { dateIso: "2025-06-15T14:12:00Z" },
            { dateIso: "2025-06-15T14:50:00Z" },
          ];
          const result = buildWallClockBins(commits, "hour", "utc");
          A(result.labels.length === 1, "build: all in same hour bin", { got: result.labels.length });
          A(result.bins[0].commits.length === 3, "build: 3 commits in bin");
        })();

        // --- buildWallClockBins: 5m resolution correct assignment ---
        (function testBuild_5mResolution() {
          const commits = [
            { dateIso: "2025-06-15T14:00:00Z" },
            { dateIso: "2025-06-15T14:03:00Z" },
            { dateIso: "2025-06-15T14:07:00Z" },
            { dateIso: "2025-06-15T14:10:00Z" },
          ];
          const result = buildWallClockBins(commits, "5m", "utc");
          A(result.labels.length === 3, "build: 3 five-min bins", { got: result.labels.length, labels: result.labels });
          A(result.bins[0].commits.length === 2, "build: 14:00 bin has 2 (00 + 03)");
          A(result.bins[1].commits.length === 1, "build: 14:05 bin has 1 (07)");
          A(result.bins[2].commits.length === 1, "build: 14:10 bin has 1");
        })();

        // --- buildWallClockBins: UTC vs local mode ---
        (function testBuild_utcMode() {
          const commits = [{ dateIso: "2025-06-15T23:30:00Z" }];
          const resultUtc = buildWallClockBins(commits, "hour", "utc");
          A(resultUtc !== null && resultUtc.labels[0].includes("23:00"), "build: UTC key shows 23:00", { got: resultUtc?.labels[0] });
        })();

        (function testBuild_localMode() {
          const commits = [{ dateIso: "2025-06-15T23:30:00Z" }];
          const resultLocal = buildWallClockBins(commits, "hour", "local");
          A(resultLocal !== null && resultLocal.labels.length === 1, "build: local mode produces 1 bin");
          A(resultLocal.labels[0].includes(":00"), "build: local key has :00 hour mark", { got: resultLocal.labels[0] });
        })();

        // --- buildWallClockBins: DST spring-forward (UTC unaffected) ---
        (function testBuild_dstSpringForwardUtc() {
          const commits = [
            { dateIso: "2025-03-09T06:00:00Z" },
            { dateIso: "2025-03-09T09:00:00Z" },
          ];
          const result = buildWallClockBins(commits, "hour", "utc");
          A(result.labels.length === 4, "build: DST spring UTC = 4 continuous hour bins", { got: result.labels.length, labels: result.labels });
        })();

        // --- buildWallClockBins: DST fall-back (UTC unaffected) ---
        (function testBuild_dstFallBackUtc() {
          const commits = [
            { dateIso: "2025-11-02T05:00:00Z" },
            { dateIso: "2025-11-02T08:00:00Z" },
          ];
          const result = buildWallClockBins(commits, "hour", "utc");
          A(result.labels.length === 4, "build: DST fall-back UTC = 4 continuous hour bins", { got: result.labels.length, labels: result.labels });
        })();

        // --- buildWallClockBins: day bins across DST transition (UTC) ---
        (function testBuild_dstDayBinsUtc() {
          const commits = [
            { dateIso: "2025-03-08T12:00:00Z" },
            { dateIso: "2025-03-10T12:00:00Z" },
          ];
          const result = buildWallClockBins(commits, "day", "utc");
          A(result.labels.length === 3, "build: DST day bins UTC = 3", { got: result.labels.length, labels: result.labels });
          A(result.labels[0] === "2025-03-08", "build: DST day label 0");
          A(result.labels[1] === "2025-03-09", "build: DST day label 1");
          A(result.labels[2] === "2025-03-10", "build: DST day label 2");
        })();

        // --- buildWallClockBins: label format consistency ---
        (function testBuild_labelConsistency() {
          const commits = [
            { dateIso: "2025-06-15T14:00:00Z" },
            { dateIso: "2025-06-15T14:20:00Z" },
          ];
          const result = buildWallClockBins(commits, "15m", "utc");
          A(result.labels.length === 2, "build: 15m labels count", { got: result.labels.length });
          const pat = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/;
          A(pat.test(result.labels[0]), "build: 15m label 0 format", { got: result.labels[0] });
          A(pat.test(result.labels[1]), "build: 15m label 1 format", { got: result.labels[1] });
        })();

        // --- aggregateBinMetric: sum ---
        (function testAgg_sum() {
          const commits = [{ v: 10 }, { v: 20 }, { v: 30 }];
          const result = aggregateBinMetric(commits, (c) => c.v, "sum");
          A(result === 60, "agg: sum = 60", { got: result });
        })();

        // --- aggregateBinMetric: mean ---
        (function testAgg_mean() {
          const commits = [{ v: 10 }, { v: 20 }, { v: 30 }];
          const result = aggregateBinMetric(commits, (c) => c.v, "mean");
          A(Math.abs(result - 20) < 0.001, "agg: mean = 20", { got: result });
        })();

        // --- aggregateBinMetric: median odd ---
        (function testAgg_medianOdd() {
          const commits = [{ v: 30 }, { v: 10 }, { v: 20 }];
          const result = aggregateBinMetric(commits, (c) => c.v, "median");
          A(result === 20, "agg: median odd = 20", { got: result });
        })();

        // --- aggregateBinMetric: median even ---
        (function testAgg_medianEven() {
          const commits = [{ v: 10 }, { v: 20 }, { v: 30 }, { v: 40 }];
          const result = aggregateBinMetric(commits, (c) => c.v, "median");
          A(result === 25, "agg: median even = 25", { got: result });
        })();

        // --- aggregateBinMetric: empty array ---
        (function testAgg_empty() {
          const result = aggregateBinMetric([], (c) => c.v, "sum");
          A(result === 0, "agg: empty = 0", { got: result });
        })();

        // --- aggregateBinMetric: single element ---
        (function testAgg_single() {
          A(aggregateBinMetric([{ v: 42 }], (c) => c.v, "sum") === 42, "agg: single sum = 42");
          A(aggregateBinMetric([{ v: 42 }], (c) => c.v, "mean") === 42, "agg: single mean = 42");
          A(aggregateBinMetric([{ v: 42 }], (c) => c.v, "median") === 42, "agg: single median = 42");
        })();

        // --- aggregateBinMetric: default mode is sum ---
        (function testAgg_defaultMode() {
          const commits = [{ v: 10 }, { v: 20 }];
          const result = aggregateBinMetric(commits, (c) => c.v, "unknown_mode");
          A(result === 30, "agg: unknown mode defaults to sum = 30", { got: result });
        })();

        // --- aggregateBinMetric: median with duplicate values ---
        (function testAgg_medianDuplicates() {
          const commits = [{ v: 5 }, { v: 5 }, { v: 5 }, { v: 100 }, { v: 100 }];
          const result = aggregateBinMetric(commits, (c) => c.v, "median");
          A(result === 5, "agg: median duplicates = 5", { got: result });
        })();

        // --- Integration: buildWallClockBins + aggregateBinMetric ---
        (function testIntegration_buildThenAggregate() {
          const commits = [
            { dateIso: "2025-06-15T10:05:00Z", lines: 100 },
            { dateIso: "2025-06-15T10:55:00Z", lines: 200 },
            { dateIso: "2025-06-15T11:30:00Z", lines: 50 },
          ];
          const result = buildWallClockBins(commits, "hour", "utc");
          A(result.bins.length === 2, "integ: 2 hourly bins");
          const sum0 = aggregateBinMetric(result.bins[0].commits, (c) => c.lines, "sum");
          const sum1 = aggregateBinMetric(result.bins[1].commits, (c) => c.lines, "sum");
          A(sum0 === 300, "integ: hour 10 sum = 300", { got: sum0 });
          A(sum1 === 50, "integ: hour 11 sum = 50", { got: sum1 });
          const mean0 = aggregateBinMetric(result.bins[0].commits, (c) => c.lines, "mean");
          A(Math.abs(mean0 - 150) < 0.001, "integ: hour 10 mean = 150", { got: mean0 });
        })();

        // --- wallClockBinKey: edge case minute=0 padding ---
        (function testBinKey_zeroPadding() {
          const t = dayjs("2025-01-01T00:00:00");
          A(wallClockBinKey(t, "5m") === "2025-01-01 00:00", "binKey: zero-padded 00:00", { got: wallClockBinKey(t, "5m") });
          A(wallClockBinKey(t, "15m") === "2025-01-01 00:00", "binKey: 15m zero-padded 00:00", { got: wallClockBinKey(t, "15m") });
        })();

        // --- wallClockFloor: minute resolution ---
        (function testFloor_minute() {
          const t = dayjs("2025-06-15T14:37:45");
          const f = wallClockFloor(t, "minute");
          A(f.second() === 0, "floor: minute zeros seconds", { s: f.second() });
          A(f.minute() === 37, "floor: minute preserves minute", { m: f.minute() });
        })();

        // --- buildWallClockBins: maxBins safety (10000 limit) ---
        (function testBuild_maxBinsSafety() {
          const commits = [
            { dateIso: "2025-01-01T00:00:00Z" },
            { dateIso: "2025-12-31T23:59:00Z" },
          ];
          const result = buildWallClockBins(commits, "5m", "utc");
          A(result.bins.length <= 10000, "build: maxBins capped at 10000", { got: result.bins.length });
        })();

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Binning Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Binning Unit Tests ----
      // ---- Binning E2E Tests (bd-24q.12.4) ----
      // Run via console: window.__runBinningE2ETests()
      // Requires dataset to be loaded.
      window.__runBinningE2ETests = async function () {
        const R = [];
        const log = (msg, ctx) => console.log("  [BIN-E2E]", msg, ctx || "");
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("  FAIL:", m, x || ""); else log("PASS: " + m); };
        const wait = (ms) => new Promise((r) => setTimeout(r, ms));

        if (!DATASET.loaded || ALL_COMMITS.length < 5) {
          console.error("BIN-E2E: Need loaded dataset with >= 5 commits.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded or < 5 commits" }] };
        }

        const resSel = document.getElementById("stackResolution");
        const tzSel = document.getElementById("stackTimezone");
        const metSel = document.getElementById("stackMetric");
        if (!resSel || !tzSel || !metSel) {
          console.error("BIN-E2E: Missing select elements (stackResolution, stackTimezone, stackMetric).");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Missing binning select elements" }] };
        }

        // Save original select values.
        const origRes = resSel.value;
        const origTz = tzSel.value;
        const origMet = metSel.value;

        const getChartLabels = () => {
          if (!chartStack) return [];
          const opt = chartStack.getOption();
          return opt?.xAxis?.[0]?.data || [];
        };

        // --- E2E 1: Toggle commit -> day; x-axis labels change + bin count differs ---
        await (async function testE2E_commitToDay() {
          log("Setting resolution to commit...");
          resSel.value = "commit";
          resSel.dispatchEvent(new Event("change"));
          await wait(400);
          const commitLabels = getChartLabels();
          const commitCount = commitLabels.length;
          log("Commit mode: " + commitCount + " bins, first=" + commitLabels[0] + ", last=" + commitLabels[commitLabels.length - 1]);

          log("Switching to day...");
          resSel.value = "day";
          resSel.dispatchEvent(new Event("change"));
          await wait(400);
          const dayLabels = getChartLabels();
          const dayCount = dayLabels.length;
          log("Day mode: " + dayCount + " bins, first=" + dayLabels[0] + ", last=" + dayLabels[dayLabels.length - 1]);

          A(dayCount !== commitCount, "e2e: day bin count differs from commit count", { commitCount, dayCount });
          A(dayLabels[0] !== commitLabels[0], "e2e: day labels differ from commit labels", { dayFirst: dayLabels[0], commitFirst: commitLabels[0] });
          // Day labels should look like YYYY-MM-DD.
          const dayPat = /^\d{4}-\d{2}-\d{2}$/;
          A(dayPat.test(dayLabels[0]), "e2e: day label format is YYYY-MM-DD", { got: dayLabels[0] });
        })();

        // --- E2E 2: Toggle resolution day -> hour; bin count increases ---
        await (async function testE2E_dayToHour() {
          resSel.value = "day";
          resSel.dispatchEvent(new Event("change"));
          await wait(400);
          const dayCount = getChartLabels().length;

          resSel.value = "hour";
          resSel.dispatchEvent(new Event("change"));
          await wait(400);
          const hourLabels = getChartLabels();
          const hourCount = hourLabels.length;
          log("Hour mode: " + hourCount + " bins (day was " + dayCount + ")");

          A(hourCount >= dayCount, "e2e: hour bin count >= day bin count", { hourCount, dayCount });
          // Hour labels should include time component.
          const hourPat = /^\d{4}-\d{2}-\d{2} \d{2}:00$/;
          A(hourPat.test(hourLabels[0]), "e2e: hour label format is YYYY-MM-DD HH:00", { got: hourLabels[0] });
        })();

        // --- E2E 3: Toggle timezone UTC -> local; labels update ---
        await (async function testE2E_tzToggle() {
          resSel.value = "hour";
          resSel.dispatchEvent(new Event("change"));
          await wait(200);

          tzSel.value = "utc";
          tzSel.dispatchEvent(new Event("change"));
          await wait(400);
          const utcLabels = getChartLabels().slice();
          log("UTC hour labels: first=" + utcLabels[0] + ", count=" + utcLabels.length);

          tzSel.value = "local";
          tzSel.dispatchEvent(new Event("change"));
          await wait(400);
          const localLabels = getChartLabels().slice();
          log("Local hour labels: first=" + localLabels[0] + ", count=" + localLabels.length);

          // In non-UTC-0 environments, labels will differ. In UTC-0, they'll match.
          // We can't know the timezone, so just check both produce valid labels.
          A(utcLabels.length > 0, "e2e: UTC mode produces labels");
          A(localLabels.length > 0, "e2e: Local mode produces labels");
          // Both should have time format.
          const pat = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/;
          A(pat.test(utcLabels[0]), "e2e: UTC label is valid datetime", { got: utcLabels[0] });
          A(pat.test(localLabels[0]), "e2e: Local label is valid datetime", { got: localLabels[0] });
          log("UTC vs local labels differ: " + (utcLabels[0] !== localLabels[0]));
        })();

        // --- E2E 4: Metric toggle changes y-axis values ---
        await (async function testE2E_metricToggle() {
          resSel.value = "day";
          resSel.dispatchEvent(new Event("change"));
          await wait(200);

          metSel.value = "groups";
          metSel.dispatchEvent(new Event("change"));
          await wait(400);
          const opt1 = chartStack.getOption();
          const series1 = opt1?.series || [];
          const total1 = series1.reduce((s, sr) => s + (sr.data || []).reduce((a, b) => a + (Number(b) || 0), 0), 0);

          metSel.value = "lines";
          metSel.dispatchEvent(new Event("change"));
          await wait(400);
          const opt2 = chartStack.getOption();
          const series2 = opt2?.series || [];
          const total2 = series2.reduce((s, sr) => s + (sr.data || []).reduce((a, b) => a + (Number(b) || 0), 0), 0);

          log("Metric groups total: " + total1.toFixed(1) + ", lines total: " + total2.toFixed(1));
          A(total1 > 0, "e2e: groups metric has data");
          A(total2 > 0, "e2e: lines metric has data");
          // Groups and lines should differ (groups counts changeGroups, lines counts impact).
          A(Math.abs(total1 - total2) > 0.1, "e2e: groups vs lines totals differ", { groups: total1, lines: total2 });
        })();

        // --- E2E 5: URL round-trip preserves resolution, timezone, metric ---
        await (async function testE2E_urlRoundTrip() {
          resSel.value = "15m";
          tzSel.value = "utc";
          metSel.value = "tokens";
          resSel.dispatchEvent(new Event("change"));
          await wait(200);

          const encoded = encodeUrlState();
          log("Encoded URL: " + encoded);
          A(encoded.includes("res=15m"), "e2e: URL contains res=15m", { got: encoded });
          A(encoded.includes("tz=utc"), "e2e: URL contains tz=utc", { got: encoded });
          A(encoded.includes("met=tokens"), "e2e: URL contains met=tokens", { got: encoded });

          // Reset to defaults.
          resSel.value = "commit";
          tzSel.value = "local";
          metSel.value = "groups";

          // Decode and apply.
          const decoded = decodeUrlState(encoded);
          A(decoded.res === "15m", "e2e: decoded res=15m", { got: decoded.res });
          A(decoded.tz === "utc", "e2e: decoded tz=utc", { got: decoded.tz });
          A(decoded.met === "tokens", "e2e: decoded met=tokens", { got: decoded.met });

          applyUrlState(decoded);
          A(resSel.value === "15m", "e2e: resSel restored to 15m", { got: resSel.value });
          A(tzSel.value === "utc", "e2e: tzSel restored to utc", { got: tzSel.value });
          A(metSel.value === "tokens", "e2e: metSel restored to tokens", { got: metSel.value });
        })();

        // --- E2E 6: Default values omitted from URL ---
        await (async function testE2E_defaultsOmitted() {
          resSel.value = "commit";
          tzSel.value = "local";
          metSel.value = "groups";
          resSel.dispatchEvent(new Event("change"));
          await wait(200);

          const encoded = encodeUrlState();
          log("Default state URL: " + encoded);
          A(!encoded.includes("res="), "e2e: default res omitted from URL", { got: encoded });
          A(!encoded.includes("tz="), "e2e: default tz omitted from URL", { got: encoded });
          A(!encoded.includes("met="), "e2e: default met omitted from URL", { got: encoded });
        })();

        // --- E2E 7: Empty bins visible in chart data ---
        await (async function testE2E_emptyBinsInChart() {
          resSel.value = "hour";
          resSel.dispatchEvent(new Event("change"));
          await wait(400);
          const labels = getChartLabels();
          const opt = chartStack.getOption();
          const firstSeries = (opt?.series || [])[0]?.data || [];

          // Count how many bins have zero across all series.
          let emptyCount = 0;
          for (let i = 0; i < labels.length; i++) {
            const total = (opt?.series || []).reduce((s, sr) => s + (Number(sr.data?.[i]) || 0), 0);
            if (total === 0) emptyCount++;
          }
          log("Hour bins: " + labels.length + " total, " + emptyCount + " empty, first=" + labels[0] + ", last=" + labels[labels.length - 1]);
          // With real data spanning multiple days, there should be empty hour bins.
          A(labels.length > 0, "e2e: hour mode has bins");
          // If the data spans more than a day, we expect some empty bins.
          if (labels.length > 24) {
            A(emptyCount > 0, "e2e: hour mode has empty bins between activity", { emptyCount, total: labels.length });
          } else {
            log("Dataset spans <= 24 hour bins, empty bins not guaranteed");
          }
        })();

        // --- Restore original state ---
        resSel.value = origRes;
        tzSel.value = origTz;
        metSel.value = origMet;
        resSel.dispatchEvent(new Event("change"));
        await wait(200);
        log("Restored original state: res=" + origRes + ", tz=" + origTz + ", met=" + origMet);

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Binning E2E Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Binning E2E Tests ----
      // ---- Side-by-Side Unit Tests (bd-24q.15.4) ----
      // Run via console: window.__runSbsTests()
      window.__runSbsTests = function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || "") };

        // --- normalizeHeadingText ---
        (function testNorm_basic() {
          A(normalizeHeadingText("Hello World") === "hello world", "norm: basic lowercase");
        })();

        (function testNorm_punctuation() {
          A(normalizeHeadingText("Hello, World! (v2.0)") === "hello world v2 0", "norm: strips punctuation", { got: normalizeHeadingText("Hello, World! (v2.0)") });
        })();

        (function testNorm_unicode() {
          const r = normalizeHeadingText("Section 日本語 heading");
          A(r.includes("section"), "norm: preserves unicode letters", { got: r });
          A(r.includes("日本語"), "norm: preserves CJK", { got: r });
        })();

        (function testNorm_empty() {
          A(normalizeHeadingText("") === "", "norm: empty string");
          A(normalizeHeadingText(null) === "", "norm: null");
          A(normalizeHeadingText(undefined) === "", "norm: undefined");
        })();

        (function testNorm_whitespace() {
          A(normalizeHeadingText("  lots   of   spaces  ") === "lots of spaces", "norm: collapses whitespace", { got: normalizeHeadingText("  lots   of   spaces  ") });
        })();

        (function testNorm_codeBackticks() {
          const r = normalizeHeadingText("`code_heading`");
          A(r === "code heading", "norm: backticks become space, underscore becomes space", { got: r });
        })();

        (function testNorm_numbers() {
          A(normalizeHeadingText("Section 5.3.1") === "section 5 3 1", "norm: preserves numbers", { got: normalizeHeadingText("Section 5.3.1") });
        })();

        // --- buildHeadingMatchMap: exact matches ---
        (function testMatch_exactSimple() {
          const oA = [
            { id: "intro", text: "Introduction", level: 2 },
            { id: "methods", text: "Methods", level: 2 },
            { id: "results", text: "Results", level: 2 },
          ];
          const oB = [
            { id: "intro", text: "Introduction", level: 2 },
            { id: "methods", text: "Methods", level: 2 },
            { id: "conclusion", text: "Conclusion", level: 2 },
          ];
          const { matchAtoB, matchBtoA } = buildHeadingMatchMap(oA, oB, "a-", "b-");
          A(matchAtoB.get("a-intro") === "b-intro", "match: intro exact", { got: matchAtoB.get("a-intro") });
          A(matchAtoB.get("a-methods") === "b-methods", "match: methods exact", { got: matchAtoB.get("a-methods") });
          A(!matchAtoB.has("a-results"), "match: results has no match in B");
          A(!matchBtoA.has("b-conclusion"), "match: conclusion has no match in A");
          // Bidirectional consistency.
          A(matchBtoA.get("b-intro") === "a-intro", "match: reverse intro");
          A(matchBtoA.get("b-methods") === "a-methods", "match: reverse methods");
        })();

        // --- buildHeadingMatchMap: level must match ---
        (function testMatch_levelMismatch() {
          const oA = [{ id: "title", text: "Introduction", level: 1 }];
          const oB = [{ id: "title", text: "Introduction", level: 2 }];
          const { matchAtoB } = buildHeadingMatchMap(oA, oB, "a-", "b-");
          A(!matchAtoB.has("a-title"), "match: level mismatch blocks exact match");
        })();

        // --- buildHeadingMatchMap: duplicate headings (first match wins) ---
        (function testMatch_duplicates() {
          const oA = [
            { id: "sec", text: "Section", level: 2 },
            { id: "sec-1", text: "Section", level: 2 },
          ];
          const oB = [
            { id: "sec", text: "Section", level: 2 },
            { id: "sec-1", text: "Section", level: 2 },
          ];
          const { matchAtoB } = buildHeadingMatchMap(oA, oB, "a-", "b-");
          A(matchAtoB.get("a-sec") === "b-sec", "match: first dup matches first", { got: matchAtoB.get("a-sec") });
          A(matchAtoB.get("a-sec-1") === "b-sec-1", "match: second dup matches second", { got: matchAtoB.get("a-sec-1") });
        })();

        // --- buildHeadingMatchMap: fuzzy matching (prefix >= 60%) ---
        (function testMatch_fuzzy() {
          const oA = [{ id: "mvcc-page-versioning", text: "MVCC Page-Level Versioning", level: 2 }];
          const oB = [{ id: "mvcc-page-versioning-impl", text: "MVCC Page-Level Versioning Implementation", level: 2 }];
          const { matchAtoB } = buildHeadingMatchMap(oA, oB, "a-", "b-");
          // "mvcc page level versioning" is a prefix of "mvcc page level versioning implementation"
          // prefix ratio = 27/41 ≈ 0.66 >= 0.6, so should match.
          A(matchAtoB.has("a-mvcc-page-versioning"), "match: fuzzy prefix matches", { got: matchAtoB.get("a-mvcc-page-versioning") });
        })();

        // --- buildHeadingMatchMap: fuzzy too short ---
        (function testMatch_fuzzyTooShort() {
          const oA = [{ id: "ab", text: "AB", level: 2 }];
          const oB = [{ id: "abcdefghijklmnop", text: "ABCDEFGHIJKLMNOP", level: 2 }];
          const { matchAtoB } = buildHeadingMatchMap(oA, oB, "a-", "b-");
          // "ab" vs "abcdefghijklmnop": prefix ratio = 2/16 = 0.125 < 0.6
          A(!matchAtoB.has("a-ab"), "match: fuzzy below threshold rejected");
        })();

        // --- buildHeadingMatchMap: empty outlines ---
        (function testMatch_emptyOutlines() {
          const { matchAtoB } = buildHeadingMatchMap([], [], "a-", "b-");
          A(matchAtoB.size === 0, "match: empty outlines = empty map");
        })();

        (function testMatch_oneEmpty() {
          const oA = [{ id: "x", text: "Something", level: 2 }];
          const { matchAtoB } = buildHeadingMatchMap(oA, [], "a-", "b-");
          A(matchAtoB.size === 0, "match: one empty outline = no matches");
        })();

        // --- buildHeadingMatchMap: renamed heading (fuzzy catches it) ---
        (function testMatch_renamedHeading() {
          const oA = [
            { id: "sec-a", text: "Section Architecture Overview", level: 2 },
            { id: "sec-b", text: "Testing Strategy", level: 2 },
          ];
          const oB = [
            { id: "sec-a", text: "Section Architecture", level: 2 },
            { id: "sec-b", text: "Testing Strategy", level: 2 },
          ];
          const { matchAtoB } = buildHeadingMatchMap(oA, oB, "a-", "b-");
          // "section architecture overview" vs "section architecture": prefix = "section architecture" (21 chars)
          // ratio = 21/30 ≈ 0.7 >= 0.6
          A(matchAtoB.has("a-sec-a"), "match: renamed heading fuzzy matched", { got: matchAtoB.get("a-sec-a") });
          A(matchAtoB.get("a-sec-b") === "b-sec-b", "match: unchanged heading exact matched");
        })();

        // --- buildHeadingMatchMap: moved sections (order doesn't matter) ---
        (function testMatch_movedSections() {
          const oA = [
            { id: "first", text: "Alpha", level: 2 },
            { id: "second", text: "Beta", level: 2 },
            { id: "third", text: "Gamma", level: 2 },
          ];
          const oB = [
            { id: "third", text: "Gamma", level: 2 },
            { id: "first", text: "Alpha", level: 2 },
            { id: "second", text: "Beta", level: 2 },
          ];
          const { matchAtoB } = buildHeadingMatchMap(oA, oB, "a-", "b-");
          A(matchAtoB.size === 3, "match: all 3 reordered headings matched", { got: matchAtoB.size });
          A(matchAtoB.get("a-first") === "b-first", "match: Alpha matched despite reorder");
          A(matchAtoB.get("a-second") === "b-second", "match: Beta matched");
          A(matchAtoB.get("a-third") === "b-third", "match: Gamma matched");
        })();

        // --- buildHeadingMatchMap: deterministic tie-breaking ---
        (function testMatch_tieBreaking() {
          // When two B headings have the same text, first one should win.
          const oA = [{ id: "x", text: "Duplicate", level: 2 }];
          const oB = [
            { id: "dup-first", text: "Duplicate", level: 2 },
            { id: "dup-second", text: "Duplicate", level: 2 },
          ];
          const { matchAtoB } = buildHeadingMatchMap(oA, oB, "a-", "b-");
          A(matchAtoB.get("a-x") === "b-dup-first", "match: tie-break picks first B match", { got: matchAtoB.get("a-x") });
        })();

        // --- buildHeadingMatchMap: mixed levels ---
        (function testMatch_mixedLevels() {
          const oA = [
            { id: "h1", text: "Title", level: 1 },
            { id: "h2a", text: "Section A", level: 2 },
            { id: "h3a", text: "Detail A.1", level: 3 },
          ];
          const oB = [
            { id: "h1", text: "Title", level: 1 },
            { id: "h2a", text: "Section A", level: 2 },
            { id: "h3a", text: "Detail A.1", level: 3 },
            { id: "h3b", text: "Detail A.2", level: 3 },
          ];
          const { matchAtoB, matchBtoA } = buildHeadingMatchMap(oA, oB, "a-", "b-");
          A(matchAtoB.size === 3, "match: all 3 A headings matched", { got: matchAtoB.size });
          A(!matchBtoA.has("b-h3b"), "match: extra B heading unmatched");
        })();

        // --- cachePaneHeadingOffsets: with no pane ---
        (function testCache_noPane() {
          const offsets = cachePaneHeadingOffsets(null, "x-");
          A(Array.isArray(offsets) && offsets.length === 0, "cache: null pane returns empty array");
        })();

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Side-by-Side Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Side-by-Side Unit Tests ----

      // ---- Side-by-Side E2E Tests (bd-24q.15.5) ----
      // Run via console: window.__runSbsE2ETests()
      // Requires dataset to be loaded.
      window.__runSbsE2ETests = async function () {
        const R = [];
        const log = (msg, ctx) => console.log("  [SBS-E2E]", msg, ctx || "");
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("  FAIL:", m, x || ""); else log("PASS: " + m); };
        const wait = (ms) => new Promise((r) => setTimeout(r, ms));

        if (!DATASET.loaded || ALL_COMMITS.length < 5) {
          console.error("SBS-E2E: Need loaded dataset with >= 5 commits.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded or < 5 commits" }] };
        }

        const origIdx = DOC.idx;
        const origTab = DOC.tab;
        const origCompare = DOC.compareMode;
        const origViewMode = DOC.abViewMode;
        const origSync = DOC.sbsSyncScroll;
        const origMobile = DOC.sbsMobilePane;
        const origFromIdx = DOC.compareFromIdx;
        const origToIdx = DOC.compareToIdx;

        // --- E2E 1: Enable A/B compare, switch to rendered mode, panes render ---
        await (async function testE2E_renderPanes() {
          // Enable compare mode.
          DOC.compareMode = true;
          DOC.compareFromIdx = 0;
          DOC.compareToIdx = Math.min(ALL_COMMITS.length - 1, 10);
          DOC.abViewMode = "rendered";
          DOC.sbsSyncScroll = true;

          // Trigger render.
          await renderSbsPanes();
          await wait(1500);

          const paneA = document.getElementById("sbsPaneA");
          const paneB = document.getElementById("sbsPaneB");
          A(paneA != null, "sbs-e2e: pane A element exists");
          A(paneB != null, "sbs-e2e: pane B element exists");

          if (paneA && paneB) {
            A(paneA.innerHTML.length > 0, "sbs-e2e: pane A has content", { len: paneA.innerHTML.length });
            A(paneB.innerHTML.length > 0, "sbs-e2e: pane B has content", { len: paneB.innerHTML.length });
            log("Pane A content: " + paneA.innerHTML.length + " chars, Pane B: " + paneB.innerHTML.length + " chars");
          }
        })();

        // --- E2E 2: Pane labels show commit info ---
        await (async function testE2E_paneLabels() {
          const labelA = document.getElementById("sbsLabelA");
          const labelB = document.getElementById("sbsLabelB");
          if (!labelA || !labelB) { A(false, "sbs-e2e: missing label elements"); return; }

          const textA = labelA.textContent || "";
          const textB = labelB.textContent || "";
          log("Label A: " + textA.slice(0, 60) + ", Label B: " + textB.slice(0, 60));
          A(textA.length > 0, "sbs-e2e: pane A label has text");
          A(textB.length > 0, "sbs-e2e: pane B label has text");
          A(textA !== textB, "sbs-e2e: labels differ for different commits", { a: textA.slice(0, 30), b: textB.slice(0, 30) });
        })();

        // --- E2E 3: Sync scroll: scroll pane A -> pane B follows ---
        await (async function testE2E_syncScroll() {
          const paneA = document.getElementById("sbsPaneA");
          const paneB = document.getElementById("sbsPaneB");
          if (!paneA || !paneB) { A(false, "sbs-e2e: missing panes for sync test"); return; }

          DOC.sbsSyncScroll = true;
          setupSbsSyncScroll();
          await wait(300);

          // Scroll pane A down.
          paneA.scrollTop = 0;
          paneB.scrollTop = 0;
          await wait(200);

          const scrollTarget = Math.min(500, paneA.scrollHeight - paneA.clientHeight);
          if (scrollTarget <= 0) { log("Pane A not scrollable, skip sync test"); A(true, "sbs-e2e: skipped sync (not scrollable)"); return; }

          paneA.scrollTop = scrollTarget;
          paneA.dispatchEvent(new Event("scroll"));
          await wait(500);

          const bScroll = paneB.scrollTop;
          log("Sync scroll: A=" + scrollTarget + ", B=" + bScroll);
          A(bScroll > 0, "sbs-e2e: pane B scrolled when A scrolled (sync on)", { aScroll: scrollTarget, bScroll });
        })();

        // --- E2E 4: Disable sync scroll -> panes scroll independently ---
        await (async function testE2E_noSyncScroll() {
          const paneA = document.getElementById("sbsPaneA");
          const paneB = document.getElementById("sbsPaneB");
          if (!paneA || !paneB) { A(false, "sbs-e2e: missing panes for no-sync test"); return; }

          DOC.sbsSyncScroll = false;
          setupSbsSyncScroll();
          await wait(300);

          // Reset both.
          paneA.scrollTop = 0;
          paneB.scrollTop = 0;
          await wait(200);

          // Scroll A only.
          const scrollTarget = Math.min(300, paneA.scrollHeight - paneA.clientHeight);
          if (scrollTarget <= 0) { A(true, "sbs-e2e: skipped no-sync (not scrollable)"); return; }

          paneA.scrollTop = scrollTarget;
          paneA.dispatchEvent(new Event("scroll"));
          await wait(300);

          const bScroll = paneB.scrollTop;
          log("No-sync scroll: A=" + scrollTarget + ", B=" + bScroll);
          A(bScroll === 0, "sbs-e2e: pane B stays at 0 with sync off", { bScroll });
        })();

        // --- E2E 5: Divider element is present and has correct styles ---
        await (async function testE2E_divider() {
          const divider = document.getElementById("sbsDivider");
          A(divider != null, "sbs-e2e: divider element exists");
          if (divider) {
            const style = window.getComputedStyle(divider);
            A(style.cursor === "col-resize", "sbs-e2e: divider has col-resize cursor", { got: style.cursor });
          }
        })();

        // --- E2E 6: Mobile tab switching preserves scroll position ---
        await (async function testE2E_mobileTabSwitch() {
          const tabA = document.getElementById("sbsTabA");
          const tabB = document.getElementById("sbsTabB");
          const paneA = document.getElementById("sbsPaneA");
          if (!tabA || !tabB || !paneA) { A(true, "sbs-e2e: skipped mobile (missing elements)"); return; }
          if (typeof switchSbsMobilePane !== "function") { A(true, "sbs-e2e: skipped mobile (no switchSbsMobilePane)"); return; }

          // Scroll pane A to a known position.
          const scrollTarget = Math.min(200, paneA.scrollHeight - paneA.clientHeight);
          paneA.scrollTop = scrollTarget;
          await wait(100);

          // Switch to pane B.
          switchSbsMobilePane("b");
          await wait(300);
          A(DOC.sbsMobilePane === "b", "sbs-e2e: mobile pane switched to B");

          // Switch back to pane A.
          switchSbsMobilePane("a");
          await wait(300);
          A(DOC.sbsMobilePane === "a", "sbs-e2e: mobile pane switched back to A");

          // Check scroll position was preserved.
          const restoredScroll = paneA.scrollTop;
          log("Mobile tab: original scroll=" + scrollTarget + ", restored=" + restoredScroll);
          A(Math.abs(restoredScroll - scrollTarget) < 5, "sbs-e2e: scroll position preserved after tab switch", { expected: scrollTarget, got: restoredScroll });
        })();

        // --- E2E 7: Different A/B indices produce different content ---
        await (async function testE2E_differentContent() {
          const paneA = document.getElementById("sbsPaneA");
          const paneB = document.getElementById("sbsPaneB");
          if (!paneA || !paneB) { A(false, "sbs-e2e: missing panes"); return; }

          DOC.compareFromIdx = 0;
          DOC.compareToIdx = ALL_COMMITS.length - 1;
          await renderSbsPanes();
          await wait(1500);

          A(paneA.innerHTML !== paneB.innerHTML, "sbs-e2e: first and last commits have different content");
          log("Pane A chars: " + paneA.innerHTML.length + ", Pane B chars: " + paneB.innerHTML.length);
        })();

        // --- E2E 8: Button styles update correctly ---
        await (async function testE2E_buttonStyles() {
          const btn = document.getElementById("btnSbsRendered");
          if (!btn) { A(true, "sbs-e2e: skipped button (missing btnSbsRendered)"); return; }

          DOC.abViewMode = "rendered";
          updateSbsButtonStyles();
          A(btn.classList.contains("bg-slate-900") || btn.classList.contains("text-white"), "sbs-e2e: rendered mode shows active button style");

          DOC.abViewMode = "diff";
          updateSbsButtonStyles();
          A(!btn.classList.contains("bg-slate-900") || btn.classList.contains("bg-white/70"), "sbs-e2e: diff mode shows inactive button style");
        })();

        // --- Restore original state ---
        DOC.compareMode = origCompare;
        DOC.abViewMode = origViewMode;
        DOC.sbsSyncScroll = origSync;
        DOC.sbsMobilePane = origMobile;
        DOC.compareFromIdx = origFromIdx;
        DOC.compareToIdx = origToIdx;
        selectCommitIdx(origIdx);
        if (DOC.tab !== origTab && typeof setDocTab === "function") setDocTab(origTab);
        await wait(300);
        log("Restored: compare=" + origCompare + ", viewMode=" + origViewMode + ", sync=" + origSync);

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Side-by-Side E2E Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Side-by-Side E2E Tests ----
      // ---- Playback E2E Tests (bd-24q.7.4) ----
      // Run via console: window.__runPlaybackE2ETests()
      // Requires dataset to be loaded.
      window.__runPlaybackE2ETests = async function () {
        const R = [];
        const log = (msg, ctx) => console.log("  [PLAY-E2E]", msg, ctx || "");
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("  FAIL:", m, x || ""); else log("PASS: " + m); };
        const wait = (ms) => new Promise((r) => setTimeout(r, ms));

        if (!DATASET.loaded || ALL_COMMITS.length < 10) {
          console.error("PLAY-E2E: Need loaded dataset with >= 10 commits.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded or < 10 commits" }] };
        }

        const maxIdx = ALL_COMMITS.length - 1;

        // Save original state.
        const origIdx = DOC.idx;
        const origState = PLAYBACK.state;
        const origSpeed = PLAYBACK.speed;
        const origLoop = PLAYBACK.loop;

        // Ensure we start clean.
        playbackStop();
        PLAYBACK.speed = 1;
        PLAYBACK.loop = false;

        // --- E2E 1: Play advances commit index ---
        await (async function testE2E_playAdvances() {
          selectCommitIdx(0);
          await wait(100);
          A(DOC.idx === 0, "play-e2e: start at idx 0", { got: DOC.idx });

          playbackSetSpeed(4); // 4 commits/sec => 1 tick every 250ms
          playbackPlay();
          A(PLAYBACK.state === "playing", "play-e2e: state is playing");
          log("Playing at 4x from idx 0...");

          await wait(1500); // ~6 ticks expected at 4x over 1.5s
          const idxAfter = DOC.idx;
          log("After 1.5s at 4x: idx=" + idxAfter);
          playbackPause();

          A(idxAfter > 0, "play-e2e: idx advanced from 0", { got: idxAfter });
          A(idxAfter >= 2, "play-e2e: advanced at least 2 commits at 4x in 1.5s", { got: idxAfter });
          A(PLAYBACK.state === "paused", "play-e2e: paused after pause()");
        })();

        // --- E2E 2: Pause stops advancement ---
        await (async function testE2E_pauseStops() {
          selectCommitIdx(5);
          await wait(100);
          playbackSetSpeed(4);
          playbackPlay();
          await wait(500);
          playbackPause();
          const idxAtPause = DOC.idx;
          log("Paused at idx=" + idxAtPause);

          await wait(800); // Wait to confirm no further advancement.
          const idxAfterWait = DOC.idx;
          A(idxAfterWait === idxAtPause, "play-e2e: no advancement after pause", { atPause: idxAtPause, afterWait: idxAfterWait });
        })();

        // --- E2E 3: Toggle play/pause ---
        await (async function testE2E_toggle() {
          selectCommitIdx(0);
          await wait(100);
          playbackSetSpeed(4);

          playbackToggle(); // paused -> playing
          A(PLAYBACK.state === "playing", "play-e2e: toggle from paused -> playing");
          await wait(600);

          playbackToggle(); // playing -> paused
          A(PLAYBACK.state === "paused", "play-e2e: toggle from playing -> paused");
          const idx1 = DOC.idx;
          A(idx1 > 0, "play-e2e: advanced during play phase", { got: idx1 });
        })();

        // --- E2E 4: Stop resets accumulator ---
        await (async function testE2E_stopResets() {
          selectCommitIdx(3);
          await wait(100);
          playbackSetSpeed(2);
          playbackPlay();
          await wait(300);
          playbackStop();
          A(PLAYBACK.state === "paused", "play-e2e: stop sets paused");
          A(PLAYBACK._accumMs === 0, "play-e2e: stop resets accumulator", { got: PLAYBACK._accumMs });
        })();

        // --- E2E 5: Speed change takes effect ---
        await (async function testE2E_speedChange() {
          selectCommitIdx(0);
          await wait(100);

          // Play at 0.5x (1 tick per 2s) for 1s => should barely advance.
          playbackSetSpeed(0.5);
          playbackPlay();
          await wait(1000);
          playbackPause();
          const slowIdx = DOC.idx;

          // Reset and play at 4x (1 tick per 250ms) for 1s => should advance more.
          selectCommitIdx(0);
          await wait(100);
          playbackSetSpeed(4);
          playbackPlay();
          await wait(1000);
          playbackPause();
          const fastIdx = DOC.idx;

          log("0.5x for 1s: idx=" + slowIdx + ", 4x for 1s: idx=" + fastIdx);
          A(fastIdx > slowIdx, "play-e2e: faster speed advances more", { slow: slowIdx, fast: fastIdx });
        })();

        // --- E2E 6: Loop wraps around ---
        await (async function testE2E_loopWraps() {
          // Start near end, enable loop, play fast.
          const nearEnd = Math.max(0, maxIdx - 3);
          selectCommitIdx(nearEnd);
          await wait(100);
          playbackSetSpeed(4);
          playbackSetLoop(true);
          playbackPlay();
          await wait(2000); // Should wrap around.
          playbackPause();
          playbackSetLoop(false);

          const loopIdx = DOC.idx;
          log("Loop test: started at " + nearEnd + ", ended at " + loopIdx);
          // With loop, it should have wrapped past maxIdx and ended up at a lower index.
          // Or it could have advanced past and wrapped. Just verify playback didn't stop at maxIdx.
          A(PLAYBACK.state === "paused", "play-e2e: loop paused correctly");
          // If it wrapped, idx should be less than nearEnd (or at least it advanced).
          if (maxIdx - nearEnd < 8) {
            // Started close to end, so wrapping is likely.
            A(loopIdx !== nearEnd, "play-e2e: loop advanced from start position", { start: nearEnd, end: loopIdx });
          }
        })();

        // --- E2E 7: No-loop stops at end ---
        await (async function testE2E_noLoopStopsAtEnd() {
          const nearEnd = Math.max(0, maxIdx - 2);
          selectCommitIdx(nearEnd);
          await wait(100);
          playbackSetSpeed(4);
          playbackSetLoop(false);
          playbackPlay();
          await wait(2000); // Should hit end and stop.

          A(PLAYBACK.state === "paused", "play-e2e: stopped at end (no loop)", { state: PLAYBACK.state });
          A(DOC.idx === maxIdx, "play-e2e: idx at maxIdx after stop", { got: DOC.idx, max: maxIdx });
        })();

        // --- E2E 8: Manual scrub during playback ---
        await (async function testE2E_scrubDuringPlay() {
          selectCommitIdx(0);
          await wait(100);
          playbackSetSpeed(2);
          playbackPlay();
          await wait(500);
          A(PLAYBACK.state === "playing", "play-e2e: playing before scrub");

          playbackOnManualScrub();
          A(PLAYBACK.state === "seeking", "play-e2e: seeking after scrub");

          // Simulate scrub to a specific index.
          selectCommitIdx(10);
          await wait(100);

          playbackOnScrubEnd();
          // Should resume playing (was playing before scrub).
          A(PLAYBACK.state === "playing", "play-e2e: resumed playing after scrub end", { got: PLAYBACK.state });
          await wait(500);
          const afterResume = DOC.idx;
          A(afterResume > 10, "play-e2e: continued advancing after scrub resume", { got: afterResume });

          playbackStop();
        })();

        // --- E2E 9: Scrub while paused stays paused ---
        await (async function testE2E_scrubWhilePaused() {
          selectCommitIdx(5);
          await wait(100);
          playbackStop(); // ensure paused
          playbackOnManualScrub();
          // When paused, scrub is a no-op (state stays paused).
          A(PLAYBACK.state === "paused", "play-e2e: scrub while paused stays paused", { got: PLAYBACK.state });
        })();

        // --- Restore original state ---
        playbackStop();
        PLAYBACK.speed = origSpeed;
        PLAYBACK.loop = origLoop;
        selectCommitIdx(origIdx);
        await wait(200);
        log("Restored: idx=" + origIdx + ", speed=" + origSpeed + ", loop=" + origLoop);

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Playback E2E Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Playback E2E Tests ----
      // ---- Mini-Map Unit Tests (bd-24q.2.5) ----
      // Run via console: window.__runMiniMapTests()
      window.__runMiniMapTests = function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || "") };

        // --- slugifyHeading ---
        (function testSlug_basic() {
          A(slugifyHeading("Hello World") === "hello-world", "slug: basic", { got: slugifyHeading("Hello World") });
        })();

        (function testSlug_punctuation() {
          A(slugifyHeading("Hello, World! (v2.0)") === "hello-world-v2-0", "slug: punctuation", { got: slugifyHeading("Hello, World! (v2.0)") });
        })();

        (function testSlug_empty() {
          A(slugifyHeading("") === "heading", "slug: empty -> fallback 'heading'", { got: slugifyHeading("") });
          A(slugifyHeading(null) === "heading", "slug: null -> fallback");
          A(slugifyHeading(undefined) === "heading", "slug: undefined -> fallback");
        })();

        (function testSlug_unicode() {
          const r = slugifyHeading("日本語の見出し");
          A(r.length > 0 && r !== "heading", "slug: unicode produces non-empty slug", { got: r });
        })();

        (function testSlug_leadingTrailingDash() {
          A(slugifyHeading("  --Hello--  ") === "hello", "slug: strips leading/trailing dashes", { got: slugifyHeading("  --Hello--  ") });
        })();

        (function testSlug_codeBackticks() {
          const r = slugifyHeading("`code_heading`");
          A(r === "code-heading", "slug: backticks+underscore -> dashes", { got: r });
        })();

        // --- extractOutline: stable IDs ---
        (function testOutline_stableIds() {
          const md = "# Title\n\n## Section A\n\n## Section B\n";
          const o1 = extractOutline(md);
          const o2 = extractOutline(md);
          A(o1.length === o2.length, "outline: same length on re-parse");
          for (let i = 0; i < o1.length; i++) {
            A(o1[i].id === o2[i].id, "outline: id stable for heading " + i, { id1: o1[i].id, id2: o2[i].id });
          }
        })();

        // --- extractOutline: duplicate headings get disambiguated IDs ---
        (function testOutline_duplicateIds() {
          const md = "## Intro\n\nText\n\n## Intro\n\nText\n\n## Intro\n";
          const o = extractOutline(md);
          A(o.length === 3, "outline: 3 duplicate headings");
          A(o[0].id === "intro", "outline: first is 'intro'");
          A(o[1].id === "intro-1", "outline: second is 'intro-1'", { got: o[1].id });
          A(o[2].id === "intro-2", "outline: third is 'intro-2'", { got: o[2].id });
          // All IDs must be unique.
          const ids = o.map(h => h.id);
          const unique = new Set(ids);
          A(unique.size === ids.length, "outline: all IDs unique", { ids });
        })();

        // --- extractOutline: heading levels ---
        (function testOutline_levels() {
          const md = "# H1\n## H2\n### H3\n#### H4\n";
          const o = extractOutline(md);
          A(o.length === 4, "outline: 4 levels");
          A(o[0].level === 1, "outline: h1 level=1");
          A(o[1].level === 2, "outline: h2 level=2");
          A(o[2].level === 3, "outline: h3 level=3");
          A(o[3].level === 4, "outline: h4 level=4");
        })();

        // --- extractOutline: empty heading ---
        (function testOutline_emptyHeading() {
          const md = "## \n\n## Real Heading\n";
          const o = extractOutline(md);
          A(o.length === 2, "outline: 2 headings (one empty)");
          A(o[0].id === "heading", "outline: empty heading gets fallback slug", { got: o[0].id });
        })();

        // --- countRoughTokens ---
        (function testTokens_basic() {
          A(countRoughTokens("hello world") === 2, "tokens: 2 words", { got: countRoughTokens("hello world") });
        })();

        (function testTokens_withPunctuation() {
          // "Hello, world!" => "Hello" + "," + "world" + "!" = 4
          const r = countRoughTokens("Hello, world!");
          A(r === 4, "tokens: words + punctuation", { got: r });
        })();

        (function testTokens_empty() {
          A(countRoughTokens("") === 0, "tokens: empty = 0");
          A(countRoughTokens("   ") === 0, "tokens: whitespace only = 0");
        })();

        // --- buildLineToHeadingMap ---
        (function testLineMap_basic() {
          const outline = [
            { id: "intro", text: "Introduction", level: 2, line: 1 },
            { id: "methods", text: "Methods", level: 2, line: 5 },
            { id: "results", text: "Results", level: 2, line: 10 },
          ];
          const map = buildLineToHeadingMap(15, outline);
          A(map[0] === "__preamble__", "lineMap: line 0 is preamble");
          A(map[1] === "intro", "lineMap: line 1 = intro", { got: map[1] });
          A(map[4] === "intro", "lineMap: line 4 = intro (before methods)", { got: map[4] });
          A(map[5] === "methods", "lineMap: line 5 = methods", { got: map[5] });
          A(map[7] === "methods", "lineMap: line 7 = methods", { got: map[7] });
          A(map[10] === "results", "lineMap: line 10 = results", { got: map[10] });
          A(map[15] === "results", "lineMap: line 15 = results (last section)", { got: map[15] });
        })();

        (function testLineMap_emptyOutline() {
          const map = buildLineToHeadingMap(5, []);
          A(map[0] === "__preamble__", "lineMap: empty outline line 0 = preamble");
          A(map[3] === "__preamble__", "lineMap: empty outline all preamble");
          A(map[5] === "__preamble__", "lineMap: empty outline last line = preamble");
        })();

        (function testLineMap_headingOnLine1() {
          const outline = [{ id: "title", text: "Title", level: 1, line: 1 }];
          const map = buildLineToHeadingMap(3, outline);
          A(map[0] === "__preamble__", "lineMap: line 0 always preamble");
          A(map[1] === "title", "lineMap: heading on line 1", { got: map[1] });
        })();

        // --- attributeHunksToHeadings ---
        (function testAttrib_addedLines() {
          const patch = "@@ -0,0 +1,3 @@\n+line one\n+line two\n+line three\n";
          const lineToHeading = ["__preamble__", "intro", "intro", "intro"];
          const metrics = attributeHunksToHeadings(patch, lineToHeading);
          const m = metrics.get("intro");
          A(m != null, "attrib: intro has metrics");
          A(m.addLines === 3, "attrib: 3 added lines", { got: m?.addLines });
          A(m.delLines === 0, "attrib: 0 deleted lines", { got: m?.delLines });
          A(m.tokensAdded > 0, "attrib: tokens added > 0", { got: m?.tokensAdded });
        })();

        (function testAttrib_deletedLines() {
          const patch = "@@ -1,2 +1,0 @@\n-removed line one\n-removed line two\n";
          const lineToHeading = ["__preamble__", "methods"];
          const metrics = attributeHunksToHeadings(patch, lineToHeading);
          const m = metrics.get("methods");
          A(m != null, "attrib: methods has metrics");
          A(m.delLines === 2, "attrib: 2 deleted lines", { got: m?.delLines });
          A(m.addLines === 0, "attrib: 0 added lines", { got: m?.addLines });
        })();

        (function testAttrib_mixedAddDel() {
          // Context line at line 1, delete at line 1 (old), add at line 2 (new).
          const patch = "@@ -1,3 +1,3 @@\n old context\n-old line\n+new line\n old tail\n";
          const lineToHeading = ["__preamble__", "sec-a", "sec-a", "sec-a"];
          const metrics = attributeHunksToHeadings(patch, lineToHeading);
          const m = metrics.get("sec-a");
          A(m != null, "attrib: sec-a has mixed metrics");
          A(m.addLines === 1, "attrib: mixed add=1", { got: m?.addLines });
          A(m.delLines === 1, "attrib: mixed del=1", { got: m?.delLines });
        })();

        (function testAttrib_acrossSections() {
          // Patch spans two sections: lines 1-2 in "intro", lines 3-4 in "methods".
          const patch = "@@ -1,4 +1,4 @@\n+added to intro\n context\n+added to methods\n context\n";
          const lineToHeading = ["__preamble__", "intro", "intro", "methods", "methods"];
          const metrics = attributeHunksToHeadings(patch, lineToHeading);
          A(metrics.has("intro"), "attrib: has intro");
          A(metrics.has("methods"), "attrib: has methods");
          A(metrics.get("intro").addLines >= 1, "attrib: intro got additions", { got: metrics.get("intro").addLines });
          A(metrics.get("methods").addLines >= 1, "attrib: methods got additions", { got: metrics.get("methods").addLines });
        })();

        (function testAttrib_emptyPatch() {
          const metrics = attributeHunksToHeadings("", []);
          A(metrics.size === 0, "attrib: empty patch = no metrics");
        })();

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Mini-Map Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Mini-Map Unit Tests ----

      // ---- Mini-Map E2E Tests (bd-24q.2.6) ----
      // Run via console: window.__runMiniMapE2ETests()
      // Requires dataset to be loaded.
      window.__runMiniMapE2ETests = async function () {
        const R = [];
        const log = (msg, ctx) => console.log("  [MM-E2E]", msg, ctx || "");
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("  FAIL:", m, x || ""); else log("PASS: " + m); };
        const wait = (ms) => new Promise((r) => setTimeout(r, ms));

        if (!DATASET.loaded || ALL_COMMITS.length < 5) {
          console.error("MM-E2E: Need loaded dataset with >= 5 commits.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded or < 5 commits" }] };
        }

        const mm = document.getElementById("miniMap");
        const mmItems = document.getElementById("miniMapItems");
        const toggleBtn = document.getElementById("btnMiniMapToggle");
        const docEl = document.getElementById("docRendered");
        if (!mm || !mmItems || !toggleBtn) {
          console.error("MM-E2E: Missing mini-map DOM elements.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Missing mini-map DOM elements" }] };
        }

        const origIdx = DOC.idx;
        const origTab = DOC.tab;

        // --- E2E 1: Toggle mini-map visibility ---
        await (async function testE2E_toggleVisibility() {
          // Ensure mini-map is visible.
          if (mm.classList.contains("hidden")) toggleBtn.click();
          await wait(300);
          A(!mm.classList.contains("hidden"), "mm-e2e: mini-map visible after toggle on");

          // Update it.
          await updateMiniMap();
          await wait(500);

          const items = mmItems.querySelectorAll(".minimap-item");
          A(items.length > 0, "mm-e2e: mini-map has heading items", { count: items.length });
          log("Mini-map rendered " + items.length + " items");
        })();

        // --- E2E 2: Click heading jumps to section ---
        await (async function testE2E_clickJumpsToSection() {
          if (!docEl) { A(false, "mm-e2e: no docRendered element"); return; }

          // Ensure on spec tab.
          if (DOC.tab !== "spec") { setDocTab("spec"); await wait(500); }

          // Show mini-map.
          if (mm.classList.contains("hidden")) { toggleBtn.click(); await wait(300); }
          await updateMiniMap();
          await wait(500);

          const items = mmItems.querySelectorAll(".minimap-item");
          if (items.length < 3) { log("Not enough items to test jump"); A(true, "mm-e2e: skipped jump (< 3 items)"); return; }

          // Scroll to top first.
          docEl.scrollTop = 0;
          await wait(200);
          const scrollBefore = docEl.scrollTop;

          // Click a heading that's further down (use the last third).
          const targetIdx = Math.floor(items.length * 0.7);
          const targetItem = items[targetIdx];
          const targetHeadingId = targetItem.dataset.headingId;
          log("Clicking heading: " + targetHeadingId + " (item " + targetIdx + "/" + items.length + ")");

          targetItem.click();
          await wait(800); // Wait for smooth scroll.

          const scrollAfter = docEl.scrollTop;
          log("Scroll before=" + scrollBefore + ", after=" + scrollAfter);
          A(scrollAfter > scrollBefore, "mm-e2e: doc scrolled after heading click", { before: scrollBefore, after: scrollAfter });
        })();

        // --- E2E 3: Active heading highlights in mini-map ---
        await (async function testE2E_activeHighlight() {
          if (mm.classList.contains("hidden")) { toggleBtn.click(); await wait(300); }
          await updateMiniMap();
          await wait(500);

          const items = mmItems.querySelectorAll(".minimap-item");
          if (items.length < 2) { A(true, "mm-e2e: skipped highlight (< 2 items)"); return; }

          // Click first item to activate it.
          items[0].click();
          await wait(500);

          const active = mmItems.querySelector(".minimap-active");
          A(active != null, "mm-e2e: an item has minimap-active class after click");
          if (active) {
            A(active.dataset.headingId === items[0].dataset.headingId, "mm-e2e: correct item is active", { expected: items[0].dataset.headingId, got: active.dataset.headingId });
          }
        })();

        // --- E2E 4: Changed-section markers present for commits with changes ---
        await (async function testE2E_changedMarkers() {
          // Select a commit with changes (skip first commit which has no parent diff).
          const testIdx = Math.min(5, ALL_COMMITS.length - 1);
          selectCommitIdx(testIdx);
          await wait(300);

          if (mm.classList.contains("hidden")) { toggleBtn.click(); await wait(300); }
          await updateMiniMap();
          await wait(800);

          // Look for change marker dots (inline-block rounded-full elements with background color).
          const markers = mmItems.querySelectorAll(".minimap-item .rounded-full");
          log("Commit " + testIdx + ": " + markers.length + " change markers found");
          // A non-trivial commit should have at least some markers.
          if (ALL_COMMITS[testIdx]?.impact > 0) {
            A(markers.length > 0, "mm-e2e: commit with changes has markers", { commit: testIdx, impact: ALL_COMMITS[testIdx].impact, markers: markers.length });
          } else {
            log("Commit has 0 impact, markers not expected");
            A(true, "mm-e2e: skipped marker test (0 impact commit)");
          }
        })();

        // --- E2E 5: Search filter narrows displayed headings ---
        await (async function testE2E_searchFilter() {
          if (mm.classList.contains("hidden")) { toggleBtn.click(); await wait(300); }
          await updateMiniMap();
          await wait(500);

          const searchInput = document.getElementById("miniMapSearch");
          if (!searchInput) { A(false, "mm-e2e: missing search input"); return; }

          const allCount = mmItems.querySelectorAll(".minimap-item").length;
          if (allCount < 3) { A(true, "mm-e2e: skipped search (< 3 items)"); return; }

          // Get text from first heading to use as search term.
          const firstItem = mmItems.querySelector(".minimap-item");
          const searchTerm = firstItem?.textContent?.trim()?.slice(0, 8) || "";
          if (!searchTerm) { A(true, "mm-e2e: skipped search (no text)"); return; }

          // Type a search term.
          searchInput.value = searchTerm;
          searchInput.dispatchEvent(new Event("input"));
          await wait(400);

          // Re-render mini-map with filter applied.
          await updateMiniMap();
          await wait(500);

          const filteredCount = mmItems.querySelectorAll(".minimap-item").length;
          log("Search '" + searchTerm + "': " + allCount + " -> " + filteredCount + " items");
          A(filteredCount <= allCount, "mm-e2e: filter reduces or keeps item count", { all: allCount, filtered: filteredCount });
          A(filteredCount > 0, "mm-e2e: filter still shows matching items", { count: filteredCount });

          // Clear search.
          searchInput.value = "";
          searchInput.dispatchEvent(new Event("input"));
          await updateMiniMap();
          await wait(300);

          const restoredCount = mmItems.querySelectorAll(".minimap-item").length;
          A(restoredCount === allCount, "mm-e2e: clearing search restores all items", { restored: restoredCount, original: allCount });
        })();

        // --- E2E 6: Mobile sheet open/close ---
        await (async function testE2E_mobileSheet() {
          const sheet = document.getElementById("miniMapMobileSheet");
          const overlay = document.getElementById("miniMapMobileOverlay");
          const mobileBtn = document.getElementById("btnMiniMapMobile");
          const closeBtn = document.getElementById("btnMiniMapMobileClose");
          if (!sheet || !overlay || !mobileBtn || !closeBtn) {
            log("Missing mobile sheet elements, skipping");
            A(true, "mm-e2e: skipped mobile (missing elements)");
            return;
          }

          // Open mobile sheet.
          openMiniMapMobile();
          await wait(500);
          A(!sheet.classList.contains("hidden"), "mm-e2e: mobile sheet visible after open");
          A(!overlay.classList.contains("hidden"), "mm-e2e: mobile overlay visible after open");

          // Check mobile list is populated.
          const mobileList = document.getElementById("miniMapMobileList");
          if (mobileList) {
            const items = mobileList.querySelectorAll("button[data-heading-id]");
            A(items.length > 0, "mm-e2e: mobile list has items", { count: items.length });
          }

          // Close mobile sheet.
          closeMiniMapMobile();
          await wait(400);
          A(overlay.classList.contains("hidden"), "mm-e2e: mobile overlay hidden after close");
        })();

        // --- E2E 7: Mobile heading tap jumps and closes sheet ---
        await (async function testE2E_mobileTapJump() {
          const sheet = document.getElementById("miniMapMobileSheet");
          const mobileList = document.getElementById("miniMapMobileList");
          const stayOpenCb = document.getElementById("miniMapMobileStayOpen");
          if (!sheet || !mobileList) { A(true, "mm-e2e: skipped mobile tap (missing elements)"); return; }

          // Ensure stay-open is unchecked so sheet closes on tap.
          if (stayOpenCb) stayOpenCb.checked = false;

          // Open and wait for list to populate.
          openMiniMapMobile();
          await wait(600);

          const items = mobileList.querySelectorAll("button[data-heading-id]");
          if (items.length < 2) { closeMiniMapMobile(); await wait(300); A(true, "mm-e2e: skipped mobile tap (< 2 items)"); return; }

          // Tap a heading.
          items[1].click();
          await wait(600);

          // Sheet should close (stay-open unchecked).
          const overlay = document.getElementById("miniMapMobileOverlay");
          A(overlay.classList.contains("hidden"), "mm-e2e: mobile sheet closed after tap", { overlayHidden: overlay?.classList?.contains("hidden") });
        })();

        // --- E2E 8: Different commits produce different outlines ---
        await (async function testE2E_differentCommitOutlines() {
          if (mm.classList.contains("hidden")) { toggleBtn.click(); await wait(300); }

          selectCommitIdx(0);
          await wait(200);
          await updateMiniMap();
          await wait(500);
          const count0 = mmItems.querySelectorAll(".minimap-item").length;

          const lastIdx = ALL_COMMITS.length - 1;
          selectCommitIdx(lastIdx);
          await wait(200);
          await updateMiniMap();
          await wait(500);
          const countLast = mmItems.querySelectorAll(".minimap-item").length;

          log("Commit 0: " + count0 + " headings, Commit " + lastIdx + ": " + countLast + " headings");
          // The spec document evolved, so heading counts should differ.
          if (count0 > 0 && countLast > 0) {
            A(countLast >= count0, "mm-e2e: later commit has >= headings than first", { first: count0, last: countLast });
          } else {
            A(true, "mm-e2e: outline counts verified (at least one commit has headings)");
          }
        })();

        // --- Restore original state ---
        selectCommitIdx(origIdx);
        if (DOC.tab !== origTab && typeof setDocTab === "function") setDocTab(origTab);
        await wait(300);
        log("Restored: idx=" + origIdx + ", tab=" + origTab);

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Mini-Map E2E Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Mini-Map E2E Tests ----







      // ---- Story Mode Unit Tests (bd-24q.4.5) ----
      // Run via console: window.__runStoryModeTests()
      window.__runStoryModeTests = function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || "") };

        if (!DATASET.loaded || !ALL_COMMITS.length) {
          console.error("StoryMode: Need loaded dataset.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded" }] };
        }

        // Save state.
        const origIdx = DOC.idx;
        const origTab = DOC.tab;
        const origStoryActiveIdx = _storyActiveIdx;
        const origStoryMilestones = _storyMilestones.slice();

        // --- 1. MILESTONES const schema validation ---
        (function testSchema_isArray() {
          A(Array.isArray(MILESTONES), "schema: MILESTONES is array");
          A(MILESTONES.length >= 5, "schema: at least 5 milestones", { len: MILESTONES.length });
        })();

        (function testSchema_requiredFields() {
          const required = ["id", "title", "commitHash", "annotationMd", "defaultTab"];
          for (const m of MILESTONES) {
            for (const f of required) {
              A(m[f] !== undefined && m[f] !== null, `schema: ${m.id}.${f} exists`, { milestone: m.id, field: f, value: m[f] });
            }
            A(typeof m.id === "string" && m.id.length > 0, `schema: ${m.id} id is non-empty string`);
            A(typeof m.title === "string" && m.title.length > 0, `schema: ${m.id} title is non-empty string`);
            A(typeof m.commitHash === "string" && m.commitHash.length >= 7, `schema: ${m.id} commitHash >= 7 chars`, { hash: m.commitHash });
            A(typeof m.annotationMd === "string" && m.annotationMd.length > 0, `schema: ${m.id} annotationMd non-empty`);
            A(["spec", "diff", "metrics"].includes(m.defaultTab), `schema: ${m.id} defaultTab valid`, { tab: m.defaultTab });
          }
        })();

        (function testSchema_uniqueIds() {
          const ids = MILESTONES.map(m => m.id);
          const unique = new Set(ids);
          A(unique.size === ids.length, "schema: all ids unique", { ids, dupes: ids.filter((v, i) => ids.indexOf(v) !== i) });
        })();

        (function testSchema_uniqueHashes() {
          const hashes = MILESTONES.map(m => m.commitHash);
          const unique = new Set(hashes);
          A(unique.size === hashes.length, "schema: all commitHashes unique", { dupes: hashes.filter((v, i) => hashes.indexOf(v) !== i) });
        })();

        (function testSchema_optionalFocusHeading() {
          // focusHeading is optional — verify it's a string when present.
          for (const m of MILESTONES) {
            if (m.focusHeading !== undefined) {
              A(typeof m.focusHeading === "string" && m.focusHeading.length > 0, `schema: ${m.id} focusHeading is non-empty string`, { heading: m.focusHeading });
            }
          }
        })();

        // --- 2. getMilestones() resolver ---
        (function testGetMilestones_returnsArray() {
          const resolved = getMilestones();
          A(Array.isArray(resolved), "resolver: returns array");
          A(resolved.length === MILESTONES.length, "resolver: same length as MILESTONES", { got: resolved.length, expected: MILESTONES.length });
        })();

        (function testGetMilestones_hasCommitIdx() {
          const resolved = getMilestones();
          for (const m of resolved) {
            A("commitIdx" in m, `resolver: ${m.id} has commitIdx`);
            A("warning" in m, `resolver: ${m.id} has warning field`);
            if (m.commitIdx !== null) {
              A(typeof m.commitIdx === "number" && m.commitIdx >= 0, `resolver: ${m.id} commitIdx is valid index`, { idx: m.commitIdx });
              A(m.commitIdx < ALL_COMMITS.length, `resolver: ${m.id} commitIdx in range`, { idx: m.commitIdx, max: ALL_COMMITS.length - 1 });
              A(m.warning === null, `resolver: ${m.id} no warning when found`);
            } else {
              A(typeof m.warning === "string", `resolver: ${m.id} has warning string when not found`, { warning: m.warning });
            }
          }
        })();

        (function testGetMilestones_commitHashMatches() {
          const resolved = getMilestones();
          for (const m of resolved) {
            if (m.commitIdx !== null) {
              const commit = ALL_COMMITS[m.commitIdx];
              const hashMatch = (commit.hash && commit.hash.startsWith(m.commitHash)) ||
                                (commit.short && commit.short === m.commitHash) ||
                                (commit.hash === m.commitHash);
              A(hashMatch, `resolver: ${m.id} commit hash matches`, { expected: m.commitHash, gotHash: commit.hash, gotShort: commit.short });
            }
          }
        })();

        (function testGetMilestones_preservesOriginalFields() {
          const resolved = getMilestones();
          for (let i = 0; i < resolved.length; i++) {
            const r = resolved[i];
            const o = MILESTONES[i];
            A(r.id === o.id, `resolver: preserves id at ${i}`);
            A(r.title === o.title, `resolver: preserves title at ${i}`);
            A(r.commitHash === o.commitHash, `resolver: preserves commitHash at ${i}`);
            A(r.annotationMd === o.annotationMd, `resolver: preserves annotationMd at ${i}`);
            A(r.defaultTab === o.defaultTab, `resolver: preserves defaultTab at ${i}`);
          }
        })();

        (function testGetMilestones_orderMatchesMilestones() {
          const resolved = getMilestones();
          // Verify indices are generally ascending (milestones should be chronological).
          let lastIdx = -1;
          let ascending = true;
          for (const m of resolved) {
            if (m.commitIdx !== null) {
              if (m.commitIdx < lastIdx) ascending = false;
              lastIdx = m.commitIdx;
            }
          }
          A(ascending, "resolver: milestones are chronologically ordered by commitIdx");
        })();

        // --- 3. Navigation: storyGoToIdx ---
        (function testNavigation_goToIdx() {
          // Populate _storyMilestones via getMilestones filter.
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          if (milestones.length < 2) { A(false, "nav: need >= 2 resolved milestones"); return; }

          // Manually set _storyMilestones for testing.
          _storyMilestones = milestones;

          storyGoToIdx(0);
          A(_storyActiveIdx === 0, "nav: goToIdx(0) sets _storyActiveIdx=0", { got: _storyActiveIdx });
          A(DOC.idx === milestones[0].commitIdx, "nav: goToIdx(0) sets DOC.idx", { got: DOC.idx, expected: milestones[0].commitIdx });

          storyGoToIdx(1);
          A(_storyActiveIdx === 1, "nav: goToIdx(1) sets _storyActiveIdx=1", { got: _storyActiveIdx });
          A(DOC.idx === milestones[1].commitIdx, "nav: goToIdx(1) sets DOC.idx", { got: DOC.idx, expected: milestones[1].commitIdx });
        })();

        (function testNavigation_goToIdxLast() {
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          if (!milestones.length) { A(false, "nav: no milestones"); return; }
          _storyMilestones = milestones;

          const lastIdx = milestones.length - 1;
          storyGoToIdx(lastIdx);
          A(_storyActiveIdx === lastIdx, "nav: goToIdx(last) sets correct index", { got: _storyActiveIdx, expected: lastIdx });
          A(DOC.idx === milestones[lastIdx].commitIdx, "nav: goToIdx(last) sets DOC.idx", { got: DOC.idx, expected: milestones[lastIdx].commitIdx });
        })();

        (function testNavigation_goToIdxInvalid() {
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          _storyMilestones = milestones;

          const beforeIdx = _storyActiveIdx;
          const beforeDocIdx = DOC.idx;
          storyGoToIdx(-1); // Invalid index.
          A(_storyActiveIdx === beforeIdx, "nav: goToIdx(-1) no change to _storyActiveIdx");
          storyGoToIdx(999); // Out of range.
          A(_storyActiveIdx === beforeIdx, "nav: goToIdx(999) no change to _storyActiveIdx");
        })();

        (function testNavigation_defaultTab() {
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          if (!milestones.length) { A(false, "nav: no milestones for tab test"); return; }
          _storyMilestones = milestones;

          // First milestone has defaultTab.
          storyGoToIdx(0);
          A(DOC.tab === milestones[0].defaultTab, "nav: goToIdx applies defaultTab", { got: DOC.tab, expected: milestones[0].defaultTab });
        })();

        // --- 4. Navigation: storyPrev / storyNext bounds ---
        (function testNavigation_prevNext() {
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          if (milestones.length < 3) { A(false, "nav: need >= 3 milestones for prev/next"); return; }
          _storyMilestones = milestones;

          // Start at index 1.
          storyGoToIdx(1);
          A(_storyActiveIdx === 1, "nav: start at 1");

          storyNext();
          A(_storyActiveIdx === 2, "nav: next from 1 → 2", { got: _storyActiveIdx });

          storyPrev();
          A(_storyActiveIdx === 1, "nav: prev from 2 → 1", { got: _storyActiveIdx });
        })();

        (function testNavigation_prevAtZero() {
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          if (!milestones.length) { A(false, "nav: no milestones"); return; }
          _storyMilestones = milestones;

          storyGoToIdx(0);
          storyPrev();
          A(_storyActiveIdx === 0, "nav: prev at 0 stays at 0 (lower bound)", { got: _storyActiveIdx });
        })();

        (function testNavigation_nextAtLast() {
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          if (!milestones.length) { A(false, "nav: no milestones"); return; }
          _storyMilestones = milestones;

          const lastIdx = milestones.length - 1;
          storyGoToIdx(lastIdx);
          storyNext();
          A(_storyActiveIdx === lastIdx, "nav: next at last stays at last (upper bound)", { got: _storyActiveIdx, expected: lastIdx });
        })();

        (function testNavigation_fullTraversal() {
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          if (milestones.length < 2) { A(false, "nav: need >= 2 milestones for traversal"); return; }
          _storyMilestones = milestones;

          // Forward traverse: 0 → last.
          storyGoToIdx(0);
          for (let i = 0; i < milestones.length - 1; i++) storyNext();
          A(_storyActiveIdx === milestones.length - 1, "nav: full forward traversal reaches last", { got: _storyActiveIdx });

          // Backward traverse: last → 0.
          for (let i = 0; i < milestones.length - 1; i++) storyPrev();
          A(_storyActiveIdx === 0, "nav: full backward traversal reaches 0", { got: _storyActiveIdx });
        })();

        // --- 5. Diagnostics ---
        (function testDiagnostics() {
          const resolved = getMilestones();
          const diag = resolved.map(m => ({ id: m.id, commitIdx: m.commitIdx, warning: m.warning }));
          console.log("  [StoryMode] Milestone diagnostics:", JSON.stringify(diag));
          const found = resolved.filter(m => m.commitIdx !== null).length;
          const missing = resolved.filter(m => m.commitIdx === null).length;
          console.log(`  [StoryMode] ${found} resolved, ${missing} missing`);
          A(found > 0, "diag: at least 1 milestone resolved", { found, missing });
        })();

        // --- Restore state ---
        DOC.idx = origIdx;
        DOC.tab = origTab;
        _storyActiveIdx = origStoryActiveIdx;
        _storyMilestones = origStoryMilestones;
        // Restore the selected commit display.
        selectCommitIdx(origIdx);

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Story Mode Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Story Mode Unit Tests ----
      // ---- Story Mode E2E Tests (bd-24q.4.6) ----
      // Run via console: window.__runStoryModeE2ETests()
      window.__runStoryModeE2ETests = async function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || ""); };
        const wait = (ms) => new Promise(r => setTimeout(r, ms));
        const log = (m) => console.log("  [story-e2e]", m);

        if (!DATASET.loaded || !ALL_COMMITS.length) {
          console.error("Story E2E: Need loaded dataset.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded" }] };
        }

        // Save state.
        const savedIdx = DOC.idx;
        const savedTab = DOC.tab;
        const savedActiveIdx = _storyActiveIdx;
        const savedMilestones = _storyMilestones.slice();
        const savedAutoplay = { enabled: STORY_AUTOPLAY.enabled, milestoneIdx: STORY_AUTOPLAY.milestoneIdx, pausedAtMilestone: STORY_AUTOPLAY.pausedAtMilestone, _milestoneCommitSet: STORY_AUTOPLAY._milestoneCommitSet };
        const savedPlaybackState = PLAYBACK.state;

        // --- E2E 1: Toggle story rail open + cards render ---
        await (async function testOpenStoryRail() {
          const rail = document.getElementById("storyRail");
          const btn = document.getElementById("btnStoryToggle");
          A(rail !== null, "e2e-1: storyRail element exists");
          A(btn !== null, "e2e-1: btnStoryToggle element exists");
          // Ensure hidden first.
          if (rail && !rail.classList.contains("hidden")) rail.classList.add("hidden");
          // Click toggle to open.
          if (btn) btn.click();
          await wait(500);
          A(!rail.classList.contains("hidden"), "e2e-1: storyRail visible after toggle click");
          const cards = document.getElementById("storyCards");
          const items = cards?.querySelectorAll(".story-card") || [];
          A(items.length > 0, "e2e-1: story cards rendered", { count: items.length });
          log("Rail open: " + items.length + " cards");
        })();

        // --- E2E 2: First milestone loads commit + annotation ---
        await (async function testFirstMilestoneLoads() {
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          if (milestones.length < 1) { log("Skipping (no milestones)"); return; }
          _storyMilestones = milestones;
          storyGoToIdx(0);
          await wait(500);
          const m = milestones[0];
          A(DOC.idx === m.commitIdx, "e2e-2: first milestone sets DOC.idx", { got: DOC.idx, expected: m.commitIdx });
          A(DOC.tab === m.defaultTab, "e2e-2: first milestone sets defaultTab", { got: DOC.tab, expected: m.defaultTab });
          // Check annotation is rendered in the active card.
          const activeCard = document.querySelector('.story-card[data-story-idx="0"]');
          if (activeCard) {
            const annotation = activeCard.querySelector(".story-annotation");
            A(annotation !== null, "e2e-2: active card has annotation");
            A(annotation && annotation.textContent.length > 10, "e2e-2: annotation has content", { len: annotation?.textContent?.length });
          }
          // Check progress shows "1/N".
          const progress = document.getElementById("storyProgress");
          A(progress && progress.textContent === "1/" + milestones.length, "e2e-2: progress shows 1/N", { got: progress?.textContent });
          log("First milestone: idx=" + m.commitIdx + " tab=" + m.defaultTab);
        })();

        // --- E2E 3: Next/prev navigation updates commit + card ---
        await (async function testNextPrevNavigation() {
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          if (milestones.length < 3) { log("Skipping nav (< 3 milestones)"); return; }
          _storyMilestones = milestones;
          storyGoToIdx(0);
          await wait(300);
          // Navigate forward.
          storyNext();
          await wait(300);
          A(_storyActiveIdx === 1, "e2e-3: next from 0 → 1", { got: _storyActiveIdx });
          A(DOC.idx === milestones[1].commitIdx, "e2e-3: DOC.idx matches milestone 1", { got: DOC.idx, expected: milestones[1].commitIdx });
          // Navigate forward again.
          storyNext();
          await wait(300);
          A(_storyActiveIdx === 2, "e2e-3: next from 1 → 2", { got: _storyActiveIdx });
          A(DOC.idx === milestones[2].commitIdx, "e2e-3: DOC.idx matches milestone 2", { got: DOC.idx, expected: milestones[2].commitIdx });
          // Navigate backward.
          storyPrev();
          await wait(300);
          A(_storyActiveIdx === 1, "e2e-3: prev from 2 → 1", { got: _storyActiveIdx });
          A(DOC.idx === milestones[1].commitIdx, "e2e-3: DOC.idx matches milestone 1 after prev", { got: DOC.idx });
          // Check progress updates.
          const progress = document.getElementById("storyProgress");
          A(progress && progress.textContent === "2/" + milestones.length, "e2e-3: progress updated after nav", { got: progress?.textContent });
          log("Nav OK: next/prev/progress verified");
        })();

        // --- E2E 4: focusHeading jump works for milestones with focusHeading ---
        await (async function testFocusHeadingJump() {
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          const withFocus = milestones.findIndex(m => m.focusHeading);
          if (withFocus === -1) { log("Skipping focusHeading (none)"); return; }
          _storyMilestones = milestones;
          storyGoToIdx(withFocus);
          await wait(800);
          const m = milestones[withFocus];
          A(DOC.idx === m.commitIdx, "e2e-4: focusHeading milestone sets DOC.idx", { got: DOC.idx });
          // If on spec tab, verify heading element exists.
          if (m.defaultTab === "spec") {
            const docEl = document.getElementById("docRendered");
            const target = docEl?.querySelector("#" + CSS.escape(m.focusHeading));
            A(target !== null, "e2e-4: focusHeading target element exists", { heading: m.focusHeading });
          } else {
            A(true, "e2e-4: focusHeading milestone on " + m.defaultTab + " tab, skip element check");
          }
          log("focusHeading: " + m.focusHeading + " at milestone " + withFocus);
        })();

        // --- E2E 5: Clicking a story card jumps to that commit ---
        await (async function testCardClick() {
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          if (milestones.length < 2) { log("Skipping card click (< 2 milestones)"); return; }
          _storyMilestones = milestones;
          storyGoToIdx(0);
          await wait(300);
          const secondCard = document.querySelector('.story-card[data-story-idx="1"]');
          if (!secondCard) { log("Skipping card click (card not found)"); return; }
          secondCard.click();
          await wait(500);
          A(DOC.idx === milestones[1].commitIdx, "e2e-5: clicking card 1 sets DOC.idx", { got: DOC.idx, expected: milestones[1].commitIdx });
          A(_storyActiveIdx === 1, "e2e-5: clicking card 1 sets _storyActiveIdx", { got: _storyActiveIdx });
          log("Card click: OK");
        })();

        // --- E2E 6: Autoplay starts and sets state correctly ---
        await (async function testAutoplayStartStop() {
          playbackStop();
          storyAutoplayStop();
          await wait(200);
          selectCommitIdx(0);
          await wait(200);
          storyAutoplayStart();
          await wait(500);
          A(STORY_AUTOPLAY.enabled === true, "e2e-6: autoplay enabled after start");
          A(STORY_AUTOPLAY._milestoneCommitSet instanceof Set, "e2e-6: milestone commit set built");
          A(STORY_AUTOPLAY._milestoneCommitSet.size > 0, "e2e-6: milestone commit set non-empty", { size: STORY_AUTOPLAY._milestoneCommitSet?.size });
          const rail = document.getElementById("storyRail");
          A(rail && !rail.classList.contains("hidden"), "e2e-6: storyRail visible during autoplay");
          // Stop autoplay.
          storyAutoplayStop();
          playbackStop();
          await wait(200);
          A(STORY_AUTOPLAY.enabled === false, "e2e-6: autoplay disabled after stop");
          A(STORY_AUTOPLAY._milestoneCommitSet === null, "e2e-6: milestone set cleared after stop");
          log("Autoplay start/stop: OK");
        })();

        // --- E2E 7: Autoplay respects reduced-motion guard ---
        await (async function testReducedMotionGuard() {
          const src = storyAutoplayStart.toString();
          A(src.includes("prefers-reduced-motion"), "e2e-7: storyAutoplayStart checks prefers-reduced-motion");
          const playSrc = playbackPlay.toString();
          A(playSrc.includes("prefers-reduced-motion"), "e2e-7: playbackPlay checks prefers-reduced-motion");
          log("Reduced-motion guard: verified in source");
        })();

        // --- E2E 8: Permalink round-trip preserves story autoplay state ---
        await (async function testPermalinkRoundTrip() {
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          if (milestones.length < 3) { log("Skipping permalink (< 3 milestones)"); return; }
          _storyMilestones = milestones;
          _storyAutoplayBuildSet();
          STORY_AUTOPLAY.enabled = true;
          STORY_AUTOPLAY.milestoneIdx = 2;
          STORY_AUTOPLAY.pausedAtMilestone = false;
          storyGoToIdx(2);
          await wait(300);
          // Encode URL state.
          const encoded = encodeUrlState();
          A(encoded.includes("sa=1"), "e2e-8: URL includes sa=1", { encoded });
          A(encoded.includes("si=2"), "e2e-8: URL includes si=2", { encoded });
          // Decode and verify round-trip.
          const decoded = decodeUrlState("?" + encoded);
          A(decoded.sa === true, "e2e-8: decoded sa = true", { got: decoded.sa });
          A(decoded.si === 2, "e2e-8: decoded si = 2", { got: decoded.si });
          // Clean up.
          storyAutoplayStop();
          playbackStop();
          await wait(200);
          log("Permalink round-trip: OK");
        })();

        // --- E2E 9: Mobile story mode opens and navigates ---
        await (async function testMobileStoryMode() {
          const sheet = document.getElementById("storyMobileSheet");
          const overlay = document.getElementById("storyMobileOverlay");
          if (!sheet || !overlay) { log("Skipping mobile (no elements)"); return; }
          openStoryMobile();
          await wait(500);
          A(!sheet.classList.contains("hidden"), "e2e-9: mobile sheet visible after open");
          const progress = document.getElementById("storyMobileProgress");
          A(progress && progress.textContent.includes("/"), "e2e-9: mobile progress shows N/M", { got: progress?.textContent });
          // Navigate forward if possible.
          const milestones = getMilestones().filter(m => m.commitIdx !== null);
          if (milestones.length >= 2 && _storyMobileIdx === 0) {
            _storyMobileNext();
            await wait(300);
            A(_storyMobileIdx === 1, "e2e-9: mobile next advances to 1", { got: _storyMobileIdx });
          }
          closeStoryMobile();
          await wait(300);
          A(sheet.classList.contains("hidden"), "e2e-9: mobile sheet hidden after close");
          log("Mobile story: OK");
        })();

        // Restore state.
        playbackStop();
        storyAutoplayStop();
        _storyActiveIdx = savedActiveIdx;
        _storyMilestones = savedMilestones;
        STORY_AUTOPLAY.enabled = savedAutoplay.enabled;
        STORY_AUTOPLAY.milestoneIdx = savedAutoplay.milestoneIdx;
        STORY_AUTOPLAY.pausedAtMilestone = savedAutoplay.pausedAtMilestone;
        STORY_AUTOPLAY._milestoneCommitSet = savedAutoplay._milestoneCommitSet;
        selectCommitIdx(savedIdx);
        if (savedTab) setDocTab(savedTab);
        await wait(300);

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Story Mode E2E Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Story Mode E2E Tests ----



      // ---- Outlier Unit Tests (bd-24q.10.3) ----
      // Run via console: window.__runOutlierTests()
      window.__runOutlierTests = function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || "") };
        const near = (a, b, eps) => Math.abs(a - b) < (eps || 0.01);

        // --- 1. Basic MAD-Z correctness on known synthetic series ---
        (function testBasic_knownSeries() {
          // Series: [1, 2, 3, 4, 100]. Median=3, MAD=median(|1-3|,|2-3|,|3-3|,|4-3|,|100-3|)=median(2,1,0,1,97)=1.
          const entries = [1, 2, 3, 4, 100].map((v, i) => ({ value: v, idx: i, ts: "2026-01-0" + (i + 1), hash: "h" + i }));
          const r = _inlineOutliersRobust(entries, 3);
          A(near(r.median, 3), "basic: median=3", { got: r.median });
          A(near(r.mad, 1), "basic: MAD=1", { got: r.mad });
          A(r.top.length === 3, "basic: top-3 returned", { got: r.top.length });
          // The outlier (100) should be first.
          A(r.top[0].value === 100, "basic: top[0] is 100", { got: r.top[0].value });
          // z for 100: 0.6745 * (100 - 3) / 1 = 65.4265
          A(near(r.top[0].z, 65.4265, 0.01), "basic: z(100) ~= 65.43", { got: r.top[0].z });
          // z for 1: 0.6745 * (1 - 3) / 1 = -1.349
          const entry1 = r.all.find(e => e.value === 1);
          A(entry1 && near(entry1.z, -1.349, 0.01), "basic: z(1) ~= -1.35", { got: entry1?.z });
        })();

        // --- 2. Even-length series (median is average of two middle values) ---
        (function testEven_median() {
          const entries = [10, 20, 30, 40].map((v, i) => ({ value: v, idx: i }));
          const r = _inlineOutliersRobust(entries, 2);
          A(near(r.median, 25), "even: median=(20+30)/2=25", { got: r.median });
          // MAD: |10-25|=15, |20-25|=5, |30-25|=5, |40-25|=15 → sorted: 5,5,15,15 → median=(5+15)/2=10
          A(near(r.mad, 10), "even: MAD=10", { got: r.mad });
        })();

        // --- 3. MAD=0 (all identical values) ---
        (function testMADZero() {
          const entries = [5, 5, 5, 5, 5].map((v, i) => ({ value: v, idx: i }));
          const r = _inlineOutliersRobust(entries, 3);
          A(near(r.median, 5), "mad0: median=5", { got: r.median });
          A(r.mad === 0 || near(r.mad, 0), "mad0: MAD=0", { got: r.mad });
          // All z-scores should be 0.
          A(r.all.every(e => near(e.z, 0, 0.001)), "mad0: all z=0");
          A(r.top.length >= 1, "mad0: at least 1 in top");
        })();

        // --- 4. Single element ---
        (function testSingle() {
          const r = _inlineOutliersRobust([{ value: 42, idx: 0 }], 5);
          A(near(r.median, 42), "single: median=42", { got: r.median });
          A(r.top.length === 1, "single: top length=1");
          A(r.all.length === 1, "single: all length=1");
        })();

        // --- 5. Empty series ---
        (function testEmpty() {
          const r = _inlineOutliersRobust([], 5);
          A(r.median === 0, "empty: median=0");
          A(r.mad === 0, "empty: MAD=0");
          A(r.top.length === 0, "empty: no top");
          A(r.all.length === 0, "empty: no all");
        })();

        // --- 6. Two elements ---
        (function testTwo() {
          const entries = [{ value: 10, idx: 0 }, { value: 20, idx: 1 }];
          const r = _inlineOutliersRobust(entries, 2);
          A(near(r.median, 15), "two: median=15", { got: r.median });
          // MAD: |10-15|=5, |20-15|=5 → median=(5+5)/2=5
          A(near(r.mad, 5), "two: MAD=5", { got: r.mad });
        })();

        // --- 7. NaN/undefined handling ---
        (function testNaN() {
          const entries = [{ value: NaN, idx: 0 }, { value: undefined, idx: 1 }, { value: 10, idx: 2 }, { value: 20, idx: 3 }];
          const r = _inlineOutliersRobust(entries, 4);
          // NaN/undefined → 0. Series: [0, 0, 10, 20]. Median=5, MAD=5.
          A(near(r.median, 5), "nan: median=5 (NaN→0)", { got: r.median });
          A(r.all.length === 4, "nan: all 4 entries processed");
          A(r.top.length === 4, "nan: top-4 returned");
        })();

        // --- 8. Stable tie-breaking: timestamp then hash ---
        (function testTieBreaking() {
          // All values identical → all |z|=0. Tie-break by timestamp asc, then hash asc.
          const entries = [
            { value: 5, idx: 0, ts: "2026-01-03", hash: "bbb" },
            { value: 5, idx: 1, ts: "2026-01-01", hash: "aaa" },
            { value: 5, idx: 2, ts: "2026-01-01", hash: "zzz" },
            { value: 5, idx: 3, ts: "2026-01-02", hash: "ccc" },
          ];
          const r = _inlineOutliersRobust(entries, 4);
          A(r.top[0].ts === "2026-01-01" && r.top[0].hash === "aaa", "tie: first is earliest ts + smallest hash", { got: r.top[0] });
          A(r.top[1].ts === "2026-01-01" && r.top[1].hash === "zzz", "tie: second is same ts, larger hash", { got: r.top[1] });
          A(r.top[2].ts === "2026-01-02", "tie: third is next timestamp", { got: r.top[2] });
          A(r.top[3].ts === "2026-01-03", "tie: fourth is latest", { got: r.top[3] });
        })();

        // --- 9. Evidence object structure ---
        (function testEvidence() {
          const entries = [
            { value: 1, idx: 0, buckets: [1, 4] },
            { value: 2, idx: 1, buckets: [2] },
            { value: 100, idx: 2, buckets: [3, 6, 8] },
          ];
          const r = _inlineOutliersRobust(entries, 3);
          const top0 = r.top[0];
          A(top0.evidence !== undefined, "evidence: exists on top entry");
          A(top0.evidence.value === top0.value, "evidence: value matches entry value");
          A(near(top0.evidence.median, r.median), "evidence: median matches result median");
          A(near(top0.evidence.mad, r.mad), "evidence: MAD matches result MAD");
          A(near(top0.evidence.z, top0.z), "evidence: z matches entry z");
          A(Array.isArray(top0.evidence.contributingBuckets), "evidence: contributingBuckets is array");
          // The outlier (100) has buckets [3, 6, 8].
          A(top0.value === 100, "evidence: top is 100");
          A(JSON.stringify(top0.evidence.contributingBuckets) === "[3,6,8]", "evidence: buckets=[3,6,8]", { got: top0.evidence.contributingBuckets });
        })();

        // --- 10. topK clamping ---
        (function testTopK() {
          const entries = [1, 2, 3].map((v, i) => ({ value: v, idx: i }));
          const r1 = _inlineOutliersRobust(entries, 100);
          A(r1.top.length === 3, "topK: clamped to series length", { got: r1.top.length });
          const r2 = _inlineOutliersRobust(entries, 0);
          A(r2.top.length === 1, "topK: min 1", { got: r2.top.length });
          const r3 = _inlineOutliersRobust(entries, -5);
          A(r3.top.length === 1, "topK: negative → min 1", { got: r3.top.length });
        })();

        // --- 11. Large outlier has highest |z| ---
        (function testLargestOutlier() {
          const entries = [1, 2, 3, 4, 5, 6, 7, 8, 9, 1000].map((v, i) => ({ value: v, idx: i }));
          const r = _inlineOutliersRobust(entries, 1);
          A(r.top[0].value === 1000, "largest: top-1 is 1000", { got: r.top[0].value });
          A(Math.abs(r.top[0].z) > 10, "largest: |z| > 10", { got: r.top[0].z });
        })();

        // --- 12. Negative values ---
        (function testNegative() {
          const entries = [-100, -5, 0, 5, 10].map((v, i) => ({ value: v, idx: i }));
          const r = _inlineOutliersRobust(entries, 2);
          A(near(r.median, 0), "negative: median=0", { got: r.median });
          A(r.top[0].value === -100, "negative: top[0] is -100 (largest deviation)", { got: r.top[0].value });
          A(r.top[0].z < 0, "negative: z is negative for -100", { got: r.top[0].z });
        })();

        // --- 13. buildOutlierMetricSeries ---
        (function testBuildSeries() {
          if (!DATASET.loaded || !ALL_COMMITS.length) {
            A(false, "buildSeries: need loaded dataset");
            return;
          }
          const series = buildOutlierMetricSeries(ALL_COMMITS);
          A("impact" in series, "buildSeries: has impact");
          A("linesAdded" in series, "buildSeries: has linesAdded");
          A("linesDeleted" in series, "buildSeries: has linesDeleted");
          A(series.impact.length === ALL_COMMITS.length, "buildSeries: impact length matches commits", { got: series.impact.length, expected: ALL_COMMITS.length });
          A(series.linesAdded.length === ALL_COMMITS.length, "buildSeries: linesAdded length matches");
          // Each entry should have value, ts, hash, idx, buckets.
          const e = series.impact[0];
          A("value" in e, "buildSeries: entry has value");
          A("ts" in e, "buildSeries: entry has ts");
          A("hash" in e, "buildSeries: entry has hash");
          A("idx" in e, "buildSeries: entry has idx");
          A("buckets" in e && Array.isArray(e.buckets), "buildSeries: entry has buckets array");
          console.log("  [Outlier] series keys:", Object.keys(series).join(", "), "entries:", series.impact.length);
        })();

        // --- 14. buildTimeBinSeries ---
        (function testTimeBins() {
          if (!DATASET.loaded || !ALL_COMMITS.length) {
            A(false, "timeBins: need loaded dataset");
            return;
          }
          const dayBins = buildTimeBinSeries(ALL_COMMITS, "day", "impact");
          A(Array.isArray(dayBins), "timeBins: day returns array");
          A(dayBins.length > 0, "timeBins: day has bins", { len: dayBins.length });
          A(dayBins.length <= ALL_COMMITS.length, "timeBins: day bins <= commits (aggregated)");
          // Each bin entry has value, ts, hash, idx, buckets.
          const b = dayBins[0];
          A(typeof b.value === "number", "timeBins: bin has numeric value");
          A(typeof b.ts === "string", "timeBins: bin has ts");
          A(Array.isArray(b.buckets), "timeBins: bin has buckets array");

          const weekBins = buildTimeBinSeries(ALL_COMMITS, "week", "impact");
          A(weekBins.length <= dayBins.length, "timeBins: week bins <= day bins", { week: weekBins.length, day: dayBins.length });

          const monthBins = buildTimeBinSeries(ALL_COMMITS, "month", "impact");
          A(monthBins.length <= weekBins.length, "timeBins: month bins <= week bins", { month: monthBins.length, week: weekBins.length });

          // Verify total sum matches.
          const totalDirect = ALL_COMMITS.reduce((s, c) => s + Number(c.impact || 0), 0);
          const totalBins = dayBins.reduce((s, b) => s + b.value, 0);
          A(near(totalDirect, totalBins, 0.1), "timeBins: day sum matches direct sum", { direct: totalDirect, bins: totalBins });
          console.log("  [Outlier] time bins: day=" + dayBins.length + " week=" + weekBins.length + " month=" + monthBins.length);
        })();

        // --- 15. Integration: full pipeline on ALL_COMMITS ---
        (function testFullPipeline() {
          if (!DATASET.loaded || !ALL_COMMITS.length) {
            A(false, "pipeline: need loaded dataset");
            return;
          }
          const series = buildOutlierMetricSeries(ALL_COMMITS);
          const impactResult = _inlineOutliersRobust(series.impact, 5);
          A(impactResult.top.length === Math.min(5, ALL_COMMITS.length), "pipeline: top-5 from impact");
          A(impactResult.median >= 0, "pipeline: median >= 0", { got: impactResult.median });
          A(impactResult.mad >= 0, "pipeline: MAD >= 0", { got: impactResult.mad });
          // Top outlier should have the largest |z|.
          if (impactResult.top.length > 1) {
            A(Math.abs(impactResult.top[0].z) >= Math.abs(impactResult.top[1].z), "pipeline: top[0] |z| >= top[1] |z|");
          }
          // Every top entry has evidence.
          A(impactResult.top.every(e => e.evidence && typeof e.evidence.value === "number"), "pipeline: all top have evidence");
          console.log("  [Outlier] pipeline: median=" + impactResult.median.toFixed(1) + " MAD=" + impactResult.mad.toFixed(1) + " top[0]=" + JSON.stringify(impactResult.top[0]?.evidence || {}));
        })();

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Outlier Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Outlier Unit Tests ----

      // ---- Outlier E2E Tests (bd-24q.10.4) ----
      // Run via console: window.__runOutlierE2ETests()
      // Requires dataset to be loaded.
      window.__runOutlierE2ETests = async function () {
        const R = [];
        const log = (msg, ctx) => console.log("  [OUT-E2E]", msg, ctx || "");
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("  FAIL:", m, x || ""); else log("PASS: " + m); };
        const wait = (ms) => new Promise((r) => setTimeout(r, ms));

        if (!DATASET.loaded || ALL_COMMITS.length < 10) {
          console.error("OUT-E2E: Need loaded dataset with >= 10 commits.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded or < 10 commits" }] };
        }

        const panel = document.getElementById("outlierPanel");
        const listEl = document.getElementById("outlierList");
        const metricSel = document.getElementById("outlierMetricSel");
        const topKSel = document.getElementById("outlierTopKSel");
        if (!panel || !listEl || !metricSel || !topKSel) {
          console.error("OUT-E2E: Missing outlier panel DOM elements.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Missing outlier DOM elements" }] };
        }

        const origIdx = DOC.idx;
        const origMetric = metricSel.value;
        const origTopK = topKSel.value;

        // --- E2E 1: Default render populates outlier list ---
        await (async function testE2E_defaultRender() {
          metricSel.value = "impact";
          topKSel.value = "10";
          metricSel.dispatchEvent(new Event("change"));
          await wait(2000); // Worker computation can be slow.

          const items = listEl.querySelectorAll("[data-outlier-hash]");
          log("Default render: " + items.length + " outlier items");
          A(items.length > 0, "out-e2e: outlier list populated", { count: items.length });
          A(items.length <= 10, "out-e2e: at most topK=10 items", { count: items.length });

          // Each item should have a hash, rank, and z-score.
          if (items.length > 0) {
            const first = items[0];
            const hash = first.dataset.outlierHash;
            A(hash && hash.length >= 7, "out-e2e: first item has hash", { hash });
            A(first.textContent.includes("#1"), "out-e2e: first item shows rank #1");
            A(first.textContent.includes("z="), "out-e2e: first item shows z-score");
          }
        })();

        // --- E2E 2: Change metric to lev -> list updates ---
        await (async function testE2E_changeMetric() {
          metricSel.value = "impact";
          metricSel.dispatchEvent(new Event("change"));
          await wait(2000);
          const impactItems = listEl.querySelectorAll("[data-outlier-hash]");
          const impactHash = impactItems.length > 0 ? impactItems[0].dataset.outlierHash : "";

          metricSel.value = "lev";
          metricSel.dispatchEvent(new Event("change"));
          await wait(2000);
          const levItems = listEl.querySelectorAll("[data-outlier-hash]");
          const levHash = levItems.length > 0 ? levItems[0].dataset.outlierHash : "";

          log("Impact #1: " + impactHash.slice(0, 7) + ", Lev #1: " + levHash.slice(0, 7));
          A(levItems.length > 0, "out-e2e: lev metric has outlier items", { count: levItems.length });
          // Different metrics likely produce different top outliers.
          if (impactItems.length > 0 && levItems.length > 0) {
            // Just verify both rendered (they may or may not differ).
            A(true, "out-e2e: both metrics rendered outliers");
          }
        })();

        // --- E2E 3: Change Top-K to 5 -> fewer items ---
        await (async function testE2E_changeTopK() {
          metricSel.value = "impact";
          topKSel.value = "5";
          metricSel.dispatchEvent(new Event("change"));
          await wait(2000);

          const items5 = listEl.querySelectorAll("[data-outlier-hash]");
          log("TopK=5: " + items5.length + " items");
          A(items5.length > 0, "out-e2e: topK=5 has items", { count: items5.length });
          A(items5.length <= 5, "out-e2e: topK=5 limits to 5 items", { count: items5.length });

          topKSel.value = "20";
          metricSel.dispatchEvent(new Event("change"));
          await wait(2000);

          const items20 = listEl.querySelectorAll("[data-outlier-hash]");
          log("TopK=20: " + items20.length + " items");
          A(items20.length >= items5.length, "out-e2e: topK=20 has >= topK=5 items", { k5: items5.length, k20: items20.length });
        })();

        // --- E2E 4: Click outlier item -> jumps to commit ---
        await (async function testE2E_clickJumpsToCommit() {
          metricSel.value = "impact";
          topKSel.value = "10";
          metricSel.dispatchEvent(new Event("change"));
          await wait(2000);

          const items = listEl.querySelectorAll("[data-outlier-hash]");
          if (items.length < 1) {
            A(false, "out-e2e: no outlier items to click");
            return;
          }

          // Select a different commit first.
          selectCommitIdx(0);
          await wait(200);
          A(DOC.idx === 0, "out-e2e: start at idx 0");

          // Click the first outlier item.
          const firstHash = items[0].dataset.outlierHash;
          const expectedIdx = ALL_COMMITS.findIndex(c => c.hash === firstHash);
          items[0].click();
          await wait(300);

          log("Clicked outlier #1: hash=" + firstHash.slice(0, 7) + ", expected idx=" + expectedIdx + ", got idx=" + DOC.idx);
          A(DOC.idx === expectedIdx, "out-e2e: click jumped to correct commit", { expected: expectedIdx, got: DOC.idx });
          A(DOC.idx !== 0, "out-e2e: commit index changed from 0", { got: DOC.idx });
        })();

        // --- E2E 5: Click different outlier items -> different commits ---
        await (async function testE2E_clickDifferentOutliers() {
          metricSel.value = "impact";
          topKSel.value = "10";
          metricSel.dispatchEvent(new Event("change"));
          await wait(2000);

          const items = listEl.querySelectorAll("[data-outlier-hash]");
          if (items.length < 2) {
            log("Only " + items.length + " outlier(s), skipping multi-click test");
            A(true, "out-e2e: skipped multi-click (insufficient outliers)");
            return;
          }

          items[0].click();
          await wait(200);
          const idx1 = DOC.idx;

          items[1].click();
          await wait(200);
          const idx2 = DOC.idx;

          log("Outlier #1 idx=" + idx1 + ", Outlier #2 idx=" + idx2);
          A(idx1 !== idx2, "out-e2e: different outliers select different commits", { idx1, idx2 });
        })();

        // --- E2E 6: Chart annotations appear on timeline ---
        await (async function testE2E_chartAnnotations() {
          metricSel.value = "impact";
          topKSel.value = "10";
          metricSel.dispatchEvent(new Event("change"));
          await wait(2000);

          if (!chartTimeline) {
            log("chartTimeline not available, skipping annotation test");
            A(true, "out-e2e: skipped chart annotation (no chartTimeline)");
            return;
          }

          const opt = chartTimeline.getOption();
          const series = opt?.series || [];
          // Check if any series has markPoint data (outlier annotations).
          let hasMarkPoints = false;
          for (const s of series) {
            const mp = s.markPoint?.data;
            if (mp && mp.length > 0) {
              hasMarkPoints = true;
              log("Found " + mp.length + " mark points on series");
              break;
            }
          }
          A(hasMarkPoints, "out-e2e: timeline chart has outlier mark points");
        })();

        // --- E2E 7: Z-score bar color coding ---
        await (async function testE2E_zScoreColors() {
          metricSel.value = "impact";
          topKSel.value = "10";
          metricSel.dispatchEvent(new Event("change"));
          await wait(2000);

          const items = listEl.querySelectorAll("[data-outlier-hash]");
          if (items.length < 1) {
            A(false, "out-e2e: no items for z-score color test");
            return;
          }

          // Check that z-score text is present and uses a color class.
          let foundZScore = false;
          for (const item of items) {
            const zMatch = item.textContent.match(/z=(\d+\.\d+)/);
            if (zMatch) {
              foundZScore = true;
              const z = parseFloat(zMatch[1]);
              log("Found z=" + z);
              // Verify the z-score span has appropriate coloring.
              const zSpan = item.querySelector("[style*='color:']");
              A(zSpan != null, "out-e2e: z-score element has color styling");
              break;
            }
          }
          A(foundZScore, "out-e2e: at least one z-score found in items");
        })();

        // --- E2E 8: Loading/empty state handling ---
        await (async function testE2E_loadingState() {
          const loading = document.getElementById("outlierLoading");
          const empty = document.getElementById("outlierEmpty");
          A(loading != null, "out-e2e: loading element exists");
          A(empty != null, "out-e2e: empty element exists");
          // After successful render, both should be hidden.
          metricSel.value = "impact";
          topKSel.value = "10";
          metricSel.dispatchEvent(new Event("change"));
          await wait(2500);
          A(loading.classList.contains("hidden"), "out-e2e: loading hidden after render", { classes: loading.className });
        })();

        // --- Restore original state ---
        metricSel.value = origMetric;
        topKSel.value = origTopK;
        metricSel.dispatchEvent(new Event("change"));
        selectCommitIdx(origIdx);
        await wait(300);
        log("Restored: idx=" + origIdx + ", metric=" + origMetric + ", topK=" + origTopK);

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Outlier E2E Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Outlier E2E Tests ----


      // ---- Heat Stripe Unit Tests (bd-24q.13.3) ----
      // Run via console: window.__runHeatStripeTests()
      window.__runHeatStripeTests = function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || "") };
        const near = (a, b, eps) => Math.abs(a - b) < (eps || 0.01);

        if (!DATASET.loaded || !ALL_COMMITS.length) {
          console.error("HeatStripe: Need loaded dataset.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded" }] };
        }

        // Clear cache before tests to ensure fresh computation.
        _heatStripeCache.clear();

        // --- 1. computeHeatStripe returns correct structure ---
        (function testStructure() {
          const stripe = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          A(stripe !== null && stripe !== undefined, "struct: result is not null");
          A(Array.isArray(stripe.bins), "struct: has bins array");
          A(typeof stripe.maxMass === "number", "struct: has numeric maxMass");
          A(typeof stripe.binCount === "number", "struct: has binCount");
          A(stripe.binCount === stripe.bins.length, "struct: binCount matches bins.length", { binCount: stripe.binCount, binsLen: stripe.bins.length });
          A(stripe.bins.length > 0, "struct: at least 1 bin", { len: stripe.bins.length });
        })();

        // --- 2. Bin structure ---
        (function testBinStructure() {
          const stripe = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          const bin = stripe.bins[0];
          A("label" in bin, "bin: has label");
          A(typeof bin.totalMass === "number", "bin: has numeric totalMass");
          A(bin.perBucket instanceof Map, "bin: perBucket is Map");
          A(typeof bin.dominant === "number", "bin: dominant is numeric id");
          A(typeof bin.dominantColor === "string" && bin.dominantColor.startsWith("#"), "bin: dominantColor is hex string", { got: bin.dominantColor });
          A("repCommit" in bin, "bin: has repCommit");
          A(typeof bin.repCommitIdx === "number", "bin: has numeric repCommitIdx");
          A(typeof bin.empty === "boolean", "bin: has boolean empty");
        })();

        // --- 3. Commit resolution: one bin per unique short hash ---
        (function testCommitResolution() {
          _heatStripeCache.clear();
          const stripe = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          const uniqueShorts = new Set(ALL_COMMITS.map(c => c.short));
          A(stripe.bins.length === uniqueShorts.size, "commit-res: bins = unique short hashes", { bins: stripe.bins.length, unique: uniqueShorts.size });
        })();

        // --- 4. First and last bins map to first and last commits ---
        (function testFirstLastBins() {
          _heatStripeCache.clear();
          const stripe = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          const firstBin = stripe.bins[0];
          const lastBin = stripe.bins[stripe.bins.length - 1];
          A(firstBin.label === ALL_COMMITS[0].short, "first-last: first bin label matches first commit short", { got: firstBin.label, expected: ALL_COMMITS[0].short });
          const lastCommitShort = ALL_COMMITS[ALL_COMMITS.length - 1].short;
          A(lastBin.label === lastCommitShort, "first-last: last bin label matches last commit short", { got: lastBin.label, expected: lastCommitShort });
        })();

        // --- 5. No gaps: bins cover all commits ---
        (function testNoGaps() {
          _heatStripeCache.clear();
          const stripe = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          // Sum of all bin masses should equal sum of all commit impacts.
          const totalBinMass = stripe.bins.reduce((s, b) => s + b.totalMass, 0);
          const totalCommitImpact = ALL_COMMITS.reduce((s, c) => s + Number(c.impact || 0), 0);
          A(near(totalBinMass, totalCommitImpact, 1), "no-gaps: total bin mass matches commit impact sum", { binMass: totalBinMass, commitImpact: totalCommitImpact });
        })();

        // --- 6. Dominant bucket: deterministic tie-breaking (highest contribution, then lowest id) ---
        (function testDominantTieBreak() {
          _heatStripeCache.clear();
          const stripe = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          for (const bin of stripe.bins) {
            if (bin.empty) continue;
            let maxContrib = 0;
            for (const b of BUCKETS) {
              const contrib = bin.perBucket.get(b.id) || 0;
              if (contrib > maxContrib) maxContrib = contrib;
            }
            // Dominant should have >= maxContrib. If tie, should be lowest id.
            const domContrib = bin.perBucket.get(bin.dominant) || 0;
            A(domContrib === maxContrib, "dominant: has max contribution in bin " + bin.label, { dominant: bin.dominant, domContrib, maxContrib });
            // If there are ties, dominant should be lowest id among them.
            const tiedIds = [];
            for (const b of BUCKETS) {
              if ((bin.perBucket.get(b.id) || 0) === maxContrib) tiedIds.push(b.id);
            }
            if (tiedIds.length > 1) {
              A(bin.dominant === Math.min(...tiedIds), "dominant: tie-break to lowest id in bin " + bin.label, { dominant: bin.dominant, tied: tiedIds });
            }
          }
        })();

        // --- 7. Intensity scaling is monotone: higher mass → higher normalized intensity ---
        (function testIntensityMonotone() {
          _heatStripeCache.clear();
          const stripe = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          A(stripe.maxMass >= 0, "intensity: maxMass >= 0", { got: stripe.maxMass });
          // All bins should have totalMass <= maxMass.
          for (const bin of stripe.bins) {
            A(bin.totalMass <= stripe.maxMass + 0.001, "intensity: bin mass <= maxMass", { label: bin.label, mass: bin.totalMass, max: stripe.maxMass });
          }
          // The bin with the highest mass should equal maxMass.
          const maxBin = stripe.bins.reduce((a, b) => a.totalMass > b.totalMass ? a : b);
          A(near(maxBin.totalMass, stripe.maxMass, 0.001), "intensity: max bin equals maxMass", { got: maxBin.totalMass, expected: stripe.maxMass });
        })();

        // --- 8. Representative commit is the one with highest metric value in bin ---
        (function testRepCommit() {
          _heatStripeCache.clear();
          const stripe = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          // For commit-resolution, each bin has one commit, so repCommit should match.
          const bin = stripe.bins.find(b => b.repCommit !== null);
          if (bin) {
            A(bin.repCommit !== null, "rep: has representative commit");
            A(bin.repCommitIdx >= 0, "rep: repCommitIdx >= 0", { got: bin.repCommitIdx });
            A(bin.repCommitIdx < ALL_COMMITS.length, "rep: repCommitIdx in range", { got: bin.repCommitIdx, max: ALL_COMMITS.length - 1 });
          }
        })();

        // --- 9. Different metrics produce different results ---
        (function testDifferentMetrics() {
          _heatStripeCache.clear();
          const linesStripe = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          _heatStripeCache.clear();
          const groupsStripe = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "groups", bucketMode: "primary" });
          // Groups metric: totalMass counts number of groups, so values are smaller integers.
          const linesMax = linesStripe.maxMass;
          const groupsMax = groupsStripe.maxMass;
          // They should generally differ (unless dataset is degenerate).
          A(linesStripe.bins.length === groupsStripe.bins.length, "metrics: same bin count", { lines: linesStripe.bins.length, groups: groupsStripe.bins.length });
          console.log("  [HeatStripe] lines maxMass=" + linesMax + " groups maxMass=" + groupsMax);
        })();

        // --- 10. Primary vs multi bucket mode ---
        (function testBucketModes() {
          _heatStripeCache.clear();
          const primary = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          _heatStripeCache.clear();
          const multi = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "multi" });
          A(primary.bins.length === multi.bins.length, "modes: same bin count");
          // In multi mode, total mass per bin can be >= primary mode (multi-labeling).
          let primaryTotal = 0, multiTotal = 0;
          for (const b of primary.bins) primaryTotal += b.totalMass;
          for (const b of multi.bins) multiTotal += b.totalMass;
          // Multi should spread same or higher (lines metric distributes by label count).
          A(near(primaryTotal, multiTotal, 1), "modes: total mass roughly equal for lines metric", { primary: primaryTotal, multi: multiTotal });
          console.log("  [HeatStripe] primary total=" + primaryTotal.toFixed(1) + " multi total=" + multiTotal.toFixed(1));
        })();

        // --- 11. Cache hit ---
        (function testCache() {
          _heatStripeCache.clear();
          const stripe1 = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          const stripe2 = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          A(stripe1 === stripe2, "cache: second call returns same reference (cached)");
          A(stripe1.cacheKey === stripe2.cacheKey, "cache: same cacheKey");
        })();

        // --- 12. perBucket covers all BUCKETS ---
        (function testPerBucketCoverage() {
          _heatStripeCache.clear();
          const stripe = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          const bin = stripe.bins[0];
          for (const b of BUCKETS) {
            A(bin.perBucket.has(b.id), "perBucket: has bucket id " + b.id);
            A(typeof bin.perBucket.get(b.id) === "number", "perBucket: bucket " + b.id + " is numeric");
          }
        })();

        // --- 13. Empty bins (if any in time-bin mode) ---
        (function testEmptyBins() {
          if (typeof buildWallClockBins !== "function") {
            console.log("  [HeatStripe] Skipping empty bin test (buildWallClockBins not available)");
            return;
          }
          _heatStripeCache.clear();
          const stripe = computeHeatStripe(ALL_COMMITS, { resolution: "day", metric: "lines", bucketMode: "primary" });
          if (!stripe || !stripe.bins) {
            console.log("  [HeatStripe] Skipping empty bin test (day resolution returned null)");
            return;
          }
          const emptyBins = stripe.bins.filter(b => b.empty);
          console.log("  [HeatStripe] day bins: " + stripe.bins.length + " (" + emptyBins.length + " empty)");
          for (const b of emptyBins) {
            A(b.totalMass === 0, "empty: empty bin has 0 mass", { label: b.label });
          }
        })();

        // --- 14. Diagnostic output ---
        (function testDiagnostic() {
          _heatStripeCache.clear();
          const stripe = computeHeatStripe(ALL_COMMITS, { resolution: "commit", metric: "lines", bucketMode: "primary" });
          const sample = stripe.bins.slice(0, 3).map(b => ({
            label: b.label, mass: b.totalMass.toFixed(1), dominant: b.dominant, rep: b.repCommit?.short || "none",
          }));
          console.log("  [HeatStripe] sample bins:", JSON.stringify(sample));
          console.log("  [HeatStripe] binCount=" + stripe.binCount + " maxMass=" + stripe.maxMass.toFixed(1));
          A(true, "diagnostic: logged successfully");
        })();

        // --- Summary ---
        _heatStripeCache.clear(); // Clean up test cache pollution.
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Heat Stripe Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Heat Stripe Unit Tests ----

      // ---- Heat Stripe E2E Tests (bd-24q.13.4) ----
      // Run via console: window.__runHeatStripeE2ETests()
      // Requires dataset to be loaded.
      window.__runHeatStripeE2ETests = async function () {
        const R = [];
        const log = (msg, ctx) => console.log("  [HS-E2E]", msg, ctx || "");
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("  FAIL:", m, x || ""); else log("PASS: " + m); };
        const wait = (ms) => new Promise((r) => setTimeout(r, ms));

        if (!DATASET.loaded || ALL_COMMITS.length < 5) {
          console.error("HS-E2E: Need loaded dataset with >= 5 commits.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded or < 5 commits" }] };
        }

        const canvas = document.getElementById("dockHeatStripe");
        const tooltip = document.getElementById("dockHeatTooltip");
        if (!canvas || !tooltip) {
          console.error("HS-E2E: Missing dockHeatStripe canvas or dockHeatTooltip div.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Missing heat stripe DOM elements" }] };
        }

        const origIdx = DOC.idx;

        // Ensure stripe is rendered.
        renderHeatStripe();
        await wait(200);

        const stripe = computeHeatStripe(ALL_COMMITS, {
          resolution: "commit",
          tzMode: "local",
          metric: "lines",
          bucketMode: STATE.bucketMode,
        });

        // --- E2E 1: Canvas rendered with correct dimensions ---
        await (async function testE2E_canvasRendered() {
          A(canvas.width > 0, "hs-e2e: canvas width > 0", { got: canvas.width });
          A(canvas.height > 0, "hs-e2e: canvas height > 0", { got: canvas.height });
          A(stripe != null, "hs-e2e: computeHeatStripe returns data");
          A(stripe.bins.length > 0, "hs-e2e: bins array is non-empty", { got: stripe.bins.length });
          A(stripe.bins.length === ALL_COMMITS.length, "hs-e2e: commit mode has one bin per commit", { bins: stripe.bins.length, commits: ALL_COMMITS.length });
        })();

        // --- E2E 2: Mousemove shows tooltip with expected fields ---
        await (async function testE2E_tooltipOnHover() {
          const rect = canvas.getBoundingClientRect();
          const midX = rect.left + rect.width / 2;
          const midY = rect.top + rect.height / 2;

          // Simulate mousemove over middle of stripe.
          const moveEvt = new MouseEvent("mousemove", { clientX: midX, clientY: midY, bubbles: true });
          canvas.dispatchEvent(moveEvt);
          await wait(100);

          A(!tooltip.classList.contains("hidden"), "hs-e2e: tooltip visible after mousemove");
          const html = tooltip.innerHTML;
          log("Tooltip content sample: " + html.slice(0, 120));

          // Tooltip should contain commit hash (short, 7 chars hex).
          const hasHash = /<strong>[a-f0-9]{7}<\/strong>/i.test(html);
          A(hasHash, "hs-e2e: tooltip contains commit short hash", { html: html.slice(0, 200) });

          // Tooltip should mention "dominant".
          A(html.includes("dominant"), "hs-e2e: tooltip shows dominant bucket", { html: html.slice(0, 200) });

          // Tooltip should mention mass (lines).
          A(html.includes("lines"), "hs-e2e: tooltip shows mass in lines", { html: html.slice(0, 200) });
        })();

        // --- E2E 3: Mouseleave hides tooltip ---
        await (async function testE2E_tooltipHidesOnLeave() {
          const leaveEvt = new MouseEvent("mouseleave", { bubbles: true });
          canvas.dispatchEvent(leaveEvt);
          await wait(100);

          A(tooltip.classList.contains("hidden"), "hs-e2e: tooltip hidden after mouseleave");
        })();

        // --- E2E 4: Click on stripe changes commit index ---
        await (async function testE2E_clickJumpsToCommit() {
          // Click near the start (25% from left).
          const rect = canvas.getBoundingClientRect();
          const clickX = rect.left + rect.width * 0.25;
          const clickY = rect.top + rect.height / 2;

          selectCommitIdx(ALL_COMMITS.length - 1); // Start at end.
          await wait(100);
          const before = DOC.idx;

          const clickEvt = new MouseEvent("click", { clientX: clickX, clientY: clickY, bubbles: true });
          canvas.dispatchEvent(clickEvt);
          await wait(200);

          const after = DOC.idx;
          log("Click at 25%: before=" + before + ", after=" + after);
          A(after !== before, "hs-e2e: click changed commit index", { before, after });
          // 25% of the stripe should select a commit roughly in the first quarter.
          const quarter = Math.floor(ALL_COMMITS.length * 0.35);
          A(after <= quarter, "hs-e2e: clicking left quarter selects early commit", { after, quarter });
        })();

        // --- E2E 5: Click at different positions selects different commits ---
        await (async function testE2E_differentClicksDifferentCommits() {
          const rect = canvas.getBoundingClientRect();
          const y = rect.top + rect.height / 2;

          // Click at 10%.
          const click1 = new MouseEvent("click", { clientX: rect.left + rect.width * 0.1, clientY: y, bubbles: true });
          canvas.dispatchEvent(click1);
          await wait(100);
          const idx1 = DOC.idx;

          // Click at 90%.
          const click2 = new MouseEvent("click", { clientX: rect.left + rect.width * 0.9, clientY: y, bubbles: true });
          canvas.dispatchEvent(click2);
          await wait(100);
          const idx2 = DOC.idx;

          log("10% click: idx=" + idx1 + ", 90% click: idx=" + idx2);
          A(idx2 > idx1, "hs-e2e: right click selects later commit than left click", { idx1, idx2 });
        })();

        // --- E2E 6: Tooltip updates when moving to different bin ---
        await (async function testE2E_tooltipUpdatesOnMove() {
          const rect = canvas.getBoundingClientRect();
          const y = rect.top + rect.height / 2;

          // Hover at 20%.
          const move1 = new MouseEvent("mousemove", { clientX: rect.left + rect.width * 0.2, clientY: y, bubbles: true });
          canvas.dispatchEvent(move1);
          await wait(100);
          const html1 = tooltip.innerHTML;

          // Hover at 80%.
          const move2 = new MouseEvent("mousemove", { clientX: rect.left + rect.width * 0.8, clientY: y, bubbles: true });
          canvas.dispatchEvent(move2);
          await wait(100);
          const html2 = tooltip.innerHTML;

          log("Tooltip at 20%: " + html1.slice(0, 60) + "...");
          log("Tooltip at 80%: " + html2.slice(0, 60) + "...");
          A(html1 !== html2, "hs-e2e: tooltip content differs for different bins");

          // Cleanup.
          canvas.dispatchEvent(new MouseEvent("mouseleave", { bubbles: true }));
        })();

        // --- E2E 7: Selected marker updates after click ---
        await (async function testE2E_selectedMarkerUpdates() {
          const rect = canvas.getBoundingClientRect();
          const y = rect.top + rect.height / 2;

          // Click at 50%.
          canvas.dispatchEvent(new MouseEvent("click", { clientX: rect.left + rect.width * 0.5, clientY: y, bubbles: true }));
          await wait(200);

          // After click, DOC.idx should be roughly in the middle.
          const mid = DOC.idx;
          const expected = Math.floor(ALL_COMMITS.length * 0.5);
          const tolerance = Math.max(3, Math.floor(ALL_COMMITS.length * 0.1));
          A(Math.abs(mid - expected) <= tolerance, "hs-e2e: 50% click selects mid-range commit", { mid, expected, tolerance });

          // Verify renderHeatStripe runs without error after index change.
          let threw = false;
          try { renderHeatStripe(); } catch (e) { threw = true; }
          A(!threw, "hs-e2e: renderHeatStripe succeeds after index change");
        })();

        // --- Restore original state ---
        selectCommitIdx(origIdx);
        await wait(200);
        canvas.dispatchEvent(new MouseEvent("mouseleave", { bubbles: true }));
        log("Restored: idx=" + origIdx);

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Heat Stripe E2E Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Heat Stripe E2E Tests ----


      // ---- Phase Map Unit Tests (bd-24q.11.3) ----
      // Run via console: window.__runPhaseMapTests()
      window.__runPhaseMapTests = function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || "") };
        const near = (a, b, eps) => Math.abs(a - b) < (eps || 0.01);

        // Helper: generate synthetic piecewise-stationary series.
        function generatePiecewise(segments) {
          const values = [];
          const metadata = [];
          for (const seg of segments) {
            for (let i = 0; i < seg.n; i++) {
              const noise = (Math.random() - 0.5) * (seg.noise || 0);
              values.push(seg.mean + noise);
              metadata.push({ ts: "2026-01-01", hash: "h" + values.length, idx: values.length - 1, buckets: seg.buckets || [] });
            }
          }
          return { values, metadata };
        }

        // --- 1. Basic two-segment detection ---
        (function testTwoSegment() {
          // Segment 1: mean=1, n=30. Segment 2: mean=10, n=30. Clear shift.
          const { values, metadata } = generatePiecewise([
            { mean: 1, n: 30, noise: 0.5 },
            { mean: 10, n: 30, noise: 0.5 },
          ]);
          const result = _inlinePhaseMapEnhanced(values, 0.05, metadata);
          A(result.p0.length === 60, "2seg: p0 length = 60", { got: result.p0.length });
          A(result.changePoints.length >= 1, "2seg: at least 1 change point detected", { cps: result.changePoints });
          // Change point should be near index 30 (±5).
          const nearCP = result.changePoints.some(cp => Math.abs(cp - 30) <= 5);
          A(nearCP, "2seg: change point near index 30 (±5)", { cps: result.changePoints });
          console.log("  [PhaseMap] 2-segment CPs:", result.changePoints.join(","));
        })();

        // --- 2. Three-segment detection ---
        (function testThreeSegment() {
          const { values, metadata } = generatePiecewise([
            { mean: 0, n: 25, noise: 0.3 },
            { mean: 8, n: 25, noise: 0.3 },
            { mean: 2, n: 25, noise: 0.3 },
          ]);
          const result = _inlinePhaseMapEnhanced(values, 0.05, metadata);
          A(result.changePoints.length >= 2, "3seg: at least 2 change points", { cps: result.changePoints });
          console.log("  [PhaseMap] 3-segment CPs:", result.changePoints.join(","));
        })();

        // --- 3. Constant series: no change points ---
        (function testConstant() {
          const values = new Array(50).fill(5);
          const result = _inlinePhaseMapEnhanced(values, 0.05, []);
          A(result.changePoints.length === 0, "constant: no change points", { cps: result.changePoints });
          A(result.segments.length === 1, "constant: 1 segment", { segs: result.segments.length });
        })();

        // --- 4. Single spike ---
        (function testSingleSpike() {
          const values = new Array(50).fill(1);
          values[25] = 100; // Large spike.
          const result = _inlinePhaseMapEnhanced(values, 0.05, []);
          // A single spike may or may not trigger a CP depending on hazard.
          // The key test is that the algorithm doesn't crash and returns valid structure.
          A(result.p0.length === 50, "spike: p0 length = 50");
          A(Array.isArray(result.segments), "spike: has segments");
          A(Array.isArray(result.evidence), "spike: has evidence");
          console.log("  [PhaseMap] spike CPs:", result.changePoints.join(","), "segs:", result.segments.length);
        })();

        // --- 5. Output structure validation ---
        (function testStructure() {
          const values = [1, 1, 1, 10, 10, 10, 1, 1, 1];
          const meta = values.map((v, i) => ({ ts: "2026-01-0" + (i + 1), hash: "h" + i, idx: i, buckets: [1, 4] }));
          const result = _inlinePhaseMapEnhanced(values, 0.1, meta);
          A("p0" in result, "struct: has p0");
          A("changePoints" in result, "struct: has changePoints");
          A("segments" in result, "struct: has segments");
          A("evidence" in result, "struct: has evidence");
          A("hazard" in result, "struct: has hazard");
          A("seriesLength" in result, "struct: has seriesLength");
          A(result.seriesLength === 9, "struct: seriesLength = 9", { got: result.seriesLength });
          A(near(result.hazard, 0.1), "struct: hazard = 0.1", { got: result.hazard });
        })();

        // --- 6. Segments cover all indices (no gaps/overlaps) ---
        (function testSegmentCoverage() {
          const { values, metadata } = generatePiecewise([
            { mean: 0, n: 20, noise: 0.2 },
            { mean: 5, n: 20, noise: 0.2 },
            { mean: 1, n: 20, noise: 0.2 },
          ]);
          const result = _inlinePhaseMapEnhanced(values, 0.05, metadata);
          // Segments should cover [0, length-1] with no gaps.
          A(result.segments.length >= 1, "coverage: at least 1 segment");
          A(result.segments[0].start === 0, "coverage: first segment starts at 0", { got: result.segments[0].start });
          const lastSeg = result.segments[result.segments.length - 1];
          A(lastSeg.end === values.length - 1, "coverage: last segment ends at length-1", { got: lastSeg.end, expected: values.length - 1 });
          // Check for gaps.
          for (let i = 1; i < result.segments.length; i++) {
            const prevEnd = result.segments[i - 1].end;
            const currStart = result.segments[i].start;
            A(currStart === prevEnd + 1, "coverage: no gap between segments " + (i - 1) + " and " + i, { prevEnd, currStart });
          }
          // Total length should equal series length.
          const totalLen = result.segments.reduce((s, seg) => s + seg.length, 0);
          A(totalLen === values.length, "coverage: total segment length = series length", { total: totalLen, series: values.length });
        })();

        // --- 7. Posterior and confidence in [0, 1] ---
        (function testPosteriorBounds() {
          const values = [1, 2, 1, 2, 10, 11, 10, 11];
          const result = _inlinePhaseMapEnhanced(values, 0.1, []);
          for (let i = 0; i < result.p0.length; i++) {
            A(result.p0[i] >= -0.001 && result.p0[i] <= 1.001, "posterior: p0[" + i + "] in [0,1]", { got: result.p0[i] });
          }
          for (const seg of result.segments) {
            A(seg.confidence >= -0.001 && seg.confidence <= 1.001, "posterior: confidence in [0,1]", { got: seg.confidence });
            A(seg.avgP0 >= -0.001 && seg.avgP0 <= 1.001, "posterior: avgP0 in [0,1]", { got: seg.avgP0 });
          }
        })();

        // --- 8. Evidence ledger structure ---
        (function testEvidence() {
          const { values, metadata } = generatePiecewise([
            { mean: 0, n: 25, noise: 0.1, buckets: [1, 4] },
            { mean: 10, n: 25, noise: 0.1, buckets: [3, 6] },
          ]);
          const result = _inlinePhaseMapEnhanced(values, 0.05, metadata);
          A(result.evidence.length === result.changePoints.length, "evidence: count matches CPs", { evidence: result.evidence.length, cps: result.changePoints.length });
          for (const ev of result.evidence) {
            A(typeof ev.idx === "number", "evidence: has idx");
            A(typeof ev.posteriorP0 === "number", "evidence: has posteriorP0");
            A(ev.posteriorP0 > 0.5, "evidence: posteriorP0 > 0.5 (triggered CP)", { got: ev.posteriorP0 });
            A("before" in ev && "after" in ev, "evidence: has before/after");
            A(typeof ev.before.mean === "number", "evidence: before.mean is number");
            A(typeof ev.before.variance === "number", "evidence: before.variance is number");
            A(typeof ev.before.stddev === "number", "evidence: before.stddev is number");
            A(typeof ev.before.n === "number" && ev.before.n > 0, "evidence: before.n > 0");
            A(typeof ev.after.mean === "number", "evidence: after.mean is number");
            A(typeof ev.after.n === "number" && ev.after.n > 0, "evidence: after.n > 0");
            A(typeof ev.meanShift === "number", "evidence: has meanShift");
            A(typeof ev.varianceRatio === "number", "evidence: has varianceRatio");
          }
          // For a clear mean shift (0 → 10), meanShift should be positive.
          if (result.evidence.length > 0) {
            const ev0 = result.evidence[0];
            A(ev0.meanShift > 3, "evidence: meanShift > 3 for 0→10 shift", { got: ev0.meanShift });
            console.log("  [PhaseMap] evidence[0]: meanShift=" + ev0.meanShift.toFixed(2) + " varRatio=" + ev0.varianceRatio.toFixed(2) + " p0=" + ev0.posteriorP0.toFixed(3));
          }
        })();

        // --- 9. Segment stats are correct ---
        (function testSegmentStats() {
          const values = [5, 5, 5, 5, 5]; // Constant series.
          const result = _inlinePhaseMapEnhanced(values, 0.05, []);
          A(result.segments.length === 1, "segstats: 1 segment for constant series");
          const seg = result.segments[0];
          A(near(seg.mean, 5), "segstats: mean = 5", { got: seg.mean });
          A(near(seg.variance, 0), "segstats: variance = 0", { got: seg.variance });
          A(seg.length === 5, "segstats: length = 5", { got: seg.length });
        })();

        // --- 10. Hazard sensitivity ---
        (function testHazardSensitivity() {
          const { values, metadata } = generatePiecewise([
            { mean: 1, n: 30, noise: 1 },
            { mean: 5, n: 30, noise: 1 },
          ]);
          const highH = _inlinePhaseMapEnhanced(values, 0.3, metadata);
          const lowH = _inlinePhaseMapEnhanced(values, 0.01, metadata);
          // Higher hazard should detect more or equal change points (more sensitive).
          A(highH.changePoints.length >= lowH.changePoints.length, "hazard: high H >= low H CPs", { high: highH.changePoints.length, low: lowH.changePoints.length });
          console.log("  [PhaseMap] hazard sensitivity: H=0.3 CPs=" + highH.changePoints.length + " H=0.01 CPs=" + lowH.changePoints.length);
        })();

        // --- 11. Empty series ---
        (function testEmpty() {
          const result = _inlinePhaseMapEnhanced([], 0.05, []);
          A(result.p0.length === 0, "empty: p0 empty");
          A(result.changePoints.length === 0, "empty: no CPs");
          A(result.segments.length === 0, "empty: no segments");
          A(result.evidence.length === 0, "empty: no evidence");
        })();

        // --- 12. Metadata propagation ---
        (function testMetadata() {
          const values = [0, 0, 0, 10, 10, 10];
          const meta = values.map((v, i) => ({ ts: "2026-01-0" + (i + 1), hash: "hash" + i, idx: i, buckets: [i % 3 + 1] }));
          const result = _inlinePhaseMapEnhanced(values, 0.1, meta);
          // Segments should have startMeta and endMeta.
          for (const seg of result.segments) {
            if (seg.startMeta) A(typeof seg.startMeta.ts === "string", "meta: startMeta has ts");
            if (seg.endMeta) A(typeof seg.endMeta.hash === "string", "meta: endMeta has hash");
          }
          // Evidence should propagate metadata.
          for (const ev of result.evidence) {
            A(typeof ev.ts === "string", "meta: evidence has ts");
            A(typeof ev.hash === "string", "meta: evidence has hash");
            A(Array.isArray(ev.buckets), "meta: evidence has buckets");
          }
        })();

        // --- 13. Gradual drift (challenging case) ---
        (function testGradualDrift() {
          // Linear ramp: 0 to 20 over 50 points. BOCPD may or may not detect this.
          const values = Array.from({ length: 50 }, (_, i) => i * 0.4);
          const result = _inlinePhaseMapEnhanced(values, 0.05, []);
          // The key is that it runs without errors and returns valid structure.
          A(result.p0.length === 50, "drift: p0 length = 50");
          A(result.seriesLength === 50, "drift: seriesLength = 50");
          console.log("  [PhaseMap] gradual drift: CPs=" + result.changePoints.length + " segs=" + result.segments.length);
        })();

        // --- 14. Integration with ALL_COMMITS ---
        (function testIntegration() {
          if (!DATASET.loaded || !ALL_COMMITS.length) {
            A(false, "integration: need loaded dataset");
            return;
          }
          const values = ALL_COMMITS.map(c => Math.log1p(Number(c.impact || 0)));
          const meta = ALL_COMMITS.map(c => ({ ts: c.dateIso || "", hash: c.hash || "", idx: c.idx, buckets: c.labels || [] }));
          const result = _inlinePhaseMapEnhanced(values, 0.03, meta);
          A(result.p0.length === ALL_COMMITS.length, "integration: p0 length matches commits");
          A(result.segments.length >= 1, "integration: at least 1 segment");
          A(result.evidence.length === result.changePoints.length, "integration: evidence count matches CPs");
          // Total segment coverage.
          const totalLen = result.segments.reduce((s, seg) => s + seg.length, 0);
          A(totalLen === ALL_COMMITS.length, "integration: segments cover all commits", { total: totalLen, commits: ALL_COMMITS.length });
          console.log("  [PhaseMap] integration: CPs=" + result.changePoints.length + " segs=" + result.segments.length + " commits=" + ALL_COMMITS.length);
        })();

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Phase Map Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Phase Map Unit Tests ----

      // ---- Phase Map E2E Tests (bd-24q.11.4) ----
      // Run via console: window.__runPhaseMapE2ETests()
      // Requires dataset to be loaded.
      window.__runPhaseMapE2ETests = async function () {
        const R = [];
        const log = (msg, ctx) => console.log("  [PM-E2E]", msg, ctx || "");
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("  FAIL:", m, x || ""); else log("PASS: " + m); };
        const wait = (ms) => new Promise((r) => setTimeout(r, ms));

        if (!DATASET.loaded || ALL_COMMITS.length < 10) {
          console.error("PM-E2E: Need loaded dataset with >= 10 commits.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded or < 10 commits" }] };
        }

        if (!chartTimeline || !chartBocpd) {
          console.error("PM-E2E: Missing chartTimeline or chartBocpd ECharts instances.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Missing chart instances" }] };
        }

        const origIdx = DOC.idx;
        const origSegIdx = PHASE_FILTER.segIdx;
        const origHazard = document.getElementById("hazard")?.value;

        // Ensure phase data is computed.
        await maybeRefreshPhaseAndOutliers(ALL_COMMITS);
        await wait(2000);

        // --- E2E 1: Phase overlay renders on timeline chart ---
        await (async function testE2E_overlayRendered() {
          const phase = WORKER_DERIVED.phase;
          A(phase != null, "pm-e2e: WORKER_DERIVED.phase is populated");
          A(phase.segments?.length > 0, "pm-e2e: phase has segments", { count: phase?.segments?.length });
          A(phase.changePoints?.length >= 0, "pm-e2e: phase has changePoints array", { count: phase?.changePoints?.length });

          // Render overlay.
          renderPhaseOverlay(ALL_COMMITS);
          await wait(300);

          // Check timeline chart has markArea data.
          const timeOpt = chartTimeline.getOption();
          const series0 = timeOpt?.series?.[0];
          const markAreas = series0?.markArea?.data;
          A(markAreas != null && markAreas.length > 0, "pm-e2e: timeline has phase markAreas", { count: markAreas?.length });
          log("Phase segments: " + phase.segments.length + ", markAreas: " + (markAreas?.length || 0));
        })();

        // --- E2E 2: BOCPD chart also gets phase overlay ---
        await (async function testE2E_bocpdOverlay() {
          const bocpdOpt = chartBocpd.getOption();
          const series = bocpdOpt?.series || [];
          let hasMarkArea = false;
          for (const s of series) {
            if (s.markArea?.data?.length > 0) { hasMarkArea = true; break; }
          }
          A(hasMarkArea, "pm-e2e: BOCPD chart has phase markAreas");
        })();

        // --- E2E 3: Phase segments cover full commit range ---
        await (async function testE2E_segmentCoverage() {
          const phase = WORKER_DERIVED.phase;
          if (!phase?.segments?.length) { A(false, "pm-e2e: no segments for coverage test"); return; }

          const firstStart = phase.segments[0].start;
          const lastEnd = phase.segments[phase.segments.length - 1].end;
          A(firstStart === 0, "pm-e2e: first segment starts at 0", { got: firstStart });
          A(lastEnd === ALL_COMMITS.length - 1, "pm-e2e: last segment ends at max index", { got: lastEnd, max: ALL_COMMITS.length - 1 });

          // No gaps between segments.
          for (let i = 1; i < phase.segments.length; i++) {
            const prev = phase.segments[i - 1];
            const cur = phase.segments[i];
            A(cur.start === prev.end + 1, "pm-e2e: no gap between segments " + (i - 1) + " and " + i, { prevEnd: prev.end, curStart: cur.start });
          }
        })();

        // --- E2E 4: PHASE_FILTER changes highlight opacity ---
        await (async function testE2E_filterHighlight() {
          const phase = WORKER_DERIVED.phase;
          if (!phase?.segments?.length) { A(false, "pm-e2e: no segments for filter test"); return; }

          // Select first segment.
          PHASE_FILTER.segIdx = 0;
          renderPhaseOverlay(ALL_COMMITS);
          await wait(200);

          const opt1 = chartTimeline.getOption();
          const areas1 = opt1?.series?.[0]?.markArea?.data || [];
          if (areas1.length > 0) {
            const selectedOpacity = areas1[0]?.[0]?.itemStyle?.opacity;
            A(selectedOpacity === 0.18, "pm-e2e: selected segment has opacity 0.18", { got: selectedOpacity });
            if (areas1.length > 1) {
              const unselectedOpacity = areas1[1]?.[0]?.itemStyle?.opacity;
              A(unselectedOpacity === 0.06, "pm-e2e: unselected segment has opacity 0.06", { got: unselectedOpacity });
            }
          }

          // Clear filter.
          PHASE_FILTER.segIdx = -1;
          renderPhaseOverlay(ALL_COMMITS);
          await wait(200);

          const opt2 = chartTimeline.getOption();
          const areas2 = opt2?.series?.[0]?.markArea?.data || [];
          if (areas2.length > 0) {
            const allLow = areas2.every(a => a[0]?.itemStyle?.opacity === 0.06);
            A(allLow, "pm-e2e: all segments at 0.06 when no filter");
          }
        })();

        // --- E2E 5: Hazard slider changes recompute phases ---
        await (async function testE2E_hazardSlider() {
          const slider = document.getElementById("hazard");
          const label = document.getElementById("hazardLabel");
          if (!slider || !label) { A(false, "pm-e2e: missing hazard slider/label"); return; }

          // Set low hazard (fewer change points).
          slider.value = "0.01";
          slider.dispatchEvent(new Event("input"));
          await wait(3000);
          const phaseLow = WORKER_DERIVED.phase;
          const cpLow = phaseLow?.changePoints?.length || 0;

          // Set high hazard (more change points).
          slider.value = "0.30";
          slider.dispatchEvent(new Event("input"));
          await wait(3000);
          const phaseHigh = WORKER_DERIVED.phase;
          const cpHigh = phaseHigh?.changePoints?.length || 0;

          log("Hazard 0.01 CPs: " + cpLow + ", Hazard 0.30 CPs: " + cpHigh);
          A(cpHigh >= cpLow, "pm-e2e: higher hazard produces >= change points", { low: cpLow, high: cpHigh });
          A(label.textContent === "0.30", "pm-e2e: hazard label updated", { got: label.textContent });
        })();

        // --- E2E 6: Phase evidence structure is correct ---
        await (async function testE2E_evidenceStructure() {
          const phase = WORKER_DERIVED.phase;
          if (!phase?.evidence?.length) {
            log("No evidence entries (0 change points), skipping");
            A(true, "pm-e2e: skipped evidence test (no CPs)");
            return;
          }
          const ev = phase.evidence[0];
          A("idx" in ev, "pm-e2e: evidence has idx");
          A("posteriorP0" in ev, "pm-e2e: evidence has posteriorP0");
          A("before" in ev && "mean" in ev.before, "pm-e2e: evidence.before has mean");
          A("after" in ev && "mean" in ev.after, "pm-e2e: evidence.after has mean");
          A("meanShift" in ev, "pm-e2e: evidence has meanShift");
          A("varianceRatio" in ev, "pm-e2e: evidence has varianceRatio");
          log("Evidence[0]: idx=" + ev.idx + ", meanShift=" + ev.meanShift.toFixed(2) + ", P0=" + ev.posteriorP0.toFixed(4));
        })();

        // --- E2E 7: Segment stats are reasonable ---
        await (async function testE2E_segmentStats() {
          const phase = WORKER_DERIVED.phase;
          if (!phase?.segments?.length) { A(false, "pm-e2e: no segments for stats test"); return; }
          for (let i = 0; i < Math.min(3, phase.segments.length); i++) {
            const seg = phase.segments[i];
            A(seg.length > 0, "pm-e2e: segment " + i + " has positive length", { got: seg.length });
            A(typeof seg.mean === "number" && !isNaN(seg.mean), "pm-e2e: segment " + i + " has valid mean", { got: seg.mean });
            A(typeof seg.stddev === "number" && seg.stddev >= 0, "pm-e2e: segment " + i + " has non-negative stddev", { got: seg.stddev });
            A(seg.confidence >= 0 && seg.confidence <= 1, "pm-e2e: segment " + i + " confidence in [0,1]", { got: seg.confidence });
          }
        })();

        // --- Restore original state ---
        PHASE_FILTER.segIdx = origSegIdx;
        if (origHazard) {
          const slider = document.getElementById("hazard");
          if (slider) { slider.value = origHazard; slider.dispatchEvent(new Event("input")); }
        }
        selectCommitIdx(origIdx);
        await wait(500);
        log("Restored: idx=" + origIdx + ", segIdx=" + origSegIdx + ", hazard=" + origHazard);

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Phase Map E2E Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Phase Map E2E Tests ----
      // ---- History Search Unit Tests (bd-24q.9.4) ----
      // Run via console: window.__runSearchTests()
      window.__runSearchTests = async function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || ""); };
        const log = (m) => console.log("  [search]", m);

        // --- Tokenizer tests (via worker) ---
        log("Testing tokenizer via worker query_search...");

        // Test 1: Empty query returns no hits.
        try {
          const r1 = await workerRequest("query_search", { q: "", limit: 10 }, { timeoutMs: 5000 });
          A(Array.isArray(r1.hits), "tokenizer: empty query returns hits array");
          A(r1.hits.length === 0, "tokenizer: empty query -> 0 hits", { len: r1.hits.length });
        } catch (e) { A(false, "tokenizer: empty query threw", { err: String(e) }); }

        // Test 2: Nonsense query returns no hits.
        try {
          const r2 = await workerRequest("query_search", { q: "xyzzyplugh99999", limit: 10 }, { timeoutMs: 5000 });
          A(r2.hits.length === 0, "tokenizer: nonsense query -> 0 hits", { len: r2.hits.length });
        } catch (e) { A(false, "tokenizer: nonsense query threw", { err: String(e) }); }

        // Test 3: Known query returns results (spec-related term).
        try {
          const r3 = await workerRequest("query_search", { q: "MVCC", limit: 5 }, { timeoutMs: 10000 });
          A(r3.hits.length > 0, "tokenizer: MVCC query returns hits", { len: r3.hits.length });
          if (r3.hits.length > 0) {
            A(typeof r3.hits[0].idx === "number", "tokenizer: hit has idx field");
            A(typeof r3.hits[0].subject === "string", "tokenizer: hit has subject field");
            A(typeof r3.hits[0].score === "number", "tokenizer: hit has score field");
          }
        } catch (e) { A(false, "tokenizer: MVCC query threw", { err: String(e) }); }

        // Test 4: Quoted phrase search.
        try {
          const r4 = await workerRequest("query_search", { q: '"page-level versioning"', limit: 5 }, { timeoutMs: 10000 });
          A(Array.isArray(r4.hits), "tokenizer: phrase search returns array");
          log("Phrase search 'page-level versioning': " + r4.hits.length + " hits");
        } catch (e) { A(false, "tokenizer: phrase search threw", { err: String(e) }); }

        // Test 5: Limit respected.
        try {
          const r5 = await workerRequest("query_search", { q: "spec", limit: 2 }, { timeoutMs: 10000 });
          A(r5.hits.length <= 2, "tokenizer: limit=2 respected", { len: r5.hits.length });
        } catch (e) { A(false, "tokenizer: limit test threw", { err: String(e) }); }

        // --- Search index tests ---
        log("Testing search index...");

        // Test 6: Search index was built during warmup.
        A(WORKER_DERIVED.searchReady === true, "index: searchReady is true");

        // Test 7: Export/hydrate round-trip.
        try {
          const exported = await workerRequest("export_search_index", {}, { timeoutMs: 10000 });
          A(exported && typeof exported === "object", "index: export returns object");
          A(typeof exported.docs_count === "number" || typeof exported.docs === "object", "index: export has docs info", { keys: Object.keys(exported) });
          log("Exported index keys: " + Object.keys(exported).join(", "));

          const hydrated = await workerRequest("hydrate_search_index", { data: exported }, { timeoutMs: 10000 });
          A(hydrated && hydrated.hydrated === true, "index: hydrate succeeds after export", hydrated);
        } catch (e) { A(false, "index: export/hydrate threw", { err: String(e) }); }

        // --- First-introduced tests ---
        log("Testing first-introduced analytics...");

        // Test 8: First-introduced for a known term.
        try {
          const fi = await workerRequest("find_first_introduced", { query: "MVCC", contextLines: 2 }, { timeoutMs: 30000 });
          A(fi.found === true, "first-introduced: MVCC found", fi);
          if (fi.found) {
            A(typeof fi.commitIdx === "number", "first-introduced: has commitIdx");
            A(fi.commitIdx >= 0, "first-introduced: commitIdx >= 0", { idx: fi.commitIdx });
            A(typeof fi.matchLine === "string", "first-introduced: has matchLine");
            A(fi.matchLine.toLowerCase().includes("mvcc"), "first-introduced: matchLine contains query", { matchLine: fi.matchLine });
            A(Array.isArray(fi.contextLines), "first-introduced: has contextLines");
            A(fi.contextLines.length > 0, "first-introduced: contextLines non-empty", { len: fi.contextLines.length });
            const matchCtx = fi.contextLines.find(c => c.isMatch);
            A(matchCtx !== undefined, "first-introduced: contextLines has isMatch=true entry");
            log("MVCC first introduced at commit #" + fi.commitIdx + " (" + fi.short + "): " + fi.subject);
          }
        } catch (e) { A(false, "first-introduced: MVCC threw", { err: String(e) }); }

        // Test 9: First-introduced for nonexistent term.
        try {
          const fi2 = await workerRequest("find_first_introduced", { query: "xyzzyplugh99999" }, { timeoutMs: 10000 });
          A(fi2.found === false, "first-introduced: nonexistent term -> not found", fi2);
        } catch (e) { A(false, "first-introduced: nonexistent threw", { err: String(e) }); }

        // Test 10: First-introduced empty query.
        try {
          const fi3 = await workerRequest("find_first_introduced", { query: "" }, { timeoutMs: 5000 });
          A(fi3.found === false, "first-introduced: empty query -> not found", fi3);
        } catch (e) { A(false, "first-introduced: empty query threw", { err: String(e) }); }

        // Test 11: First-introduced case insensitivity.
        try {
          const fiLower = await workerRequest("find_first_introduced", { query: "mvcc" }, { timeoutMs: 30000 });
          const fiUpper = await workerRequest("find_first_introduced", { query: "MVCC" }, { timeoutMs: 30000 });
          A(fiLower.found === fiUpper.found, "first-introduced: case insensitive (same found)", { lower: fiLower.found, upper: fiUpper.found });
          if (fiLower.found && fiUpper.found) {
            A(fiLower.commitIdx === fiUpper.commitIdx, "first-introduced: case insensitive (same commitIdx)", { lower: fiLower.commitIdx, upper: fiUpper.commitIdx });
          }
        } catch (e) { A(false, "first-introduced: case test threw", { err: String(e) }); }

        // --- Most-edited sections tests ---
        log("Testing most-edited sections analytics...");

        // Test 12: Most-edited sections were precomputed during warmup.
        A(WORKER_DERIVED.mostEditedReady === true, "most-edited: mostEditedReady is true");

        // Test 13: Compute most-edited sections.
        try {
          const me = await workerRequest("compute_most_edited_sections", { topK: 5 }, { timeoutMs: 120000 });
          A(Array.isArray(me.sections), "most-edited: returns sections array");
          A(me.sections.length > 0, "most-edited: has sections", { len: me.sections.length });
          A(me.sections.length <= 5, "most-edited: topK=5 respected", { len: me.sections.length });

          if (me.sections.length > 0) {
            const s0 = me.sections[0];
            A(typeof s0.heading === "string", "most-edited: section has heading");
            A(typeof s0.totalTokensDelta === "number", "most-edited: section has totalTokensDelta");
            A(typeof s0.totalLinesDelta === "number", "most-edited: section has totalLinesDelta");
            A(typeof s0.peakIdx === "number", "most-edited: section has peakIdx");
            A(typeof s0.peakDelta === "number", "most-edited: section has peakDelta");
            A(typeof s0.commitCount === "number", "most-edited: section has commitCount");
            A(Array.isArray(s0.timeline), "most-edited: section has timeline");
            A(s0.timeline.length > 0, "most-edited: timeline non-empty", { len: s0.timeline.length });
            A(s0.commitCount === s0.timeline.length, "most-edited: commitCount matches timeline.length", { commitCount: s0.commitCount, timelineLen: s0.timeline.length });
            log("Top section: '" + s0.heading + "' - " + s0.totalTokensDelta + " token delta across " + s0.commitCount + " commits");

            // Verify sorting (descending by totalTokensDelta).
            for (let i = 1; i < me.sections.length; i++) {
              A(me.sections[i - 1].totalTokensDelta >= me.sections[i].totalTokensDelta,
                "most-edited: sorted desc by totalTokensDelta",
                { prev: me.sections[i - 1].totalTokensDelta, curr: me.sections[i].totalTokensDelta, idx: i });
            }
          }
        } catch (e) { A(false, "most-edited: compute threw", { err: String(e) }); }

        // Test 14: Timeline entry structure.
        try {
          const me2 = await workerRequest("compute_most_edited_sections", { topK: 1 }, { timeoutMs: 120000 });
          if (me2.sections.length > 0 && me2.sections[0].timeline.length > 0) {
            const t = me2.sections[0].timeline[0];
            A(typeof t.idx === "number", "most-edited: timeline entry has idx");
            A(typeof t.tokensAdded === "number", "most-edited: timeline entry has tokensAdded");
            A(typeof t.tokensDeleted === "number", "most-edited: timeline entry has tokensDeleted");
            A(typeof t.addLines === "number", "most-edited: timeline entry has addLines");
            A(typeof t.delLines === "number", "most-edited: timeline entry has delLines");
            A(t.tokensAdded >= 0, "most-edited: tokensAdded >= 0", { val: t.tokensAdded });
            A(t.tokensDeleted >= 0, "most-edited: tokensDeleted >= 0", { val: t.tokensDeleted });
          }
        } catch (e) { A(false, "most-edited: timeline structure threw", { err: String(e) }); }

        // --- Search palette UI tests ---
        log("Testing search palette UI...");

        // Test 15: Search palette elements exist.
        A(document.getElementById("searchPaletteOverlay") !== null, "palette: overlay element exists");
        A(document.getElementById("searchPaletteInput") !== null, "palette: input element exists");
        A(document.getElementById("searchPaletteResults") !== null, "palette: results element exists");

        // Test 16: Open/close palette.
        if (typeof openSearchPalette === "function" && typeof closeSearchPalette === "function") {
          openSearchPalette();
          const ov = document.getElementById("searchPaletteOverlay");
          A(!ov.classList.contains("hidden"), "palette: opens (overlay not hidden)");
          A(_spOpen === true, "palette: _spOpen is true after open");

          closeSearchPalette();
          A(ov.classList.contains("hidden"), "palette: closes (overlay hidden)");
          A(_spOpen === false, "palette: _spOpen is false after close");
        } else {
          A(false, "palette: openSearchPalette/closeSearchPalette not defined");
        }

        // Test 17: spNavigate bounds.
        if (typeof spNavigate === "function") {
          _spResults = [{ idx: 0 }, { idx: 1 }, { idx: 2 }];
          _spActiveIdx = 0;
          spNavigate(1);
          A(_spActiveIdx === 1, "palette: navigate down from 0 -> 1", { idx: _spActiveIdx });
          spNavigate(1);
          A(_spActiveIdx === 2, "palette: navigate down from 1 -> 2", { idx: _spActiveIdx });
          spNavigate(1);
          A(_spActiveIdx === 2, "palette: navigate down from 2 -> 2 (clamped)", { idx: _spActiveIdx });
          spNavigate(-1);
          A(_spActiveIdx === 1, "palette: navigate up from 2 -> 1", { idx: _spActiveIdx });
          spNavigate(-10);
          A(_spActiveIdx === 0, "palette: navigate up past 0 -> 0 (clamped)", { idx: _spActiveIdx });
          _spResults = [];
          _spActiveIdx = -1;
        }

        // --- Clustering tests ---
        log("Testing clustering...");

        // Test 18: Clusters were computed during warmup.
        A(WORKER_DERIVED.clusterReady === true, "clustering: clusterReady is true");

        // Test 19: Cluster structure.
        try {
          const cl = await workerRequest("compute_clusters", { limit: 5, threshold: 0.3 }, { timeoutMs: 30000 });
          A(Array.isArray(cl.clusters), "clustering: returns clusters array");
          log("Got " + cl.clusters.length + " clusters");
          if (cl.clusters.length > 0) {
            const c0 = cl.clusters[0];
            A(typeof c0.id === "string", "clustering: cluster has string id", { id: c0.id });
            A(c0.id.startsWith("cl-"), "clustering: cluster id starts with cl-", { id: c0.id });
            A(typeof c0.size === "number", "clustering: cluster has size");
            A(c0.size >= 2, "clustering: cluster size >= 2", { size: c0.size });
            A(typeof c0.medoid === "number", "clustering: cluster has medoid");
            A(Array.isArray(c0.tags), "clustering: cluster has tags array");
            A(Array.isArray(c0.items), "clustering: cluster has items array");
            A(c0.items.length === c0.size, "clustering: items.length === size", { items: c0.items.length, size: c0.size });
            // Verify items have expected fields.
            if (c0.items.length > 0) {
              A(typeof c0.items[0].idx === "number", "clustering: item has idx");
              A(typeof c0.items[0].subject === "string", "clustering: item has subject");
            }
            // Verify sorting (largest first).
            for (let i = 1; i < cl.clusters.length; i++) {
              A(cl.clusters[i - 1].size >= cl.clusters[i].size,
                "clustering: sorted desc by size",
                { prev: cl.clusters[i - 1].size, curr: cl.clusters[i].size, idx: i });
            }
            // Verify stable IDs (deterministic).
            const cl2 = await workerRequest("compute_clusters", { limit: 5, threshold: 0.3 }, { timeoutMs: 30000 });
            if (cl2.clusters.length > 0) {
              A(cl2.clusters[0].id === c0.id, "clustering: stable IDs across calls", { first: c0.id, second: cl2.clusters[0].id });
            }
          }
        } catch (e) { A(false, "clustering: compute threw", { err: String(e) }); }

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Search Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End History Search Unit Tests ----

      // ---- History Search E2E Tests (bd-24q.9.5) ----
      // Run via console: window.__runSearchE2ETests()
      // Requires dataset to be loaded.
      window.__runSearchE2ETests = async function () {
        const R = [];
        const log = (msg, ctx) => console.log("  [SRCH-E2E]", msg, ctx || "");
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("  FAIL:", m, x || ""); else log("PASS: " + m); };
        const wait = (ms) => new Promise((r) => setTimeout(r, ms));

        if (!DATASET.loaded || ALL_COMMITS.length < 5) {
          console.error("SRCH-E2E: Need loaded dataset with >= 5 commits.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded or < 5 commits" }] };
        }

        const overlay = document.getElementById("searchPaletteOverlay");
        const inputEl = document.getElementById("searchPaletteInput");
        const resultsEl = document.getElementById("searchPaletteResults");
        if (!overlay || !inputEl || !resultsEl) {
          console.error("SRCH-E2E: Missing search palette DOM elements.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Missing search palette elements" }] };
        }

        const origIdx = DOC.idx;

        // Ensure search index is built.
        if (!STATE.searchIndex || !STATE.searchIndex.postings?.size) {
          log("Search index not yet built, waiting...");
          await wait(5000);
        }

        // --- E2E 1: Open search palette via function call ---
        await (async function testE2E_openPalette() {
          openSearchPalette();
          await wait(300);
          A(!overlay.classList.contains("hidden"), "srch-e2e: palette visible after open", { classes: overlay.className });
          A(document.activeElement === inputEl, "srch-e2e: input is focused after open");
        })();

        // --- E2E 2: Type query and get results ---
        await (async function testE2E_queryReturnsResults() {
          openSearchPalette();
          await wait(200);
          inputEl.value = "MVCC";
          inputEl.dispatchEvent(new Event("input"));
          await wait(1500);
          const items = resultsEl.querySelectorAll(".search-palette-item");
          log("Query 'MVCC': " + items.length + " results");
          A(items.length > 0, "srch-e2e: 'MVCC' query returns results", { count: items.length });
          if (items.length > 0) {
            const first = items[0];
            A(first.dataset.spIdx != null, "srch-e2e: first result has spIdx data attribute");
            log("First result: " + (first.textContent || "").slice(0, 80));
          }
        })();

        // --- E2E 3: Arrow key navigation highlights different results ---
        await (async function testE2E_keyboardNavigation() {
          openSearchPalette();
          await wait(200);
          inputEl.value = "MVCC";
          inputEl.dispatchEvent(new Event("input"));
          await wait(1500);
          const items = resultsEl.querySelectorAll(".search-palette-item");
          if (items.length < 2) { A(true, "srch-e2e: skipped nav (< 2 results)"); closeSearchPalette(); return; }
          inputEl.dispatchEvent(new KeyboardEvent("keydown", { key: "ArrowDown", bubbles: true }));
          await wait(100);
          const activeAfterDown = _spActiveIdx;
          inputEl.dispatchEvent(new KeyboardEvent("keydown", { key: "ArrowDown", bubbles: true }));
          await wait(100);
          const activeAfterDown2 = _spActiveIdx;
          log("Nav: after 1 down=" + activeAfterDown + ", after 2 down=" + activeAfterDown2);
          A(activeAfterDown2 > activeAfterDown, "srch-e2e: ArrowDown advances active index", { first: activeAfterDown, second: activeAfterDown2 });
          inputEl.dispatchEvent(new KeyboardEvent("keydown", { key: "ArrowUp", bubbles: true }));
          await wait(100);
          A(_spActiveIdx < activeAfterDown2, "srch-e2e: ArrowUp decrements active index", { got: _spActiveIdx });
          closeSearchPalette();
        })();

        // --- E2E 4: Enter selects result and jumps to commit ---
        await (async function testE2E_enterSelectsResult() {
          selectCommitIdx(0);
          await wait(200);
          openSearchPalette();
          await wait(200);
          inputEl.value = "MVCC";
          inputEl.dispatchEvent(new Event("input"));
          await wait(1500);
          const items = resultsEl.querySelectorAll(".search-palette-item");
          if (items.length < 1) { A(false, "srch-e2e: no results for enter test"); closeSearchPalette(); return; }
          inputEl.dispatchEvent(new KeyboardEvent("keydown", { key: "ArrowDown", bubbles: true }));
          await wait(100);
          inputEl.dispatchEvent(new KeyboardEvent("keydown", { key: "Enter", bubbles: true }));
          await wait(500);
          A(DOC.idx !== 0, "srch-e2e: Enter jumped to a different commit", { got: DOC.idx });
          log("After Enter: idx=" + DOC.idx);
        })();

        // --- E2E 5: Escape closes the palette ---
        await (async function testE2E_escapeCloses() {
          openSearchPalette();
          await wait(200);
          A(!overlay.classList.contains("hidden"), "srch-e2e: palette open before Escape");
          inputEl.dispatchEvent(new KeyboardEvent("keydown", { key: "Escape", bubbles: true }));
          await wait(300);
          A(overlay.classList.contains("hidden"), "srch-e2e: palette closed after Escape");
        })();

        // --- E2E 6: Click on result jumps to commit ---
        await (async function testE2E_clickResult() {
          selectCommitIdx(0);
          await wait(200);
          openSearchPalette();
          await wait(200);
          inputEl.value = "page";
          inputEl.dispatchEvent(new Event("input"));
          await wait(1500);
          const items = resultsEl.querySelectorAll(".search-palette-item");
          if (items.length < 1) { A(true, "srch-e2e: skipped click (no results for 'page')"); closeSearchPalette(); return; }
          items[0].click();
          await wait(500);
          A(DOC.idx !== 0, "srch-e2e: clicking result changed commit index", { got: DOC.idx });
          log("After click: idx=" + DOC.idx);
        })();

        // --- E2E 7: Empty/nonsense query returns no results ---
        await (async function testE2E_emptyQuery() {
          openSearchPalette();
          await wait(200);
          inputEl.value = "";
          inputEl.dispatchEvent(new Event("input"));
          await wait(500);
          const items = resultsEl.querySelectorAll(".search-palette-item");
          A(items.length === 0, "srch-e2e: empty query returns no results", { count: items.length });
          inputEl.value = "zzxxqqww123456";
          inputEl.dispatchEvent(new Event("input"));
          await wait(1000);
          const items2 = resultsEl.querySelectorAll(".search-palette-item");
          A(items2.length === 0, "srch-e2e: nonsense query returns no results", { count: items2.length });
          closeSearchPalette();
        })();

        // --- E2E 8: Palette close cleans up ---
        await (async function testE2E_closeCleanup() {
          openSearchPalette();
          await wait(300);
          A(!overlay.classList.contains("hidden"), "srch-e2e: palette open before close");
          closeSearchPalette();
          await wait(200);
          A(overlay.classList.contains("hidden"), "srch-e2e: palette closed");
        })();

        // --- E2E 9: Most-edited sections analytics ---
        await (async function testE2E_mostEdited() {
          if (typeof workerRequest !== "function") {
            A(true, "srch-e2e: skipped most-edited (workerRequest not available)");
            return;
          }
          try {
            const result = await workerRequest("compute_most_edited_sections", {}, { timeoutMs: 10000 });
            if (!result || !result.length) {
              log("No most-edited sections returned");
              A(true, "srch-e2e: skipped most-edited (no results)");
              return;
            }
            A(result.length > 0, "srch-e2e: most-edited has sections", { count: result.length });
            const top = result[0];
            A(top.heading != null, "srch-e2e: top section has heading field", { heading: top.heading });
            A(top.totalTokensDelta > 0, "srch-e2e: top section has positive token delta", { got: top.totalTokensDelta });
            log("Top most-edited: '" + top.heading + "' with " + top.totalTokensDelta + " tokens delta");
          } catch (e) {
            log("Most-edited worker call failed: " + e.message);
            A(true, "srch-e2e: skipped most-edited (worker error)");
          }
        })();

        // --- Restore original state ---
        closeSearchPalette();
        selectCommitIdx(origIdx);
        await wait(300);
        log("Restored: idx=" + origIdx);

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `History Search E2E Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End History Search E2E Tests ----

      // ---- Clustering E2E Tests (bd-24q.14.5) ----
      // Run via console: window.__runClusteringE2ETests()
      window.__runClusteringE2ETests = async function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || ""); };
        const wait = (ms) => new Promise(r => setTimeout(r, ms));
        const log = (m) => console.log("  [cluster-e2e]", m);

        if (!DATASET.loaded || !ALL_COMMITS.length) {
          console.error("Clustering E2E: Need loaded dataset.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded" }] };
        }

        // Save state.
        const savedClusterId = _selectedClusterId;
        const savedClusterMembers = _selectedClusterMembers.slice();
        const savedClusterNavIdx = _clusterNavIdx;
        const savedCommitIdx = DOC.idx;

        // --- E2E 1: Cluster panel elements exist ---
        await (async function testPanelExists() {
          const panel = document.getElementById("clusterPanel");
          const list = document.getElementById("clusterList");
          A(panel !== null, "e2e-1: clusterPanel element exists");
          A(list !== null, "e2e-1: clusterList element exists");
        })();

        // --- E2E 2: Compute clusters and render panel ---
        await (async function testRenderPanel() {
          if (!WORKER_STATE.ready) { log("Skipping render (no worker)"); return; }
          await renderClusterPanel();
          await wait(1000);
          const list = document.getElementById("clusterList");
          const items = list.querySelectorAll(".cluster-item");
          A(items.length > 0, "e2e-2: cluster items rendered", { len: items.length });
          log("Rendered " + items.length + " cluster items");
          // Each item should have a data-cluster-id.
          if (items.length > 0) {
            const cid = items[0].dataset.clusterId;
            A(typeof cid === "string" && cid.startsWith("cl-"), "e2e-2: first item has valid cluster id", { cid });
          }
        })();

        // --- E2E 3: Select cluster -> members populated ---
        await (async function testSelectCluster() {
          if (!WORKER_STATE.ready) { log("Skipping select (no worker)"); return; }
          const list = document.getElementById("clusterList");
          const items = list.querySelectorAll(".cluster-item");
          if (!items.length) { log("Skipping select (no items)"); return; }
          const firstCid = items[0].dataset.clusterId;
          // Simulate click on first cluster.
          const threshold = parseFloat(document.getElementById("clusterThresholdSel")?.value || "0.3");
          const limit = parseInt(document.getElementById("clusterLimitSel")?.value || "10", 10);
          try {
            const res = await workerRequest("compute_clusters", { limit, threshold }, { timeoutMs: 30000 });
            const cluster = (res.clusters || []).find(c => c.id === firstCid);
            if (cluster) {
              _selectedClusterMembers = cluster.items.map(it => it.idx);
              _clusterNavIdx = 0;
            }
          } catch (e) { A(false, "e2e-3: compute_clusters threw", { err: String(e) }); return; }
          selectCluster(firstCid);
          await wait(1000);

          A(_selectedClusterId === firstCid, "e2e-3: _selectedClusterId set", { got: _selectedClusterId, expected: firstCid });
          A(_selectedClusterMembers.length >= 2, "e2e-3: members populated (>= 2)", { len: _selectedClusterMembers.length });
          A(_clusterNavIdx === 0, "e2e-3: nav index starts at 0", { got: _clusterNavIdx });
          log("Selected cluster " + firstCid + " with " + _selectedClusterMembers.length + " members");
        })();

        // --- E2E 4: Cluster navigation (next/prev) ---
        await (async function testClusterNav() {
          if (_selectedClusterMembers.length < 2) { log("Skipping nav (< 2 members)"); return; }
          const firstMember = _selectedClusterMembers[0];
          const secondMember = _selectedClusterMembers[1];

          // Navigate to first member.
          _clusterNavIdx = 0;
          clusterNavigate(0); // Stay at 0.
          await wait(200);
          A(DOC.idx === firstMember, "e2e-4: at first member after nav(0)", { expected: firstMember, got: DOC.idx });

          // Navigate forward.
          clusterNavigate(1);
          await wait(200);
          A(_clusterNavIdx === 1, "e2e-4: navIdx = 1 after forward", { got: _clusterNavIdx });
          A(DOC.idx === secondMember, "e2e-4: at second member after nav(1)", { expected: secondMember, got: DOC.idx });

          // Navigate backward.
          clusterNavigate(-1);
          await wait(200);
          A(_clusterNavIdx === 0, "e2e-4: navIdx = 0 after back", { got: _clusterNavIdx });
          A(DOC.idx === firstMember, "e2e-4: back at first member", { expected: firstMember, got: DOC.idx });

          // Navigate past start (clamped).
          clusterNavigate(-1);
          await wait(200);
          A(_clusterNavIdx === 0, "e2e-4: clamped at 0", { got: _clusterNavIdx });

          // Navigate to last member.
          const lastIdx = _selectedClusterMembers.length - 1;
          _clusterNavIdx = lastIdx;
          clusterNavigate(0);
          await wait(200);
          A(DOC.idx === _selectedClusterMembers[lastIdx], "e2e-4: at last member", { got: DOC.idx });

          // Navigate past end (clamped).
          clusterNavigate(1);
          await wait(200);
          A(_clusterNavIdx === lastIdx, "e2e-4: clamped at end", { got: _clusterNavIdx });
          log("Nav test: OK (forward/back/clamp at " + _selectedClusterMembers.length + " members)");
        })();

        // --- E2E 5: Nav label updates ---
        await (async function testNavLabel() {
          const label = document.getElementById("clusterNavLabel");
          if (!label) { log("Skipping nav label (no element)"); return; }
          if (_selectedClusterMembers.length < 1) { log("Skipping nav label (no members)"); return; }
          _clusterNavIdx = 0;
          updateClusterNav();
          A(label.textContent === "1 / " + _selectedClusterMembers.length, "e2e-5: nav label at idx 0", { got: label.textContent });
          if (_selectedClusterMembers.length >= 2) {
            _clusterNavIdx = 1;
            updateClusterNav();
            A(label.textContent === "2 / " + _selectedClusterMembers.length, "e2e-5: nav label at idx 1", { got: label.textContent });
          }
        })();

        // --- E2E 6: Timeline highlight on cluster selection ---
        await (async function testTimelineHighlight() {
          if (!_selectedClusterMembers.length) { log("Skipping highlight (no members)"); return; }
          highlightClusterOnTimeline();
          await wait(200);
          const highlighted = document.querySelectorAll(".timeline-cluster-highlight");
          // May be 0 if commit list isn't rendered with data-idx attributes.
          log("Timeline highlighted elements: " + highlighted.length);
          A(true, "e2e-6: highlightClusterOnTimeline ran without error");
        })();

        // --- E2E 7: Deselect cluster ---
        await (async function testDeselectCluster() {
          if (!_selectedClusterId) { log("Skipping deselect (none selected)"); return; }
          const cid = _selectedClusterId;
          selectCluster(cid); // Toggle off.
          await wait(500);
          A(_selectedClusterId === null, "e2e-7: deselected (id = null)", { got: _selectedClusterId });
          A(_selectedClusterMembers.length === 0, "e2e-7: members cleared", { len: _selectedClusterMembers.length });
          A(_clusterNavIdx === -1, "e2e-7: navIdx = -1", { got: _clusterNavIdx });
          const nav = document.getElementById("clusterNav");
          if (nav) A(nav.classList.contains("hidden"), "e2e-7: nav hidden after deselect");
          log("Deselect: OK");
        })();

        // --- E2E 8: Cluster determinism (same params -> same results) ---
        await (async function testDeterminism() {
          if (!WORKER_STATE.ready) { log("Skipping determinism (no worker)"); return; }
          try {
            const r1 = await workerRequest("compute_clusters", { limit: 5, threshold: 0.3 }, { timeoutMs: 30000 });
            const r2 = await workerRequest("compute_clusters", { limit: 5, threshold: 0.3 }, { timeoutMs: 30000 });
            A(r1.clusters.length === r2.clusters.length, "e2e-8: same cluster count", { r1: r1.clusters.length, r2: r2.clusters.length });
            if (r1.clusters.length > 0 && r2.clusters.length > 0) {
              A(r1.clusters[0].id === r2.clusters[0].id, "e2e-8: same first cluster id", { r1: r1.clusters[0].id, r2: r2.clusters[0].id });
              A(r1.clusters[0].size === r2.clusters[0].size, "e2e-8: same first cluster size", { r1: r1.clusters[0].size, r2: r2.clusters[0].size });
            }
            log("Determinism: OK (" + r1.clusters.length + " clusters)");
          } catch (e) { A(false, "e2e-8: determinism test threw", { err: String(e) }); }
        })();

        // --- E2E 9: Navigation stays within cluster membership ---
        await (async function testNavWithinCluster() {
          if (!WORKER_STATE.ready) { log("Skipping nav membership (no worker)"); return; }
          try {
            const res = await workerRequest("compute_clusters", { limit: 5, threshold: 0.3 }, { timeoutMs: 30000 });
            if (!res.clusters.length) { log("Skipping nav membership (no clusters)"); return; }
            const cluster = res.clusters[0];
            _selectedClusterId = cluster.id;
            _selectedClusterMembers = cluster.items.map(it => it.idx);
            _clusterNavIdx = 0;
            const memberSet = new Set(_selectedClusterMembers);
            // Navigate through all members.
            for (let i = 0; i < _selectedClusterMembers.length && i < 10; i++) {
              _clusterNavIdx = i;
              clusterNavigate(0);
              await wait(50);
              A(memberSet.has(DOC.idx), "e2e-9: commit at nav " + i + " is a member", { idx: DOC.idx, member: memberSet.has(DOC.idx) });
            }
            log("Nav membership: OK (checked " + Math.min(_selectedClusterMembers.length, 10) + " members)");
          } catch (e) { A(false, "e2e-9: nav membership threw", { err: String(e) }); }
        })();

        // Restore state.
        _selectedClusterId = savedClusterId;
        _selectedClusterMembers = savedClusterMembers;
        _clusterNavIdx = savedClusterNavIdx;
        selectCommitIdx(savedCommitIdx);
        highlightClusterOnTimeline();
        await wait(200);

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Clustering E2E Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Clustering E2E Tests ----


      // ---- Clustering Unit Tests (bd-24q.14.4) ----
      // Run via console: window.__runClusteringTests()
      window.__runClusteringTests = async function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || ""); };
        const log = (m) => console.log("  [cluster]", m);

        // --- MinHash signature tests ---
        log("Testing MinHash signatures...");

        // Test 1: MinHash signatures computed during warmup.
        try {
          const exported = await workerRequest("export_minhash_signatures", {}, { timeoutMs: 10000 });
          A(exported !== null && typeof exported === "object", "minhash: export returns object");
          A(typeof exported.sigLen === "number", "minhash: export has sigLen", { keys: Object.keys(exported) });
          A(exported.sigLen === 64, "minhash: sigLen=64 (default)", { sigLen: exported.sigLen });
          A(typeof exported.sigs_b64 === "string", "minhash: export has sigs_b64");
          A(exported.sigs_b64.length > 0, "minhash: sigs_b64 non-empty");
          A(Array.isArray(exported.meta), "minhash: export has meta array");
          A(exported.meta.length > 0, "minhash: meta non-empty", { len: exported.meta.length });
          A(exported.meta.length === ALL_COMMITS.length, "minhash: meta.length matches commits", { meta: exported.meta.length, commits: ALL_COMMITS.length });
          log("Exported: " + exported.meta.length + " docs, sigLen=" + exported.sigLen + ", sigs_b64 length=" + exported.sigs_b64.length);
        } catch (e) { A(false, "minhash: export threw", { err: String(e) }); }

        // Test 2: MinHash export/hydrate round-trip.
        try {
          const exported = await workerRequest("export_minhash_signatures", {}, { timeoutMs: 10000 });
          const hydrated = await workerRequest("hydrate_minhash_signatures", { data: exported }, { timeoutMs: 10000 });
          A(hydrated.hydrated === true, "minhash: hydrate succeeds", hydrated);
          A(hydrated.docs === exported.meta.length, "minhash: hydrated docs count matches", { hydrated: hydrated.docs, exported: exported.meta.length });
          A(hydrated.sigLen === exported.sigLen, "minhash: hydrated sigLen matches", { hydrated: hydrated.sigLen, exported: exported.sigLen });
        } catch (e) { A(false, "minhash: round-trip threw", { err: String(e) }); }

        // Test 3: MinHash meta entry structure.
        try {
          const exported = await workerRequest("export_minhash_signatures", {}, { timeoutMs: 10000 });
          if (exported.meta.length > 0) {
            const m = exported.meta[0];
            A(typeof m.idx === "number", "minhash: meta[0] has idx");
            A(typeof m.hash === "string", "minhash: meta[0] has hash");
            A(typeof m.short === "string", "minhash: meta[0] has short");
            A(typeof m.subject === "string", "minhash: meta[0] has subject");
            A(m.idx === 0, "minhash: meta[0].idx === 0", { idx: m.idx });
          }
        } catch (e) { A(false, "minhash: meta structure threw", { err: String(e) }); }

        // Test 4: Determinism — same inputs produce same signatures.
        try {
          const exp1 = await workerRequest("export_minhash_signatures", {}, { timeoutMs: 10000 });
          // Recompute with same params.
          await workerRequest("compute_minhash_signatures", { sigLen: 64, shingleK: 5, mode: "added" }, { timeoutMs: 60000 });
          const exp2 = await workerRequest("export_minhash_signatures", {}, { timeoutMs: 10000 });
          A(exp1.sigs_b64 === exp2.sigs_b64, "minhash: deterministic (same sigs_b64 after recompute)", { len1: exp1.sigs_b64.length, len2: exp2.sigs_b64.length });
          A(exp1.meta.length === exp2.meta.length, "minhash: deterministic (same meta length)");
        } catch (e) { A(false, "minhash: determinism test threw", { err: String(e) }); }

        // --- Jaccard estimator accuracy ---
        log("Testing Jaccard estimator accuracy...");

        // Test 5: Similar commits should have higher Jaccard than dissimilar ones.
        // We test by looking at clusters — members should have higher avg sim than random pairs.
        try {
          const cl = await workerRequest("compute_clusters", { limit: 3, threshold: 0.2 }, { timeoutMs: 30000 });
          if (cl.clusters.length > 0 && cl.clusters[0].size >= 3) {
            const c0 = cl.clusters[0];
            log("Testing Jaccard on cluster '" + c0.id + "' with " + c0.size + " members, tags: " + c0.tags.join(", "));
            // All members in a cluster passed the threshold, so their median Jaccard should be >= threshold.
            A(c0.size >= 2, "jaccard: cluster has >= 2 members for testing");
            // The medoid should be a member of the cluster.
            const memberIdxs = c0.items.map(it => it.idx);
            A(memberIdxs.includes(c0.medoid), "jaccard: medoid is cluster member", { medoid: c0.medoid, members: memberIdxs });
          } else {
            log("Not enough cluster data for Jaccard accuracy test (need cluster with >= 3 members at threshold 0.2)");
            A(true, "jaccard: skipped (insufficient cluster data)");
          }
        } catch (e) { A(false, "jaccard: accuracy test threw", { err: String(e) }); }

        // --- Grouping correctness ---
        log("Testing grouping correctness...");

        // Test 6: Stable cluster IDs across calls.
        try {
          const cl1 = await workerRequest("compute_clusters", { limit: 5, threshold: 0.3 }, { timeoutMs: 30000 });
          const cl2 = await workerRequest("compute_clusters", { limit: 5, threshold: 0.3 }, { timeoutMs: 30000 });
          A(cl1.clusters.length === cl2.clusters.length, "grouping: same cluster count", { c1: cl1.clusters.length, c2: cl2.clusters.length });
          for (let i = 0; i < Math.min(cl1.clusters.length, cl2.clusters.length); i++) {
            A(cl1.clusters[i].id === cl2.clusters[i].id, "grouping: stable ID at index " + i, { id1: cl1.clusters[i].id, id2: cl2.clusters[i].id });
            A(cl1.clusters[i].size === cl2.clusters[i].size, "grouping: same size at index " + i, { s1: cl1.clusters[i].size, s2: cl2.clusters[i].size });
          }
        } catch (e) { A(false, "grouping: stability threw", { err: String(e) }); }

        // Test 7: Higher threshold -> fewer/smaller clusters.
        try {
          const lo = await workerRequest("compute_clusters", { limit: 20, threshold: 0.1 }, { timeoutMs: 30000 });
          const hi = await workerRequest("compute_clusters", { limit: 20, threshold: 0.5 }, { timeoutMs: 30000 });
          const loTotal = lo.clusters.reduce((s, c) => s + c.size, 0);
          const hiTotal = hi.clusters.reduce((s, c) => s + c.size, 0);
          log("Threshold 0.1: " + lo.clusters.length + " clusters (" + loTotal + " total members)");
          log("Threshold 0.5: " + hi.clusters.length + " clusters (" + hiTotal + " total members)");
          A(loTotal >= hiTotal, "grouping: lower threshold -> more grouped members", { lo: loTotal, hi: hiTotal });
        } catch (e) { A(false, "grouping: threshold monotonicity threw", { err: String(e) }); }

        // Test 8: All cluster members are unique (no duplicates across clusters).
        try {
          const cl = await workerRequest("compute_clusters", { limit: 20, threshold: 0.3 }, { timeoutMs: 30000 });
          const allIdxs = [];
          for (const c of cl.clusters) {
            for (const item of c.items) allIdxs.push(item.idx);
          }
          const unique = new Set(allIdxs);
          A(unique.size === allIdxs.length, "grouping: no duplicate members across clusters", { total: allIdxs.length, unique: unique.size });
        } catch (e) { A(false, "grouping: uniqueness threw", { err: String(e) }); }

        // Test 9: Cluster members sorted ascending by idx.
        try {
          const cl = await workerRequest("compute_clusters", { limit: 5, threshold: 0.3 }, { timeoutMs: 30000 });
          for (const c of cl.clusters) {
            let sorted = true;
            for (let i = 1; i < c.items.length; i++) {
              if (c.items[i].idx < c.items[i - 1].idx) { sorted = false; break; }
            }
            A(sorted, "grouping: members sorted by idx in cluster " + c.id, { size: c.size });
          }
        } catch (e) { A(false, "grouping: sort order threw", { err: String(e) }); }

        // Test 10: Theme tags are strings.
        try {
          const cl = await workerRequest("compute_clusters", { limit: 5, threshold: 0.3 }, { timeoutMs: 30000 });
          for (const c of cl.clusters) {
            A(Array.isArray(c.tags), "grouping: tags is array for " + c.id);
            for (const t of c.tags) {
              A(typeof t === "string", "grouping: tag is string", { tag: t, cluster: c.id });
              A(t.length >= 3, "grouping: tag length >= 3", { tag: t });
            }
            if (c.tags.length > 0) {
              log("Cluster " + c.id + " (" + c.size + " members): tags=[" + c.tags.join(", ") + "]");
            }
          }
        } catch (e) { A(false, "grouping: theme tags threw", { err: String(e) }); }

        // Test 11: Limit parameter respected.
        try {
          const cl3 = await workerRequest("compute_clusters", { limit: 2, threshold: 0.3 }, { timeoutMs: 30000 });
          A(cl3.clusters.length <= 2, "grouping: limit=2 respected", { len: cl3.clusters.length });
        } catch (e) { A(false, "grouping: limit threw", { err: String(e) }); }

        // Test 12: Medoid is valid commit index.
        try {
          const cl = await workerRequest("compute_clusters", { limit: 5, threshold: 0.3 }, { timeoutMs: 30000 });
          for (const c of cl.clusters) {
            A(c.medoid >= 0 && c.medoid < ALL_COMMITS.length, "grouping: medoid in valid range for " + c.id, { medoid: c.medoid, max: ALL_COMMITS.length });
            const isMember = c.items.some(it => it.idx === c.medoid);
            A(isMember, "grouping: medoid is cluster member for " + c.id, { medoid: c.medoid });
          }
        } catch (e) { A(false, "grouping: medoid validity threw", { err: String(e) }); }

        // --- Summary ---
        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
        const s = `Clustering Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Clustering Unit Tests ----

      // ---- Performance Unit Tests: Cache + Worker Protocol (bd-24q.5.4) ----
      // Run via console: window.__runCacheWorkerTests()
      window.__runCacheWorkerTests = function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || ""); };

        // --- 1. LruCache keying ---
        (function test_lruCache_sameKey() {
          const cache = new LruCache(10);
          const origHash = WORKER_STATE.datasetHash;
          WORKER_STATE.datasetHash = "testhash123";
          cache.set("op1", { a: 1 }, "value1");
          const val = cache.get("op1", { a: 1 });
          A(val === "value1", "LRU sameKey: same params → same value", { val });
          WORKER_STATE.datasetHash = origHash;
        })();

        (function test_lruCache_diffKey() {
          const cache = new LruCache(10);
          const origHash = WORKER_STATE.datasetHash;
          WORKER_STATE.datasetHash = "testhash123";
          cache.set("op1", { a: 1 }, "value1");
          cache.set("op1", { a: 2 }, "value2");
          const v1 = cache.get("op1", { a: 1 });
          const v2 = cache.get("op1", { a: 2 });
          A(v1 === "value1", "LRU diffKey: params {a:1} → value1", { v1 });
          A(v2 === "value2", "LRU diffKey: params {a:2} → value2", { v2 });
          WORKER_STATE.datasetHash = origHash;
        })();

        (function test_lruCache_diffOp() {
          const cache = new LruCache(10);
          const origHash = WORKER_STATE.datasetHash;
          WORKER_STATE.datasetHash = "testhash123";
          cache.set("opA", {}, "valA");
          cache.set("opB", {}, "valB");
          A(cache.get("opA", {}) === "valA", "LRU diffOp: opA → valA");
          A(cache.get("opB", {}) === "valB", "LRU diffOp: opB → valB");
          WORKER_STATE.datasetHash = origHash;
        })();

        (function test_lruCache_diffDatasetHash() {
          const cache = new LruCache(10);
          const origHash = WORKER_STATE.datasetHash;
          WORKER_STATE.datasetHash = "hash1";
          cache.set("op", {}, "val_hash1");
          WORKER_STATE.datasetHash = "hash2";
          cache.set("op", {}, "val_hash2");
          A(cache.get("op", {}) === "val_hash2", "LRU diffHash: hash2 → val_hash2");
          WORKER_STATE.datasetHash = "hash1";
          A(cache.get("op", {}) === "val_hash1", "LRU diffHash: hash1 → val_hash1");
          WORKER_STATE.datasetHash = origHash;
        })();

        // --- 2. LRU eviction ---
        (function test_lruCache_eviction() {
          const cache = new LruCache(3);
          const origHash = WORKER_STATE.datasetHash;
          WORKER_STATE.datasetHash = "evict";
          cache.set("op", { i: 1 }, "v1");
          cache.set("op", { i: 2 }, "v2");
          cache.set("op", { i: 3 }, "v3");
          A(cache.size === 3, "LRU eviction: size is 3 before overflow", { size: cache.size });
          cache.set("op", { i: 4 }, "v4"); // Should evict {i:1}
          A(cache.size === 3, "LRU eviction: size stays 3 after overflow", { size: cache.size });
          A(cache.get("op", { i: 1 }) === undefined, "LRU eviction: oldest entry (i:1) evicted");
          A(cache.get("op", { i: 4 }) === "v4", "LRU eviction: newest entry (i:4) present");
          WORKER_STATE.datasetHash = origHash;
        })();

        (function test_lruCache_access_refreshes() {
          const cache = new LruCache(3);
          const origHash = WORKER_STATE.datasetHash;
          WORKER_STATE.datasetHash = "refresh";
          cache.set("op", { i: 1 }, "v1");
          cache.set("op", { i: 2 }, "v2");
          cache.set("op", { i: 3 }, "v3");
          // Access i:1 to refresh it (move to end)
          cache.get("op", { i: 1 });
          // Now i:2 is oldest; adding i:4 should evict i:2
          cache.set("op", { i: 4 }, "v4");
          A(cache.get("op", { i: 1 }) === "v1", "LRU refresh: accessed entry i:1 survives");
          A(cache.get("op", { i: 2 }) === undefined, "LRU refresh: stale entry i:2 evicted");
          A(cache.get("op", { i: 4 }) === "v4", "LRU refresh: new entry i:4 present");
          WORKER_STATE.datasetHash = origHash;
        })();

        (function test_lruCache_overwrite() {
          const cache = new LruCache(5);
          const origHash = WORKER_STATE.datasetHash;
          WORKER_STATE.datasetHash = "ow";
          cache.set("op", { k: "a" }, "old");
          cache.set("op", { k: "a" }, "new");
          A(cache.get("op", { k: "a" }) === "new", "LRU overwrite: same key gets updated value");
          A(cache.size === 1, "LRU overwrite: no duplicate entries", { size: cache.size });
          WORKER_STATE.datasetHash = origHash;
        })();

        (function test_lruCache_has() {
          const cache = new LruCache(5);
          const origHash = WORKER_STATE.datasetHash;
          WORKER_STATE.datasetHash = "has";
          cache.set("op", { x: 1 }, "val");
          A(cache.has("op", { x: 1 }) === true, "LRU has: returns true for existing key");
          A(cache.has("op", { x: 2 }) === false, "LRU has: returns false for missing key");
          WORKER_STATE.datasetHash = origHash;
        })();

        (function test_lruCache_clear() {
          const cache = new LruCache(5);
          const origHash = WORKER_STATE.datasetHash;
          WORKER_STATE.datasetHash = "clr";
          cache.set("op", { i: 1 }, "v1");
          cache.set("op", { i: 2 }, "v2");
          A(cache.size === 2, "LRU clear: size before clear is 2");
          cache.clear();
          A(cache.size === 0, "LRU clear: size after clear is 0");
          A(cache.get("op", { i: 1 }) === undefined, "LRU clear: entries gone after clear");
          WORKER_STATE.datasetHash = origHash;
        })();

        // --- 3. Worker protocol: handleWorkerMessage ---
        (function test_workerMsg_ok() {
          // Simulate a pending request resolved by handleWorkerMessage
          const origPending = new Map(WORKER_STATE.pending);
          let resolved = null;
          let rejected = null;
          const fakeReqId = "test-ok-1";
          WORKER_STATE.pending.set(fakeReqId, {
            resolve: (v) => { resolved = v; },
            reject: (e) => { rejected = e; },
            onProgress: null,
            timeoutId: null,
          });
          // Simulate worker response
          handleWorkerMessage({ data: { reqId: fakeReqId, type: "ok", payload: { result: 42 } } });
          A(resolved !== null, "workerMsg ok: resolve called", { resolved });
          A(resolved?.result === 42, "workerMsg ok: correct payload", { result: resolved?.result });
          A(rejected === null, "workerMsg ok: reject not called");
          A(!WORKER_STATE.pending.has(fakeReqId), "workerMsg ok: pending entry cleaned up");
          // Restore
          WORKER_STATE.pending = origPending;
        })();

        (function test_workerMsg_error() {
          const origPending = new Map(WORKER_STATE.pending);
          let resolved = null;
          let rejected = null;
          const fakeReqId = "test-err-1";
          WORKER_STATE.pending.set(fakeReqId, {
            resolve: (v) => { resolved = v; },
            reject: (e) => { rejected = e; },
            onProgress: null,
            timeoutId: null,
          });
          handleWorkerMessage({ data: { reqId: fakeReqId, type: "error", error: { message: "test error", name: "TestError" } } });
          A(rejected !== null, "workerMsg error: reject called");
          A(rejected?.message === "test error", "workerMsg error: correct message", { msg: rejected?.message });
          A(rejected?.name === "TestError", "workerMsg error: correct name", { name: rejected?.name });
          A(resolved === null, "workerMsg error: resolve not called");
          A(!WORKER_STATE.pending.has(fakeReqId), "workerMsg error: pending entry cleaned up");
          WORKER_STATE.pending = origPending;
        })();

        (function test_workerMsg_cancelled() {
          const origPending = new Map(WORKER_STATE.pending);
          let resolved = null;
          let rejected = null;
          const fakeReqId = "test-cancel-1";
          WORKER_STATE.pending.set(fakeReqId, {
            resolve: (v) => { resolved = v; },
            reject: (e) => { rejected = e; },
            onProgress: null,
            timeoutId: null,
          });
          handleWorkerMessage({ data: { reqId: fakeReqId, type: "cancelled" } });
          A(rejected !== null, "workerMsg cancelled: reject called");
          A(rejected?.name === "AbortError", "workerMsg cancelled: AbortError", { name: rejected?.name });
          A(resolved === null, "workerMsg cancelled: resolve not called");
          WORKER_STATE.pending = origPending;
        })();

        (function test_workerMsg_progress() {
          const origPending = new Map(WORKER_STATE.pending);
          let progressData = null;
          const fakeReqId = "test-prog-1";
          WORKER_STATE.pending.set(fakeReqId, {
            resolve: () => {},
            reject: () => {},
            onProgress: (p) => { progressData = p; },
            timeoutId: null,
          });
          handleWorkerMessage({ data: { reqId: fakeReqId, type: "progress", payload: { pct: 50 } } });
          A(progressData !== null, "workerMsg progress: onProgress called");
          A(progressData?.pct === 50, "workerMsg progress: correct payload", { pct: progressData?.pct });
          // Progress should NOT remove from pending
          A(WORKER_STATE.pending.has(fakeReqId), "workerMsg progress: pending entry kept");
          WORKER_STATE.pending.delete(fakeReqId);
          WORKER_STATE.pending = origPending;
        })();

        (function test_workerMsg_unknown_reqId() {
          const origPending = new Map(WORKER_STATE.pending);
          // No pending entry for this reqId - should silently ignore
          const sizeBefore = WORKER_STATE.pending.size;
          handleWorkerMessage({ data: { reqId: "nonexistent-123", type: "ok", payload: {} } });
          A(WORKER_STATE.pending.size === sizeBefore, "workerMsg unknown: no side effects for unknown reqId");
          WORKER_STATE.pending = origPending;
        })();

        (function test_workerMsg_no_reqId() {
          const origPending = new Map(WORKER_STATE.pending);
          const sizeBefore = WORKER_STATE.pending.size;
          handleWorkerMessage({ data: { type: "ok", payload: {} } });
          A(WORKER_STATE.pending.size === sizeBefore, "workerMsg noReqId: no side effects when reqId missing");
          WORKER_STATE.pending = origPending;
        })();

        // --- 4. workerRequest reqId correlation ---
        (function test_workerRequest_unavailable() {
          const origWorker = WORKER_STATE.worker;
          const origReady = WORKER_STATE.ready;
          WORKER_STATE.worker = null;
          let caught = false;
          workerRequest("test_op", {}).catch(() => { caught = true; });
          // Since worker is null, it should reject
          A(WORKER_STATE.worker === null, "workerRequest unavailable: worker stays null");
          WORKER_STATE.worker = origWorker;
          WORKER_STATE.ready = origReady;
        })();

        (function test_workerRequest_reqId_unique() {
          const id1 = WORKER_STATE.reqSeq;
          const id2 = WORKER_STATE.reqSeq + 1;
          A(id1 !== id2, "workerRequest reqId: sequential reqIds are unique", { id1, id2 });
        })();

        // --- 5. localStorage cache (schema mismatch clears) ---
        (function test_lsCache_keyFormat() {
          const origHash = WORKER_STATE.datasetHash;
          WORKER_STATE.datasetHash = "lskeyhash";
          const key = lsCacheKey("myop", { p: 1 });
          A(key.startsWith(LS_CACHE_PREFIX), "lsCache key: starts with prefix", { key, prefix: LS_CACHE_PREFIX });
          A(key.includes("myop"), "lsCache key: includes op name", { key });
          A(key.includes("lskeyhash"), "lsCache key: includes dataset hash", { key });
          WORKER_STATE.datasetHash = origHash;
        })();

        // --- Diagnostics ---
        const failed = R.filter(r => !r.pass);
        if (failed.length > 0) {
          console.group("Cache/Worker Protocol Test Diagnostics");
          failed.forEach(r => console.error("  FAIL:", r.msg, r.ctx || ""));
          // Print WORKER_STATE summary
          console.log("WORKER_STATE:", { ready: WORKER_STATE.ready, disabled: WORKER_STATE.disabled, datasetHash: WORKER_STATE.datasetHash?.slice(0, 12), pendingCount: WORKER_STATE.pending.size, reqSeq: WORKER_STATE.reqSeq });
          console.groupEnd();
        }

        // Summary
        const p = R.filter(r => r.pass).length;
        const f = R.filter(r => !r.pass).length;
        const summary = "Cache + Worker Protocol Tests: " + p + " passed, " + f + " failed, " + R.length + " total";
        if (f > 0) { console.warn(summary); R.filter(r => !r.pass).forEach(r => console.error("  FAIL:", r.msg, r.ctx || "")); }
        else console.log("%c" + summary, "color: green; font-weight: bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Performance Unit Tests ----

      // ---- Dataset Tool Unit Tests (bd-24q.6.4) ----
      // Run via console: window.__runDatasetToolTests()
      // Requires dataset to be loaded.
      window.__runDatasetToolTests = async function () {
        const R = [];
        const log = (msg, ctx) => console.log("  [DS-UT]", msg, ctx || "");
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("  FAIL:", m, x || ""); else log("PASS: " + m); };

        if (!DATASET.loaded || ALL_COMMITS.length < 5) {
          console.error("DS-UT: Need loaded dataset with >= 5 commits.");
          return { passed: 0, failed: 1, total: 1, results: [{ pass: false, msg: "Dataset not loaded or < 5 commits" }] };
        }

        // --- Unit 1: parseUnifiedHunks - basic patch ---
        (function test_parseHunks_basic() {
          const patch = "@@ -1,3 +1,4 @@\n line1\n-old\n+new\n+added\n line3";
          const hunks = parseUnifiedHunks(patch);
          A(hunks.length === 1, "parseHunks: single hunk parsed", { count: hunks.length });
          A(hunks[0].oldStart === 1, "parseHunks: oldStart=1", { got: hunks[0].oldStart });
          A(hunks[0].oldCount === 3, "parseHunks: oldCount=3", { got: hunks[0].oldCount });
          A(hunks[0].newStart === 1, "parseHunks: newStart=1", { got: hunks[0].newStart });
          A(hunks[0].newCount === 4, "parseHunks: newCount=4", { got: hunks[0].newCount });
          A(hunks[0].lines.length === 5, "parseHunks: 5 lines", { got: hunks[0].lines.length });
        })();

        // --- Unit 2: parseUnifiedHunks - multiple hunks ---
        (function test_parseHunks_multi() {
          const patch = "@@ -1,2 +1,2 @@\n-old1\n+new1\n line2\n@@ -10,2 +10,3 @@\n line10\n+added10\n line11";
          const hunks = parseUnifiedHunks(patch);
          A(hunks.length === 2, "parseHunks multi: 2 hunks", { count: hunks.length });
          A(hunks[0].oldStart === 1, "parseHunks multi: hunk0 oldStart=1");
          A(hunks[1].oldStart === 10, "parseHunks multi: hunk1 oldStart=10");
          A(hunks[1].newCount === 3, "parseHunks multi: hunk1 newCount=3");
        })();

        // --- Unit 3: parseUnifiedHunks - empty/null input ---
        (function test_parseHunks_empty() {
          A(parseUnifiedHunks("").length === 0, "parseHunks empty: '' returns []");
          A(parseUnifiedHunks(null).length === 0, "parseHunks empty: null returns []");
          A(parseUnifiedHunks(undefined).length === 0, "parseHunks empty: undefined returns []");
          A(parseUnifiedHunks("no hunks here").length === 0, "parseHunks empty: 'no hunks here' returns []");
        })();

        // --- Unit 4: applyPatchLines - simple addition ---
        (function test_applyPatch_add() {
          const prev = ["line1", "line2", "line3"];
          const patch = "@@ -2,1 +2,2 @@\n line2\n+inserted";
          const result = applyPatchLines(prev, patch);
          A(result.length === 4, "applyPatch add: length 4", { got: result.length });
          A(result[0] === "line1", "applyPatch add: line1 preserved");
          A(result[1] === "line2", "applyPatch add: line2 preserved");
          A(result[2] === "inserted", "applyPatch add: inserted at position 2", { got: result[2] });
          A(result[3] === "line3", "applyPatch add: line3 moved to position 3", { got: result[3] });
        })();

        // --- Unit 5: applyPatchLines - deletion ---
        (function test_applyPatch_del() {
          const prev = ["alpha", "beta", "gamma", "delta"];
          const patch = "@@ -2,2 +2,1 @@\n-beta\n gamma";
          const result = applyPatchLines(prev, patch);
          A(result.length === 3, "applyPatch del: length 3", { got: result.length });
          A(result[0] === "alpha", "applyPatch del: alpha kept");
          A(result[1] === "gamma", "applyPatch del: gamma at pos 1", { got: result[1] });
          A(result[2] === "delta", "applyPatch del: delta at pos 2", { got: result[2] });
        })();

        // --- Unit 6: applyPatchLines - replacement ---
        (function test_applyPatch_replace() {
          const prev = ["a", "b", "c"];
          const patch = "@@ -2,1 +2,1 @@\n-b\n+B";
          const result = applyPatchLines(prev, patch);
          A(result.length === 3, "applyPatch replace: length 3", { got: result.length });
          A(result[1] === "B", "applyPatch replace: b -> B", { got: result[1] });
        })();

        // --- Unit 7: applyPatchLines - empty patch ---
        (function test_applyPatch_empty() {
          const prev = ["x", "y"];
          const result = applyPatchLines(prev, "");
          A(result.length === 2, "applyPatch empty: no change", { got: result.length });
          A(result[0] === "x" && result[1] === "y", "applyPatch empty: content preserved");
        })();

        // --- Unit 8: applyPatchLines - sequential series reconstruction ---
        (function test_applyPatch_series() {
          let lines = ["# Title", "", "Paragraph one."];
          const patches = [
            "@@ -3,1 +3,2 @@\n Paragraph one.\n+Paragraph two.",
            "@@ -1,1 +1,1 @@\n-# Title\n+# Updated Title",
            "@@ -4,1 +4,2 @@\n Paragraph two.\n+Paragraph three.",
          ];
          for (const p of patches) lines = applyPatchLines(lines, p);
          A(lines.length === 5, "applyPatch series: 5 lines after 3 patches", { got: lines.length });
          A(lines[0] === "# Updated Title", "applyPatch series: title updated", { got: lines[0] });
          A(lines[4] === "Paragraph three.", "applyPatch series: para 3 added", { got: lines[4] });
          log("Series result: " + JSON.stringify(lines));
        })();

        // --- Unit 9: quickMetricsFromPatch - basic metrics ---
        (function test_quickMetrics_basic() {
          const patch = "@@ -1,2 +1,3 @@\n context\n-removed line\n+added line one\n+added line two";
          const m = quickMetricsFromPatch(patch);
          A(m.hunks === 1, "quickMetrics: 1 hunk", { got: m.hunks });
          A(m.addLines === 2, "quickMetrics: 2 add lines", { got: m.addLines });
          A(m.delLines === 1, "quickMetrics: 1 del line", { got: m.delLines });
          A(m.tokensChanged > 0, "quickMetrics: tokensChanged > 0", { got: m.tokensChanged });
          A(m.bytesChanged > 0, "quickMetrics: bytesChanged > 0", { got: m.bytesChanged });
          A(m.tokensDelta > 0, "quickMetrics: tokensDelta positive (net add)", { got: m.tokensDelta });
          A(m.bytesDelta > 0, "quickMetrics: bytesDelta positive (net add)", { got: m.bytesDelta });
        })();

        // --- Unit 10: quickMetricsFromPatch - empty ---
        (function test_quickMetrics_empty() {
          const m = quickMetricsFromPatch("");
          A(m.hunks === 0, "quickMetrics empty: 0 hunks");
          A(m.addLines === 0, "quickMetrics empty: 0 add");
          A(m.delLines === 0, "quickMetrics empty: 0 del");
        })();

        // --- Unit 11: quickMetricsFromPatch - skips +++ and --- lines ---
        (function test_quickMetrics_skipHeaders() {
          const patch = "--- a/file.md\n+++ b/file.md\n@@ -1,1 +1,2 @@\n context\n+added";
          const m = quickMetricsFromPatch(patch);
          A(m.addLines === 1, "quickMetrics headers: only 1 add (skips +++)", { got: m.addLines });
          A(m.delLines === 0, "quickMetrics headers: 0 del (skips ---)", { got: m.delLines });
        })();

        // --- Unit 12: parseCommitLog - structure ---
	        (function test_parseCommitLog_structure() {
	          const commits = parseCommitLog();
	          A(Array.isArray(commits), "parseCommitLog: returns array");
	          const expected = Number(DATASET.meta?.commit_count || 0);
	          if (expected) A(commits.length === expected, "parseCommitLog: same length as DB meta commit_count", { got: commits.length, expected });

	          const c0 = commits[0];
	          A(c0.idx === 0, "parseCommitLog: first commit idx=0");
	          A(typeof c0.hash === "string" && c0.hash.length >= 7, "parseCommitLog: hash is string >= 7 chars", { hash: c0.hash });
          A(typeof c0.short === "string", "parseCommitLog: has short hash");
          A(typeof c0.dateIso === "string", "parseCommitLog: has dateIso");
          A(typeof c0.author === "string", "parseCommitLog: has author");
          A(typeof c0.subject === "string", "parseCommitLog: has subject");
          A(c0.url.includes(c0.hash), "parseCommitLog: url contains hash");
          log("First commit: " + c0.short + " '" + c0.subject.slice(0, 40) + "'");
        })();

        // --- Unit 13: parseCommitStats - structure ---
	        (function test_parseCommitStats_structure() {
	          const stats = parseCommitStats();
	          A(stats instanceof Map, "parseCommitStats: returns Map");
	          const expected = Number(DATASET.meta?.commit_count || 0);
	          if (expected) A(stats.size === expected, "parseCommitStats: same size as DB meta commit_count", { got: stats.size, expected });

	          const firstHash = String(parseCommitLog()?.[0]?.hash || "");
	          const s0 = stats.get(firstHash);
	          A(s0 != null, "parseCommitStats: first commit has stats");
	          A(typeof s0.add === "number", "parseCommitStats: has 'add' number");
          A(typeof s0.del === "number", "parseCommitStats: has 'del' number");
          A(typeof s0.impact === "number", "parseCommitStats: has 'impact' number");
          A(s0.impact >= 0, "parseCommitStats: impact >= 0", { got: s0.impact });
          log("First commit stats: add=" + s0.add + ", del=" + s0.del + ", impact=" + s0.impact);
        })();

	        // --- Unit 14: computeDatasetHash - determinism ---
	        await (async function test_datasetHash_determinism() {
	          const ds = materializeDatasetForWorker();
	          const h1 = await computeDatasetHash(ds);
	          const h2 = await computeDatasetHash(ds);
	          A(h1 === h2, "datasetHash: same data -> same hash", { h1: h1.slice(0, 16), h2: h2.slice(0, 16) });
	          A(typeof h1 === "string" && h1.length > 0, "datasetHash: non-empty string", { len: h1.length });
	          log("Dataset hash: " + h1.slice(0, 24) + "...");

          // Different data -> different hash.
          const fakeData = { commits: [{ hash: "fake123" }], patches: ["fake"], base_doc: "fake" };
          const h3 = await computeDatasetHash(fakeData);
          A(h3 !== h1, "datasetHash: different data -> different hash", { real: h1.slice(0, 16), fake: h3.slice(0, 16) });
        })();

	        // --- Unit 15: Real dataset patch apply reconstruction ---
	        (function test_realDataset_reconstruction() {
	          const d = materializeDatasetForWorker();
	          if (!d.base_doc || !d.patches || d.patches.length < 3) {
	            A(true, "realReconstruction: skipped (insufficient patches)");
	            return;
	          }

          // Reconstruct first 3 snapshots.
          let lines = String(d.base_doc).split("\n");
          A(lines.length > 0, "realReconstruction: base_doc has lines", { count: lines.length });

          for (let i = 1; i <= Math.min(3, d.patches.length - 1); i++) {
            const patch = d.patches[i];
            if (!patch) continue;
            const before = lines.length;
            lines = applyPatchLines(lines, patch);
            A(lines.length > 0, "realReconstruction: patch " + i + " produces non-empty doc", { before, after: lines.length });
            log("Patch " + i + ": " + before + " -> " + lines.length + " lines");
          }

          // Verify reconstructed text has markdown headings.
          const text = lines.join("\n");
          const headingMatch = text.match(/^#+ /m);
          A(headingMatch != null, "realReconstruction: reconstructed text has markdown headings");
        })();

        // --- Unit 16: Metrics consistency with ALL_COMMITS ---
        (function test_metricsConsistency() {
          const stats = parseCommitStats();
          let mismatches = 0;
          for (let i = 0; i < Math.min(10, ALL_COMMITS.length); i++) {
            const c = ALL_COMMITS[i];
            const s = stats.get(c.hash);
            if (!s) { mismatches++; continue; }
            if (c.add !== s.add || c.del !== s.del) mismatches++;
          }
          A(mismatches === 0, "metricsConsistency: ALL_COMMITS matches parseCommitStats for first 10", { mismatches });
	        })();

	        // --- Diagnostics ---
	        { const ds = materializeDatasetForWorker(); log("Dataset: " + ds.commits.length + " commits, " + (ds.patches?.length || 0) + " patches, base_doc=" + (ds.base_doc?.length || 0) + " chars"); }

	        // --- Summary ---
	        const p = R.filter(x => x.pass).length, f = R.filter(x => !x.pass).length;
	        const s = `Dataset Tool Tests: ${p} passed, ${f} failed, ${R.length} total`;
        if (f > 0) { console.warn(s); R.filter(x => !x.pass).forEach(x => console.error("  FAIL:", x.msg, x.ctx || "")); }
        else console.log("%c" + s, "color:green;font-weight:bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Dataset Tool Unit Tests ----




      // ---- Performance E2E Tests (bd-24q.5.5) ----
      // Run via console: window.__runPerfE2ETests()
      window.__runPerfE2ETests = async function () {
        const R = [];
        const A = (c, m, x) => { R.push(c ? { pass: true, msg: m } : { pass: false, msg: m, ctx: x }); if (!c) console.error("FAIL:", m, x || ""); };
        const log = (m) => console.log("  [perf-e2e]", m);

        // --- 1. PERF_BUDGET object exists and is functional ---
        log("Testing PERF_BUDGET...");
        A(typeof PERF_BUDGET === "object", "perf: PERF_BUDGET object exists");
        A(typeof PERF_BUDGET.log === "function", "perf: PERF_BUDGET.log is function");
        A(typeof PERF_BUDGET.summary === "function", "perf: PERF_BUDGET.summary is function");
        A(Array.isArray(PERF_BUDGET.entries), "perf: PERF_BUDGET.entries is array");

        // --- 2. PERF_BUDGET tracks entries ---
        log("Testing PERF_BUDGET tracking...");
        const entriesBefore = PERF_BUDGET.entries.length;
        PERF_BUDGET.log("test_op_e2e", 42.5, false);
        A(PERF_BUDGET.entries.length === entriesBefore + 1, "perf: log adds entry", { before: entriesBefore, after: PERF_BUDGET.entries.length });
        const lastEntry = PERF_BUDGET.entries[PERF_BUDGET.entries.length - 1];
        A(lastEntry.op === "test_op_e2e", "perf: entry has correct op", { op: lastEntry.op });
        A(lastEntry.ms === 42.5, "perf: entry has correct ms", { ms: lastEntry.ms });
        A(lastEntry.cached === false, "perf: entry has cached flag", { cached: lastEntry.cached });
        A(typeof lastEntry.ts === "number", "perf: entry has timestamp");

        // Cache hit entry
        PERF_BUDGET.log("test_op_e2e_cached", 0.1, true);
        const cachedEntry = PERF_BUDGET.entries[PERF_BUDGET.entries.length - 1];
        A(cachedEntry.cached === true, "perf: cached entry has cached=true");

        // --- 3. PERF_BUDGET summary ---
        log("Testing PERF_BUDGET.summary()...");
        const s = PERF_BUDGET.summary();
        A(typeof s.totalMs === "number", "perf: summary has totalMs", { totalMs: s.totalMs });
        A(typeof s.hitRate === "string", "perf: summary has hitRate string", { hitRate: s.hitRate });
        A(typeof s.hits === "number", "perf: summary has hits count", { hits: s.hits });
        A(typeof s.misses === "number", "perf: summary has misses count", { misses: s.misses });
        A(s.entries.length >= 2, "perf: summary entries include our test ops", { len: s.entries.length });

        // --- 4. WORKER_RESULT_CACHE integration ---
        log("Testing WORKER_RESULT_CACHE integration...");
        A(typeof WORKER_RESULT_CACHE === "object", "cache: WORKER_RESULT_CACHE exists");
        A(typeof WORKER_RESULT_CACHE.get === "function", "cache: has get method");
        A(typeof WORKER_RESULT_CACHE.set === "function", "cache: has set method");
        A(typeof WORKER_RESULT_CACHE.size === "number", "cache: has size property");

        // --- 5. Cache hit on repeated worker request ---
        log("Testing cache hit on repeated workerRequest...");
        if (WORKER_STATE.ready) {
          try {
            // First request — cache miss (or already cached from warmup)
            const hitsBefore = PERF_BUDGET.cacheHits;
            const r1 = await workerRequest("compute_clusters", { limit: 3, threshold: 0.3 }, { timeoutMs: 30000 });
            A(r1 !== undefined && r1 !== null, "cache-hit: first request returns data");
            A(Array.isArray(r1.clusters), "cache-hit: first request has clusters array");

            // Second request — should be a cache hit
            const hitsBefore2 = PERF_BUDGET.cacheHits;
            const r2 = await workerRequest("compute_clusters", { limit: 3, threshold: 0.3 }, { timeoutMs: 30000 });
            A(r2 !== undefined && r2 !== null, "cache-hit: second request returns data");
            A(PERF_BUDGET.cacheHits > hitsBefore2, "cache-hit: second request logged as cache hit", { before: hitsBefore2, after: PERF_BUDGET.cacheHits });

            // Verify same data
            A(r1.clusters.length === r2.clusters.length, "cache-hit: same result both times", { c1: r1.clusters.length, c2: r2.clusters.length });
            log("Cache hit confirmed for compute_clusters");
          } catch (e) {
            A(false, "cache-hit: worker request threw", { err: String(e) });
          }
        } else {
          log("Worker not ready, skipping cache hit test");
          A(true, "cache-hit: skipped (worker not ready)");
        }

        // --- 6. Uncacheable ops bypass cache ---
        log("Testing uncacheable ops...");
        A(typeof _UNCACHEABLE_OPS === "object", "uncacheable: _UNCACHEABLE_OPS exists");
        A(_UNCACHEABLE_OPS.has("init_dataset"), "uncacheable: init_dataset is uncacheable");
        A(_UNCACHEABLE_OPS.has("cancel"), "uncacheable: cancel is uncacheable");
        A(_UNCACHEABLE_OPS.has("compute_minhash_signatures"), "uncacheable: compute_minhash_signatures is uncacheable");

        // --- 7. Progress UI elements exist ---
        log("Testing progress UI elements...");
        A(document.getElementById("warmupProgress") !== null, "progress-ui: warmupProgress div exists");
        A(document.getElementById("warmupProgressBar") !== null, "progress-ui: warmupProgressBar div exists");
        A(document.getElementById("warmupProgressLabel") !== null, "progress-ui: warmupProgressLabel span exists");
        A(document.getElementById("warmupStage") !== null, "progress-ui: warmupStage div exists");
        A(document.getElementById("btnCancelWarmup") !== null, "progress-ui: btnCancelWarmup button exists");
        A(document.getElementById("computeProgress") !== null, "progress-ui: computeProgress div exists");
        A(document.getElementById("btnCancelCompute") !== null, "progress-ui: btnCancelCompute button exists");

        // --- 8. showWarmupProgress / hideWarmupProgress work ---
        log("Testing showWarmupProgress / hideWarmupProgress...");
        showWarmupProgress(50, "Test stage");
        const wp = document.getElementById("warmupProgress");
        A(!wp.classList.contains("hidden"), "progress-ui: showWarmupProgress removes hidden class");
        const bar = document.getElementById("warmupProgressBar");
        A(bar.style.width === "50%", "progress-ui: bar width set to 50%", { width: bar.style.width });
        const label = document.getElementById("warmupProgressLabel");
        A(label.textContent === "50%", "progress-ui: label shows 50%", { text: label.textContent });
        const stage = document.getElementById("warmupStage");
        A(stage.textContent === "Test stage", "progress-ui: stage text set", { text: stage.textContent });

        hideWarmupProgress();
        A(wp.classList.contains("hidden"), "progress-ui: hideWarmupProgress adds hidden class");

        // --- 9. Progress clamping ---
        log("Testing progress clamping...");
        showWarmupProgress(-10, "Negative");
        A(bar.style.width === "0%", "progress-ui: negative clamped to 0%", { width: bar.style.width });
        showWarmupProgress(150, "Over");
        A(bar.style.width === "100%", "progress-ui: >100 clamped to 100%", { width: bar.style.width });
        hideWarmupProgress();

        // --- 10. WARMUP_ABORT_CONTROLLER ---
        log("Testing warmup abort controller...");
        A(typeof WARMUP_ABORT_CONTROLLER === "object" || WARMUP_ABORT_CONTROLLER === null, "abort: WARMUP_ABORT_CONTROLLER exists or is null");

        // --- 11. Warmup timing entries recorded ---
        log("Testing warmup timing entries...");
        if (WORKER_STATE.ready && WORKER_DERIVED.searchReady) {
          const warmupOps = PERF_BUDGET.entries.filter(e => e.op === "search_index" || e.op === "minhash_signatures" || e.op === "compute_clusters" || e.op === "most_edited_sections" || e.op === "warmup_total");
          A(warmupOps.length > 0, "timing: warmup ops recorded in PERF_BUDGET", { count: warmupOps.length, ops: warmupOps.map(e => e.op) });
          log("Warmup entries: " + warmupOps.map(e => e.op + "=" + e.ms.toFixed(0) + "ms").join(", "));

          // Check warmup_total exists
          const totalEntry = warmupOps.find(e => e.op === "warmup_total");
          if (totalEntry) {
            A(totalEntry.ms > 0, "timing: warmup_total > 0ms", { ms: totalEntry.ms });
            log("Total warmup time: " + totalEntry.ms.toFixed(0) + "ms");
          }
        } else {
          log("Worker not ready or search not ready, skipping warmup timing test");
          A(true, "timing: skipped (worker/search not ready)");
        }

        // --- 12. window.__perfBudget exposed ---
        log("Testing window.__perfBudget...");
        A(window.__perfBudget === PERF_BUDGET, "exposed: window.__perfBudget === PERF_BUDGET");

        // --- 13. Cache hit rate calculation ---
        log("Testing cache hit rate...");
        const budget = PERF_BUDGET.summary();
        const totalOps = budget.hits + budget.misses;
        if (totalOps > 0) {
          const rate = parseFloat(budget.hitRate);
          A(!isNaN(rate), "hitRate: is valid number", { hitRate: budget.hitRate });
          A(rate >= 0 && rate <= 100, "hitRate: between 0-100%", { rate });
          log("Overall cache hit rate: " + budget.hitRate + "% (" + budget.hits + "/" + totalOps + ")");
        } else {
          A(true, "hitRate: no ops to measure (skipped)");
        }

        // --- Diagnostics ---
        const failed = R.filter(r => !r.pass);
        if (failed.length > 0) {
          console.group("Performance E2E Test Diagnostics");
          failed.forEach(r => console.error("  FAIL:", r.msg, r.ctx || ""));
          console.log("PERF_BUDGET:", PERF_BUDGET.summary());
          console.log("WORKER_STATE:", { ready: WORKER_STATE.ready, disabled: WORKER_STATE.disabled });
          console.log("WORKER_DERIVED:", { ...WORKER_DERIVED });
          console.groupEnd();
        }

        // --- Summary ---
        const p = R.filter(r => r.pass).length, f = R.filter(r => !r.pass).length;
        const summary = "Performance E2E Tests: " + p + " passed, " + f + " failed, " + R.length + " total";
        if (f > 0) { console.warn(summary); R.filter(r => !r.pass).forEach(r => console.error("  FAIL:", r.msg, r.ctx || "")); }
        else console.log("%c" + summary, "color: green; font-weight: bold");
        return { passed: p, failed: f, total: R.length, results: R };
      };
      // ---- End Performance E2E Tests ----

      async function levenshteinForPatchLocal(patch) {
        const hunks = parseUnifiedHunks(patch);
        const enc = new TextEncoder();
        let sum = 0;
        for (const h of hunks) {
          const oldLines = [];
          const newLines = [];
          for (const hl of h.lines) {
            if (!hl) continue;
            const p = hl[0];
            const content = hl.slice(1);
            if (p === "-") oldLines.push(content);
            if (p === "+") newLines.push(content);
          }
          if (!oldLines.length && !newLines.length) continue;
          const a = enc.encode(oldLines.join("\n"));
          const b = enc.encode(newLines.join("\n"));
          if (a.length > 20000 || b.length > 20000) {
            // Worst-case guard: fallback to a cheap upper bound.
            sum += a.length + b.length;
          } else {
            sum += await levenshteinBytes(a, b);
          }
        }
        return sum;
      }

      async function levenshteinForPatch(patch, opts = {}) {
        if (WORKER_STATE.ready && !opts.localOnly) {
          try {
            const res = await workerRequest("levenshtein_patch", { patch }, { timeoutMs: 30000, signal: opts.signal });
            if (Number.isFinite(Number(res?.lev))) return Number(res.lev);
          } catch (e) {
            if (e?.name === "AbortError") throw e;
            console.error("Worker Levenshtein failed; using local fallback:", e);
          }
        }
        return levenshteinForPatchLocal(patch);
      }

      function selectCommitIdx(idx, opts = {}) {
        const max = Math.max(0, (ALL_COMMITS.length || 1) - 1);
        const next = clamp(Number(idx || 0), 0, max);
        DOC.idx = next;

        const slider = document.getElementById("dockSlider");
        if (slider) slider.value = String(next);

        syncDockAndDoc();
        if (!opts._fromPopstate) syncUrlToState();
        // Update story rail if visible.
        if (!document.getElementById("storyRail")?.classList.contains("hidden")) renderStoryCards();

        if (opts.scrollToCommitList) {
          const c = ALL_COMMITS[next];
          const el = c ? document.getElementById(`commit-${c.hash}`) : null;
          if (el) {
            el.scrollIntoView({ behavior: "smooth", block: "start" });
            el.open = true;
          }
        }
      }

      // -------------------------------------------------------
      // Story Mode: Desktop UI (bd-24q.4.2)
      // -------------------------------------------------------
      let _storyMilestones = [];
      let _storyActiveIdx = -1;

      /** Render milestone cards in the story rail. */
      function renderStoryCards() {
        const rail = document.getElementById("storyRail");
        const container = document.getElementById("storyCards");
        if (!rail || !container || rail.classList.contains("hidden")) return;

        _storyMilestones = getMilestones().filter((m) => m.commitIdx !== null);

        if (!_storyMilestones.length) {
          container.innerHTML = '<div class="text-[11px] text-slate-400 italic">No milestones available</div>';
          _updateStoryProgress();
          return;
        }

        // Find which milestone is closest to (at or before) current DOC.idx.
        _storyActiveIdx = -1;
        for (let i = _storyMilestones.length - 1; i >= 0; i--) {
          if (_storyMilestones[i].commitIdx <= DOC.idx) { _storyActiveIdx = i; break; }
        }
        if (_storyActiveIdx === -1 && _storyMilestones.length) _storyActiveIdx = 0;

        const md = window._mdSingleton || window.markdownit?.();
        container.innerHTML = _storyMilestones.map((m, i) => {
          const isActive = i === _storyActiveIdx;
          const commit = ALL_COMMITS[m.commitIdx];
          const date = commit?.dateIso ? new Date(commit.dateIso).toLocaleDateString() : "";
          const annotationHtml = md ? md.render(m.annotationMd || "") : escapeHtml(m.annotationMd || "");
          const metrics = commit ? `+${fmtInt(commit.add || 0)} -${fmtInt(commit.del || 0)}` : "";
          return `<div class="story-card rounded-xl border p-3 cursor-pointer transition-all ${isActive ? 'border-blue-400 bg-blue-50/80 shadow-sm' : 'border-slate-900/10 bg-white/60 hover:bg-slate-50'}" data-story-idx="${i}">
            <div class="flex items-center gap-2">
              <span class="inline-block w-2 h-2 rounded-full shrink-0 ${isActive ? 'bg-blue-500' : 'bg-slate-300'}"></span>
              <span class="text-[11px] font-semibold ${isActive ? 'text-blue-900' : 'text-slate-700'} truncate">${escapeHtml(m.title)}</span>
            </div>
            <div class="mt-1.5 text-[10px] leading-snug text-slate-600 story-annotation">${annotationHtml}</div>
            <div class="mt-1.5 flex items-center gap-2 text-[10px] text-slate-400">
              ${date ? `<span>${escapeHtml(date)}</span>` : ""}
              ${metrics ? `<span class="mono">${escapeHtml(metrics)}</span>` : ""}
            </div>
          </div>`;
        }).join("");

        // Click handlers.
        container.querySelectorAll(".story-card").forEach((card) => {
          card.addEventListener("click", () => {
            const idx = Number(card.dataset.storyIdx);
            const m = _storyMilestones[idx];
            if (!m) return;
            selectCommitIdx(m.commitIdx);
            if (m.defaultTab) setDocTab(m.defaultTab);
            // Focus heading after render settles.
            if (m.focusHeading) {
              requestAnimationFrame(() => {
                const docEl = document.getElementById("docRendered");
                const target = docEl?.querySelector("#" + CSS.escape(m.focusHeading));
                if (target) target.scrollIntoView({ behavior: "smooth", block: "start" });
              });
            }
            _storyActiveIdx = idx;
            renderStoryCards();
          });
        });

        // Scroll active card into view.
        const activeCard = container.querySelector(`.story-card[data-story-idx="${_storyActiveIdx}"]`);
        if (activeCard) activeCard.scrollIntoView({ block: "nearest", behavior: "smooth" });

        _updateStoryProgress();
      }

      function _updateStoryProgress() {
        const el = document.getElementById("storyProgress");
        if (el) el.textContent = _storyMilestones.length ? `${_storyActiveIdx + 1}/${_storyMilestones.length}` : "0/0";
      }

      function storyGoToIdx(storyIdx) {
        const m = _storyMilestones[storyIdx];
        if (!m) return;
        selectCommitIdx(m.commitIdx);
        if (m.defaultTab) setDocTab(m.defaultTab);
        if (m.focusHeading) {
          requestAnimationFrame(() => {
            const docEl = document.getElementById("docRendered");
            const target = docEl?.querySelector("#" + CSS.escape(m.focusHeading));
            if (target) target.scrollIntoView({ behavior: "smooth", block: "start" });
          });
        }
        _storyActiveIdx = storyIdx;
        renderStoryCards();
      }

      function storyPrev() {
        if (_storyActiveIdx > 0) storyGoToIdx(_storyActiveIdx - 1);
      }

      function storyNext() {
        if (_storyActiveIdx < _storyMilestones.length - 1) storyGoToIdx(_storyActiveIdx + 1);
      }

      // -------------------------------------------------------
      // Story Autoplay Integration (bd-24q.4.4)
      // -------------------------------------------------------
      // Autoplay through commits, pausing at each milestone to present the story card.
      // Manual storyPrev/storyNext during autoplay update milestoneIdx without breaking state.

      const STORY_AUTOPLAY = {
        enabled: false,           // story autoplay mode active
        milestoneIdx: -1,         // index into _storyMilestones; -1 = before first
        pausedAtMilestone: false, // currently paused presenting a card
        _milestoneCommitSet: null, // Set of commitIdx values for O(1) lookup
      };

      /** Build a Set of milestone commitIdx values for fast lookup in _playbackFrame. */
      function _storyAutoplayBuildSet() {
        STORY_AUTOPLAY._milestoneCommitSet = new Set(
          _storyMilestones.map(m => m.commitIdx).filter(i => i != null)
        );
      }

      /** Start story autoplay: opens story rail, begins playback, pauses at milestones. */
      function storyAutoplayStart() {
        if (window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches) return;
        // Ensure milestones are populated.
        _storyMilestones = getMilestones().filter(m => m.commitIdx !== null);
        if (!_storyMilestones.length) return;
        _storyAutoplayBuildSet();

        // Show story rail if hidden.
        const rail = document.getElementById("storyRail");
        if (rail?.classList.contains("hidden")) {
          rail.classList.remove("hidden");
          const btn = document.getElementById("btnStoryToggle");
          if (btn) { btn.classList.add("bg-slate-900", "text-white"); btn.classList.remove("bg-white/70", "text-slate-900"); }
        }

        // Find which milestone is at or just before current DOC.idx.
        STORY_AUTOPLAY.milestoneIdx = -1;
        for (let i = _storyMilestones.length - 1; i >= 0; i--) {
          if (_storyMilestones[i].commitIdx <= DOC.idx) { STORY_AUTOPLAY.milestoneIdx = i; break; }
        }

        STORY_AUTOPLAY.enabled = true;
        STORY_AUTOPLAY.pausedAtMilestone = false;
        _syncStoryAutoplayUI();
        syncUrlToState();

        // Start playback.
        playbackPlay();
      }

      /** Stop story autoplay and return to normal playback. */
      function storyAutoplayStop() {
        STORY_AUTOPLAY.enabled = false;
        STORY_AUTOPLAY.pausedAtMilestone = false;
        STORY_AUTOPLAY.milestoneIdx = -1;
        STORY_AUTOPLAY._milestoneCommitSet = null;
        _syncStoryAutoplayUI();
        syncUrlToState();
      }

      /** Resume after pausing at a milestone: advance to next segment. */
      function storyAutoplayResume() {
        if (!STORY_AUTOPLAY.enabled || !STORY_AUTOPLAY.pausedAtMilestone) return;
        STORY_AUTOPLAY.pausedAtMilestone = false;

        // If we're at the last milestone, stop autoplay.
        if (STORY_AUTOPLAY.milestoneIdx >= _storyMilestones.length - 1) {
          storyAutoplayStop();
          playbackStop();
          return;
        }

        // Resume playback to advance toward next milestone.
        playbackPlay();
        _syncStoryAutoplayUI();
      }

      /**
       * Called from _playbackFrame after advancing DOC.idx.
       * Checks if we've hit a milestone and should pause.
       * Returns true if we paused (caller should not schedule next frame).
       */
      function _storyAutoplayCheckMilestone(commitIdx) {
        if (!STORY_AUTOPLAY.enabled || STORY_AUTOPLAY.pausedAtMilestone) return false;
        if (!STORY_AUTOPLAY._milestoneCommitSet?.has(commitIdx)) return false;

        // Find which milestone this is.
        const msIdx = _storyMilestones.findIndex(m => m.commitIdx === commitIdx);
        if (msIdx < 0) return false;
        // Only pause at milestones AFTER current one (or at first if milestoneIdx is -1).
        if (msIdx <= STORY_AUTOPLAY.milestoneIdx) return false;

        STORY_AUTOPLAY.milestoneIdx = msIdx;
        STORY_AUTOPLAY.pausedAtMilestone = true;

        // Pause playback.
        playbackPause();
        _syncPlaybackUI();

        // Update story cards to highlight current milestone.
        _storyActiveIdx = msIdx;
        renderStoryCards();

        // Update mobile story if open.
        _storyMobileIdx = msIdx;
        const mobileSheet = document.getElementById("storyMobileSheet");
        if (mobileSheet && !mobileSheet.classList.contains("hidden")) _renderStoryMobileCard();

        _syncStoryAutoplayUI();
        return true;
      }

      /** Update autoplay button appearance. */
      function _syncStoryAutoplayUI() {
        const btn = document.getElementById("storyAutoplayBtn");
        if (btn) {
          if (STORY_AUTOPLAY.enabled) {
            if (STORY_AUTOPLAY.pausedAtMilestone) {
              btn.innerHTML = "&#9654; Continue";
              btn.classList.add("bg-blue-600", "text-white");
              btn.classList.remove("bg-white/80", "text-slate-600", "bg-slate-900");
            } else {
              btn.textContent = "Stop Tour";
              btn.classList.add("bg-slate-900", "text-white");
              btn.classList.remove("bg-white/80", "text-slate-600", "bg-blue-600");
            }
          } else {
            btn.innerHTML = "&#9654; Tour";
            btn.classList.remove("bg-slate-900", "bg-blue-600", "text-white");
            btn.classList.add("bg-white/80", "text-slate-600");
          }
        }
        // Mobile autoplay button.
        const mBtn = document.getElementById("storyMobileAutoplay");
        if (mBtn) {
          if (STORY_AUTOPLAY.enabled) {
            if (STORY_AUTOPLAY.pausedAtMilestone) {
              mBtn.innerHTML = "&#9654; Continue";
              mBtn.classList.add("bg-blue-600", "text-white");
              mBtn.classList.remove("bg-slate-100", "text-slate-700", "bg-slate-900");
            } else {
              mBtn.textContent = "Stop Tour";
              mBtn.classList.add("bg-slate-900", "text-white");
              mBtn.classList.remove("bg-slate-100", "text-slate-700", "bg-blue-600");
            }
          } else {
            mBtn.innerHTML = "&#9654; Tour";
            mBtn.classList.remove("bg-slate-900", "bg-blue-600", "text-white");
            mBtn.classList.add("bg-slate-100", "text-slate-700");
          }
        }
      }

      // -------------------------------------------------------
      // Playback: Core Scheduler + State Machine (bd-24q.7.1)
      // -------------------------------------------------------
      // States: "paused" | "playing" | "seeking"
      // Transitions:
      //   paused  -> playing  (play)
      //   playing -> paused   (pause / reach end without loop / visibility hidden)
      //   playing -> seeking  (manual scrub during playback)
      //   seeking -> playing  (scrub ends, resume)
      //   seeking -> paused   (scrub ends, was paused before)
      //   any     -> paused   (stop)

      const PLAYBACK = {
        state: "paused",         // "paused" | "playing" | "seeking"
        speed: 1,                // commits per second (0.25, 0.5, 1, 2, 4)
        loop: false,             // loop back to start at end
        _preSeekState: "paused", // state to restore after seeking
        _rafId: 0,               // requestAnimationFrame id
        _lastTickTime: 0,        // performance.now() of last tick
        _accumMs: 0,             // accumulated sub-tick milliseconds (drift correction)
        _visCleanup: null,       // cleanup for visibilitychange listener
      };

      const PLAYBACK_SPEEDS = [0.25, 0.5, 1, 2, 4];

      /** Pure: compute how many commits to advance given elapsed ms and speed. */
      function playbackTicksForElapsed(elapsedMs, speed, accumMs) {
        const totalMs = accumMs + elapsedMs;
        const intervalMs = 1000 / speed;
        const ticks = Math.floor(totalMs / intervalMs);
        const remainder = totalMs - ticks * intervalMs;
        return { ticks, remainder };
      }

      /** Pure: compute next commit index given current, ticks, max, and loop flag. */
      function playbackNextIndex(currentIdx, ticks, maxIdx, loop) {
        if (ticks <= 0) return { idx: currentIdx, stopped: false };
        let next = currentIdx + ticks;
        if (next > maxIdx) {
          if (loop) {
            next = next % (maxIdx + 1);
          } else {
            return { idx: maxIdx, stopped: true };
          }
        }
        return { idx: next, stopped: false };
      }

      /** Pure: validate and return a transition, or null if invalid. */
      function playbackTransition(currentState, action) {
        const transitions = {
          paused:  { play: "playing", seek: "seeking" },
          playing: { pause: "paused", seek: "seeking", stop: "paused", end: "paused" },
          seeking: { resume: null, stop: "paused" }, // resume target computed at runtime
        };
        const t = transitions[currentState];
        if (!t || !(action in t)) return null;
        if (currentState === "seeking" && action === "resume") {
          return PLAYBACK._preSeekState === "playing" ? "playing" : "paused";
        }
        return t[action];
      }

      function playbackPlay() {
        // Respect prefers-reduced-motion (a11y).
        if (window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches) return;
        const next = playbackTransition(PLAYBACK.state, "play");
        if (!next) return;
        PLAYBACK.state = next;
        PLAYBACK._lastTickTime = performance.now();
        PLAYBACK._accumMs = 0;
        _playbackInstallVisibility();
        _playbackSchedule();
      }

      function playbackPause() {
        const next = playbackTransition(PLAYBACK.state, "pause")
          || playbackTransition(PLAYBACK.state, "stop");
        if (!next) return;
        PLAYBACK.state = next;
        _playbackCancel();
      }

      function playbackStop() {
        PLAYBACK.state = "paused";
        PLAYBACK._accumMs = 0;
        _playbackCancel();
        _playbackRemoveVisibility();
        _syncPlaybackUI();
      }

      function playbackToggle() {
        if (PLAYBACK.state === "playing") playbackPause();
        else playbackPlay();
        _syncPlaybackUI();
      }

      function playbackSetSpeed(speed) {
        PLAYBACK.speed = Math.max(0.1, Number(speed) || 1);
        PLAYBACK._accumMs = 0;
        PLAYBACK._lastTickTime = performance.now();
      }

      function playbackSetLoop(loop) {
        PLAYBACK.loop = Boolean(loop);
      }

      /** Call when user manually scrubs the slider during playback. */
      function playbackOnManualScrub() {
        if (PLAYBACK.state === "paused") return; // no-op
        PLAYBACK._preSeekState = PLAYBACK.state;
        PLAYBACK.state = "seeking";
        _playbackCancel();
      }

      /** Call when manual scrub ends to optionally resume playback. */
      function playbackOnScrubEnd() {
        if (PLAYBACK.state !== "seeking") return;
        const next = playbackTransition("seeking", "resume");
        PLAYBACK.state = next || "paused";
        if (PLAYBACK.state === "playing") {
          PLAYBACK._lastTickTime = performance.now();
          PLAYBACK._accumMs = 0;
          _playbackSchedule();
        }
      }

      function _playbackSchedule() {
        if (PLAYBACK.state !== "playing") return;
        PLAYBACK._rafId = requestAnimationFrame(_playbackFrame);
      }

      function _playbackFrame(now) {
        if (PLAYBACK.state !== "playing") return;
        const elapsed = now - PLAYBACK._lastTickTime;
        PLAYBACK._lastTickTime = now;

        const { ticks, remainder } = playbackTicksForElapsed(elapsed, PLAYBACK.speed, PLAYBACK._accumMs);
        PLAYBACK._accumMs = remainder;

        if (ticks > 0) {
          const maxIdx = Math.max(0, (ALL_COMMITS.length || 1) - 1);
          const { idx, stopped } = playbackNextIndex(DOC.idx, ticks, maxIdx, PLAYBACK.loop);
          selectCommitIdx(idx);
          if (stopped) {
            if (STORY_AUTOPLAY.enabled) storyAutoplayStop();
            playbackStop();
            return;
          }
          // Story autoplay: check if we hit a milestone (bd-24q.4.4).
          if (_storyAutoplayCheckMilestone(idx)) return;
        }
        _playbackSchedule();
      }

      function _playbackCancel() {
        if (PLAYBACK._rafId) {
          cancelAnimationFrame(PLAYBACK._rafId);
          PLAYBACK._rafId = 0;
        }
      }

      /** Update playback UI elements to match PLAYBACK state. */
      function _syncPlaybackUI() {
        const btn = document.getElementById("dockPlayPause");
        if (btn) {
          btn.innerHTML = PLAYBACK.state === "playing" ? "&#9646;&#9646;" : "&#9654;";
          btn.classList.toggle("bg-slate-900", PLAYBACK.state === "playing");
          btn.classList.toggle("text-white", PLAYBACK.state === "playing");
          btn.classList.toggle("bg-white/70", PLAYBACK.state !== "playing");
          btn.classList.toggle("text-slate-900", PLAYBACK.state !== "playing");
          btn.setAttribute("aria-label", PLAYBACK.state === "playing" ? "Pause playback" : "Play timeline");
        }
        const speedSel = document.getElementById("dockSpeed");
        if (speedSel) speedSel.value = String(PLAYBACK.speed);
        const loopBtn = document.getElementById("dockLoop");
        if (loopBtn) {
          loopBtn.classList.toggle("bg-slate-900", PLAYBACK.loop);
          loopBtn.classList.toggle("text-white", PLAYBACK.loop);
          loopBtn.classList.toggle("text-slate-500", !PLAYBACK.loop);
        }
      }

      function _playbackInstallVisibility() {
        if (PLAYBACK._visCleanup) return;
        const handler = () => {
          if (document.hidden && PLAYBACK.state === "playing") {
            PLAYBACK._preSeekState = "playing";
            PLAYBACK.state = "paused";
            _playbackCancel();
          } else if (!document.hidden && PLAYBACK._preSeekState === "playing" && PLAYBACK.state === "paused") {
            playbackPlay();
          }
        };
        document.addEventListener("visibilitychange", handler);
        PLAYBACK._visCleanup = () => document.removeEventListener("visibilitychange", handler);
      }

      function _playbackRemoveVisibility() {
        if (PLAYBACK._visCleanup) {
          PLAYBACK._visCleanup();
          PLAYBACK._visCleanup = null;
        }
      }

      function initDockIfNeeded() {
        if (DOCK_READY) return;
        const slider = document.getElementById("dockSlider");
        if (!slider || !ALL_COMMITS.length) return;
        slider.min = "0";
        slider.max = String(ALL_COMMITS.length - 1);
        slider.step = "1";
        document.getElementById("dockLeftLabel").textContent = ALL_COMMITS[0]?.short || "-";
        document.getElementById("dockRightLabel").textContent = ALL_COMMITS[ALL_COMMITS.length - 1]?.short || "-";
        DOCK_READY = true;
      }

      let _lastDrawDockIdx = -1;
      let _lastDrawDockCommitsLen = -1;

      function drawDock() {
        const canvas = document.getElementById("dockCanvas");
        if (!canvas || !ALL_COMMITS.length) return;

        if (_lastDrawDockIdx === DOC.idx && _lastDrawDockCommitsLen === ALL_COMMITS.length) return;
        _lastDrawDockIdx = DOC.idx;
        _lastDrawDockCommitsLen = ALL_COMMITS.length;

        const dpr = window.devicePixelRatio || 1;
        const w = Math.max(1, Math.floor(canvas.clientWidth * dpr));
        const h = Math.max(1, Math.floor(canvas.clientHeight * dpr));
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
        }
        const ctx = canvas.getContext("2d");
        if (!ctx) return;
        ctx.clearRect(0, 0, w, h);

        const maxImpact = Math.max(1, ...ALL_COMMITS.map((c) => Number(c.impact || 0)));
        const barW = w / ALL_COMMITS.length;
        const pad = 2 * dpr;

        for (let i = 0; i < ALL_COMMITS.length; i++) {
          const c = ALL_COMMITS[i];
          const v = Number(c.impact || 0);
          const t = Math.sqrt(v / maxImpact);
          const bh = Math.max(1, (h - pad * 2) * t);
          const x = i * barW;
          const y = h - pad - bh;
          ctx.globalAlpha = 0.9;
          ctx.fillStyle = bucketById(c.primary).color;
          ctx.fillRect(x, y, Math.max(1, barW), bh);
        }

        // Selected marker.
        const sx = DOC.idx * barW;
        ctx.globalAlpha = 1;
        ctx.lineWidth = Math.max(1, dpr);
        ctx.strokeStyle = "rgba(2,6,23,0.85)";
        ctx.strokeRect(sx + 0.5, 0.5, Math.max(1, barW - 1), h - 1);

        // Inset glow
        ctx.globalAlpha = 1;
        ctx.strokeStyle = "rgba(37,99,235,0.35)";
        ctx.strokeRect(sx + 0.5, 1.5, Math.max(1, barW - 1), h - 3);
      }

      const RENDER_CACHE = {
        specIdx: -1,
        specIH: false, // bd-24q.16.2: whether last spec render used inline highlights
        specHtml: "",
        diffIdx: -1,
        diffFromIdx: -1,
        diffToIdx: -1,
        diffLayout: "",
        diffMode: "",
        diffAbViewMode: "",
        diffHtml: "",
      };

      async function updateDocUI() {
        const loading = document.getElementById("docLoading");
        const main = document.getElementById("docMain");
        if (!loading || !main) return;

        if (!DATASET.loaded) {
          loading.classList.remove("hidden");
          main.classList.add("hidden");
          loading.textContent = DATASET.error
            ? `Spec evolution dataset unavailable: ${DATASET.error}`
            : "Loading spec evolution dataset... (local gzip JSON; no GitHub API)";
          return;
        }

        loading.classList.add("hidden");
        main.classList.remove("hidden");
        updateDocPanelVisibility();

        const c = ALL_COMMITS[DOC.idx];
        if (!c) return;

        const dockTitle = document.getElementById("dockTitle");
        if (dockTitle) dockTitle.textContent = `${c.short} · ${c.subject}`;

        const title = document.getElementById("docCommitTitle");
        const meta = document.getElementById("docCommitMeta");
        const link = document.getElementById("docCommitLink");
        if (title) title.textContent = c.subject;
        if (meta) meta.textContent = `${c.short} · ${dayjs(c.dateIso).format("YYYY-MM-DD HH:mm:ss")} · +${fmtInt(c.add)} -${fmtInt(c.del)}`;
        if (link) link.href = c.url;

        // Summary box.
        const sum = document.getElementById("docSummary");
        const tok = METRICS.tokensChanged.get(c.hash);
        const byt = METRICS.bytesChanged.get(c.hash);
        const hn = METRICS.hunks.get(c.hash);
        const lv = METRICS.lev.get(c.hash);
        if (sum) {
          sum.innerHTML = `
            <div class="flex flex-wrap gap-2">
              <span class="chip mono rounded-full px-2.5 py-1 text-[11px] text-slate-700">Impact ${fmtInt(c.impact)}</span>
              <span class="chip mono rounded-full px-2.5 py-1 text-[11px] text-slate-700">Hunks ${fmtInt(hn ?? 0)}</span>
              <span class="chip mono rounded-full px-2.5 py-1 text-[11px] text-slate-700">Tokens ${fmtInt(tok ?? 0)}</span>
              <span class="chip mono rounded-full px-2.5 py-1 text-[11px] text-slate-700">Bytes ${fmtInt(byt ?? 0)}</span>
              <span class="chip mono rounded-full px-2.5 py-1 text-[11px] text-slate-700">Lev ${(lv === null || lv === undefined) ? "?" : fmtInt(lv)}</span>
            </div>
            <div class="mt-2 text-xs text-slate-600">Bucket: <span class="font-semibold">${escapeHtml(bucketById(c.primary).name)}</span></div>
          `;
        }

        // Metrics cards
        const mTokens = document.getElementById("mTokens");
        const mBytes = document.getElementById("mBytes");
        const mHunks = document.getElementById("mHunks");
        const mLev = document.getElementById("mLev");
        if (mTokens) mTokens.textContent = (tok === null || tok === undefined) ? "-" : fmtInt(tok);
        if (mBytes) mBytes.textContent = (byt === null || byt === undefined) ? "-" : fmtInt(byt);
        if (mHunks) mHunks.textContent = (hn === null || hn === undefined) ? "-" : fmtInt(hn);
        if (mLev) mLev.textContent = (lv === null || lv === undefined) ? "-" : fmtInt(lv);

        const patch = patchForIdx(DOC.idx);

        if (DOC.tab === "diff") {
          const raw = document.getElementById("diffRaw");
          const pretty = document.getElementById("diffPretty");
          const inRenderedMode = DOC.compareMode && DOC.abViewMode === "rendered";

          const cacheKey = DOC.compareMode 
            ? `ab|${DOC.compareFromIdx}:${DOC.compareToIdx}|${DOC.diffLayout}|${DOC.diffMode}|${DOC.abViewMode}`
            : `p|${DOC.idx}|${DOC.diffLayout}|${DOC.diffMode}|${DOC.abViewMode}`;

          const cacheMatch = DOC.compareMode
            ? (RENDER_CACHE.diffFromIdx === DOC.compareFromIdx && RENDER_CACHE.diffToIdx === DOC.compareToIdx && RENDER_CACHE.diffLayout === DOC.diffLayout && RENDER_CACHE.diffMode === DOC.diffMode && RENDER_CACHE.diffAbViewMode === DOC.abViewMode)
            : (RENDER_CACHE.diffIdx === DOC.idx && RENDER_CACHE.diffLayout === DOC.diffLayout && RENDER_CACHE.diffMode === DOC.diffMode && RENDER_CACHE.diffAbViewMode === DOC.abViewMode);

          if (!cacheMatch) {
            let diffText = patch || "";
            let abDiffError = false;
            if (DOC.compareMode && DOC.abViewMode !== "rendered") {
              try {
                diffText = await generateABDiff(DOC.compareFromIdx, DOC.compareToIdx);
              } catch (e) {
                abDiffError = true;
                diffText = "";
                if (pretty) pretty.innerHTML = `<div class="p-3 text-xs text-red-600">A/B diff failed: ${escapeHtml(String(e?.message || e))}</div>`;
              }
            }
            if (raw) raw.textContent = diffText;

            if (pretty && !abDiffError) {
              if (DOC.diffMode === "pretty") {
                try {
                  const outputFmt = DOC.compareMode ? DOC.diffLayout : "side-by-side";
                  pretty.innerHTML = Diff2Html.html(diffText, {
                    drawFileList: false,
                    matching: "lines",
                    outputFormat: outputFmt,
                  });
                } catch (e) {
                  pretty.innerHTML = `<div class="p-3 text-xs text-slate-700">Diff2Html failed: ${escapeHtml(String(e?.message || e))}</div>`;
                }
              } else {
                pretty.innerHTML = "";
              }
            }

            const sbsContainer = document.getElementById("sbsContainer");
            if (sbsContainer) {
              sbsContainer.classList.toggle("hidden", !inRenderedMode);
              if (inRenderedMode) void renderSbsPanes();
            }

            if (DOC.compareMode) {
              RENDER_CACHE.diffFromIdx = DOC.compareFromIdx;
              RENDER_CACHE.diffToIdx = DOC.compareToIdx;
            } else {
              RENDER_CACHE.diffIdx = DOC.idx;
            }
            RENDER_CACHE.diffLayout = DOC.diffLayout;
            RENDER_CACHE.diffMode = DOC.diffMode;
            RENDER_CACHE.diffAbViewMode = DOC.abViewMode;
          }

          document.getElementById("diffPretty")?.classList.toggle("hidden", inRenderedMode || DOC.diffMode !== "pretty");
          document.getElementById("diffRaw")?.classList.toggle("hidden", inRenderedMode || DOC.diffMode !== "raw");

          const diffLabel = document.getElementById("diffLabel");
          if (diffLabel) {
            if (DOC.compareMode) {
              const cA = ALL_COMMITS[DOC.compareFromIdx];
              const cB = ALL_COMMITS[DOC.compareToIdx];
              diffLabel.textContent = `Diff (${cA?.short || "#" + DOC.compareFromIdx} → ${cB?.short || "#" + DOC.compareToIdx})`;
            } else {
              diffLabel.textContent = "Diff (parent → selected)";
            }
          }

          const abMetricsBar = document.getElementById("abMetricsBar");
          if (abMetricsBar) {
            if (DOC.compareMode) {
              void computeAndShowABMetrics(DOC.compareFromIdx, DOC.compareToIdx);
            } else {
              abMetricsBar.classList.add("hidden");
            }
          }
        }

        if (DOC.tab === "spec") {
          const raw = document.getElementById("docRaw");
          const rendered = document.getElementById("docRendered");
          const specView = document.getElementById("docSpecView");
          if (specView) specView.classList.remove("hidden");

          // bd-24q.16.2: also re-render when inline highlights toggle changes
          if (RENDER_CACHE.specIdx !== DOC.idx || RENDER_CACHE.specIH !== DOC.inlineHighlights) {
            const text = await docTextAt(DOC.idx);
            if (raw) raw.textContent = text;

            if (rendered && DOC.inlineHighlights && DOC.idx > 0) {
              // bd-24q.16.2: sentinel-based rendering for inline change highlights
              const _ihPatch = patchForIdx(DOC.idx);
              const _ihChanged = parsePatchChangedNewLines(_ihPatch);
              renderMarkdownWithSentinels(text, rendered, "", _ihChanged);
              applyInlineHighlights(rendered);
              _ihRefreshNav(); _ihSetupPopover();
            } else if (rendered) {
              const outline = extractOutline(text);
              OUTLINE_CACHE.set(DOC.idx, outline);

              if (!window._mdSingleton) {
                window._mdSingleton = markdownit({
                  html: false,
                  linkify: true,
                  typographer: true,
                  highlight: (str, lang) => {
                    try {
                      if (lang && hljs.getLanguage(lang)) {
                        return `<pre class="hljs"><code>${hljs.highlight(str, { language: lang }).value}</code></pre>`;
                      }
                      return `<pre class="hljs"><code>${hljs.highlightAuto(str).value}</code></pre>`;
                    } catch {
                      return `<pre class="hljs"><code>${escapeHtml(str)}</code></pre>`;
                    }
                  },
                });
              }

              let outlineIdx = 0;
              const origHeadingOpen = window._mdSingleton.renderer.rules.heading_open;
              window._mdSingleton.renderer.rules.heading_open = (tokens, idx, options, env, self) => {
                const entry = outline[outlineIdx++];
                if (entry) {
                  tokens[idx].attrSet("id", entry.id);
                }
                return self.renderToken(tokens, idx, options);
              };

              const html = window._mdSingleton.render(text || "");
              rendered.innerHTML = DOMPurify.sanitize(html, { ADD_ATTR: ["id"] });

              if (origHeadingOpen) {
                window._mdSingleton.renderer.rules.heading_open = origHeadingOpen;
              } else {
                delete window._mdSingleton.renderer.rules.heading_open;
              }
              clearInlineHighlights(rendered); // bd-24q.16.2
            }
            RENDER_CACHE.specIdx = DOC.idx;
            RENDER_CACHE.specIH = DOC.inlineHighlights; // bd-24q.16.2
          }

          // bd-24q.16.2: sync highlights toggle button + nav bar
          { const _ihB = document.getElementById("btnIHToggle"), _ihN = document.getElementById("ihNav");
            if (_ihB) { _ihB.className = DOC.inlineHighlights ? "focus-ring rounded-xl bg-slate-900 px-3 py-1.5 text-[11px] font-semibold text-white hover:bg-slate-800" : "focus-ring rounded-xl border border-slate-900/10 bg-white/70 px-3 py-1.5 text-[11px] font-semibold text-slate-900 hover:bg-white"; }
            if (_ihN) _ihN.style.display = DOC.inlineHighlights ? "inline-flex" : "none";
          }

          if (rendered) rendered.classList.toggle("hidden", DOC.rawSpec);
          if (raw) raw.classList.toggle("hidden", !DOC.rawSpec);

          void updateMiniMap();
        }

        if (DOC.tab === "sections") {
          void updateSectionSummary();
        }

        if (DATASET.loaded && DOC.idx > 0 && !METRICS.lev.has(c.hash)) {
          void (async () => {
            try {
              const d = await levenshteinForPatch(patch);
              METRICS.lev.set(c.hash, d);
              if (ALL_COMMITS[DOC.idx]?.hash === c.hash) {
                const mLev = document.getElementById("mLev");
                if (mLev) mLev.textContent = fmtInt(d);
                syncDockAndDoc();
              }
            } catch (e) {
              if (e?.name !== "AbortError") {
                console.error("On-demand Levenshtein failed:", e);
                if (ALL_COMMITS[DOC.idx]?.hash === c.hash) {
                  const levNode = document.getElementById("mLev");
                  if (levNode) {
                    levNode.textContent = "ERR";
                    levNode.title = formatErr(e);
                  }
                }
              }
            }
          })();
        }
      }

      let COMPUTE_RUNNING = false;

      function applyMetricsPayload(payload) {
        if (!payload) return;
        const tokens = payload.tokensChanged || {};
        const bytes = payload.bytesChanged || {};
        const hunks = payload.hunks || {};
        const lev = payload.lev || {};
        for (const [hash, value] of Object.entries(tokens)) {
          METRICS.tokensChanged.set(hash, Number(value || 0));
        }
        for (const [hash, value] of Object.entries(bytes)) {
          METRICS.bytesChanged.set(hash, Number(value || 0));
        }
        for (const [hash, value] of Object.entries(hunks)) {
          METRICS.hunks.set(hash, Number(value || 0));
        }
        for (const [hash, value] of Object.entries(lev)) {
          METRICS.lev.set(hash, Number(value || 0));
        }
      }

      async function computeAllMetricsLocal(progressCb, signal) {
        const total = ALL_COMMITS.length;
        for (let i = 0; i < total; i++) {
          if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
          const c = ALL_COMMITS[i];
          const patch = patchForIdx(i);
          if (!METRICS.tokensChanged.has(c.hash) || !METRICS.bytesChanged.has(c.hash) || !METRICS.hunks.has(c.hash)) {
            const qm = quickMetricsFromPatch(patch);
            METRICS.tokensChanged.set(c.hash, qm.tokensChanged);
            METRICS.bytesChanged.set(c.hash, qm.bytesChanged);
            METRICS.hunks.set(c.hash, qm.hunks);
          }
          if (i > 0 && !METRICS.lev.has(c.hash)) {
            const d = await levenshteinForPatchLocal(patch);
            METRICS.lev.set(c.hash, d);
          }
          progressCb?.({
            stage: "metrics",
            done: i + 1,
            total,
            haveLev: METRICS.lev.size,
            message: "Computing per-commit metrics",
          });
          if (i % 4 === 0) {
            await new Promise((r) => setTimeout(r, 0));
            if (i % 12 === 0) render();
          }
        }
      }

      async function computeAllMetrics() {
        if (COMPUTE_RUNNING) return;
        if (!DATASET.loaded) return;
        if (!ALL_COMMITS.length) return;

        COMPUTE_RUNNING = true;
        COMPUTE_ABORT_CONTROLLER?.abort();
        COMPUTE_ABORT_CONTROLLER = new AbortController();
        const prog = document.getElementById("computeProgress");
        const cancelBtn = document.getElementById("btnCancelCompute");
        if (prog) {
          prog.classList.remove("hidden");
          prog.className = "mt-2 text-xs font-semibold text-slate-700";
          prog.textContent = WORKER_STATE.ready
            ? "Worker compute in progress..."
            : "Computing metrics (main-thread fallback)...";
          prog.title = "";
        }
        if (cancelBtn) {
          cancelBtn.classList.remove("hidden");
          cancelBtn.disabled = false;
        }

        try {
          const updateProgressText = (p) => {
            if (prog) {
              const done = Number(p?.done || 0);
              const total = Number(p?.total || ALL_COMMITS.length);
              const haveLev = Number(p?.haveLev || METRICS.lev.size);
              prog.textContent = `Computed ${done}/${total} commits · Levenshtein ready ${haveLev}/${Math.max(0, total - 1)}`;
            }
          };

          if (WORKER_STATE.ready) {
            const payload = await workerRequest(
              "compute_all_metrics",
              { includeLev: true },
              {
                signal: COMPUTE_ABORT_CONTROLLER.signal,
                timeoutMs: 180000,
                onProgress: updateProgressText,
              },
            );
            applyMetricsPayload(payload);
          } else {
            await computeAllMetricsLocal(updateProgressText, COMPUTE_ABORT_CONTROLLER.signal);
          }
          if (prog) prog.textContent = "Done. Charts updated.";
        } catch (e) {
          if (e?.name === "AbortError") {
            if (prog) {
              prog.textContent = "Compute cancelled.";
              prog.title = "";
            }
          } else {
            if (prog) {
              prog.className = "mt-2 text-xs font-semibold text-rose-700";
              prog.textContent = `Compute failed: ${e?.message || e}`;
              prog.title = formatErr(e);
            }
            console.error("computeAllMetrics failed:", e);
          }
        } finally {
          COMPUTE_RUNNING = false;
          if (cancelBtn) {
            cancelBtn.disabled = true;
            cancelBtn.classList.add("hidden");
          }
          render();
        }
      }

      // -----------------------------------------------------------
      // Heat Stripe: Dock UI Rendering + Tooltip + Click-to-Jump
      // (bd-24q.13.2)
      // -----------------------------------------------------------

      let _heatStripeRafPending = false;

      function renderHeatStripe() {
        const canvas = document.getElementById("dockHeatStripe");
        if (!canvas || !ALL_COMMITS.length) return;

        const stripe = computeHeatStripe(ALL_COMMITS, {
          resolution: "commit",
          tzMode: "local",
          metric: "lines",
          bucketMode: STATE.bucketMode,
        });
        if (!stripe || !stripe.bins.length) return;

        const dpr = window.devicePixelRatio || 1;
        const w = Math.max(1, Math.floor(canvas.clientWidth * dpr));
        const h = Math.max(1, Math.floor(canvas.clientHeight * dpr));
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
        }
        const ctx = canvas.getContext("2d");
        if (!ctx) return;
        ctx.clearRect(0, 0, w, h);

        const binW = w / stripe.bins.length;
        const maxM = Math.max(1, stripe.maxMass);

        for (let i = 0; i < stripe.bins.length; i++) {
          const bin = stripe.bins[i];
          if (bin.empty) continue;
          const intensity = Math.sqrt(bin.totalMass / maxM);
          ctx.globalAlpha = 0.15 + 0.85 * intensity;
          ctx.fillStyle = bin.dominantColor;
          ctx.fillRect(i * binW, 0, Math.max(1, binW), h);
        }
        ctx.globalAlpha = 1;

        // Draw selected marker
        if (DOC.idx >= 0 && DOC.idx < stripe.bins.length) {
          const sx = DOC.idx * binW;
          ctx.strokeStyle = "rgba(2,6,23,0.7)";
          ctx.lineWidth = Math.max(1, dpr);
          ctx.strokeRect(sx + 0.5, 0.5, Math.max(1, binW - 1), h - 1);
        }
      }

      function _heatStripeBinFromEvent(e) {
        const canvas = document.getElementById("dockHeatStripe");
        if (!canvas || !ALL_COMMITS.length) return -1;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const stripe = computeHeatStripe(ALL_COMMITS, {
          resolution: "commit",
          tzMode: "local",
          metric: "lines",
          bucketMode: STATE.bucketMode,
        });
        if (!stripe || !stripe.bins.length) return -1;
        const binW = rect.width / stripe.bins.length;
        return clamp(Math.floor(x / binW), 0, stripe.bins.length - 1);
      }

      function _showHeatTooltip(e) {
        const idx = _heatStripeBinFromEvent(e);
        const tooltip = document.getElementById("dockHeatTooltip");
        if (!tooltip) return;
        if (idx < 0) { tooltip.classList.add("hidden"); return; }

        const stripe = computeHeatStripe(ALL_COMMITS, {
          resolution: "commit",
          tzMode: "local",
          metric: "lines",
          bucketMode: STATE.bucketMode,
        });
        if (!stripe) { tooltip.classList.add("hidden"); return; }
        const bin = stripe.bins[idx];
        if (!bin) { tooltip.classList.add("hidden"); return; }

        // Build tooltip content
        const lines = [];
        if (bin.empty) {
          lines.push("<em>No activity</em>");
        } else {
          const c = bin.repCommit;
          if (c) lines.push(`<strong>${escapeHtml(c.short)}</strong> ${escapeHtml(c.subject || "").slice(0, 50)}`);
          const b = bucketById(bin.dominant);
          lines.push(`<span style="color:${b.color}">\u25CF</span> ${escapeHtml(b.name)} (dominant)`);
          lines.push(`Mass: ${Math.round(bin.totalMass)} lines`);
          // Top 3 buckets
          const sorted = [...bin.perBucket.entries()].filter(([,v]) => v > 0).sort((a,b) => b[1] - a[1]).slice(0, 3);
          if (sorted.length > 1) {
            const details = sorted.map(([id, v]) => `${bucketById(id).name}: ${Math.round(v)}`).join(", ");
            lines.push(`<span style="color:#64748b">${details}</span>`);
          }
        }
        tooltip.innerHTML = lines.join("<br>");
        tooltip.classList.remove("hidden");

        // Position near cursor
        const rect = tooltip.getBoundingClientRect();
        const canvas = document.getElementById("dockHeatStripe");
        const cRect = canvas.getBoundingClientRect();
        let left = e.clientX - rect.width / 2;
        left = Math.max(4, Math.min(left, window.innerWidth - rect.width - 4));
        tooltip.style.left = left + "px";
        tooltip.style.top = (cRect.top - rect.height - 6) + "px";
      }

      function _hideHeatTooltip() {
        const tooltip = document.getElementById("dockHeatTooltip");
        if (tooltip) tooltip.classList.add("hidden");
      }

      function _heatStripeClick(e) {
        const idx = _heatStripeBinFromEvent(e);
        if (idx < 0) return;
        const stripe = computeHeatStripe(ALL_COMMITS, {
          resolution: "commit",
          tzMode: "local",
          metric: "lines",
          bucketMode: STATE.bucketMode,
        });
        if (!stripe) return;
        const bin = stripe.bins[idx];
        if (!bin || bin.repCommitIdx < 0) return;
        selectCommitIdx(bin.repCommitIdx);
      }

      // -----------------------------------------------------------
      // Mobile Story Mode (bd-24q.4.3)
      // -----------------------------------------------------------

      let _storyMobileIdx = 0;

      function openStoryMobile() {
        const sheet = document.getElementById("storyMobileSheet");
        const overlay = document.getElementById("storyMobileOverlay");
        if (sheet) { sheet.classList.remove("hidden"); requestAnimationFrame(() => sheet.classList.add("open")); }
        if (overlay) overlay.classList.remove("hidden");
        _storyMilestones = getMilestones().filter(m => m.commitIdx !== null);
        if (_storyMilestones.length && _storyMobileIdx >= _storyMilestones.length) _storyMobileIdx = 0;
        _renderStoryMobileCard();
      }

      function closeStoryMobile() {
        const sheet = document.getElementById("storyMobileSheet");
        const overlay = document.getElementById("storyMobileOverlay");
        if (sheet) { sheet.classList.remove("open"); setTimeout(() => sheet.classList.add("hidden"), 310); }
        if (overlay) overlay.classList.add("hidden");
      }

      function _renderStoryMobileCard() {
        const area = document.getElementById("storyMobileCardArea");
        const progress = document.getElementById("storyMobileProgress");
        if (!area) return;
        const m = _storyMilestones[_storyMobileIdx];
        if (!m) { area.innerHTML = '<div class="text-sm text-slate-400 italic text-center">No milestones</div>'; return; }
        const commit = ALL_COMMITS[m.commitIdx];
        const date = commit?.dateIso ? new Date(commit.dateIso).toLocaleDateString() : "";
        const md = window._mdSingleton || window.markdownit?.();
        const annotationHtml = md ? md.render(m.annotationMd || "") : escapeHtml(m.annotationMd || "");
        const metrics = commit ? `+${fmtInt(commit.add || 0)} -${fmtInt(commit.del || 0)} lines` : "";
        area.innerHTML = `<div class="text-center"><div class="text-xl font-bold text-slate-900">${escapeHtml(m.title)}</div><div class="mt-4 text-sm leading-relaxed text-slate-700 story-annotation text-left">${annotationHtml}</div><div class="mt-4 flex items-center justify-center gap-3 text-xs text-slate-400">${date ? `<span>${escapeHtml(date)}</span>` : ""}${metrics ? `<span class="mono">${escapeHtml(metrics)}</span>` : ""}</div><button class="mt-4 focus-ring rounded-2xl bg-blue-600 px-5 py-2.5 text-sm font-semibold text-white hover:bg-blue-700" id="storyMobileJump" type="button">Jump to this commit</button></div>`;
        document.getElementById("storyMobileJump")?.addEventListener("click", () => {
          selectCommitIdx(m.commitIdx);
          if (m.defaultTab) setDocTab(m.defaultTab);
          if (m.focusHeading) {
            requestAnimationFrame(() => {
              const docEl = document.getElementById("docRendered");
              const target = docEl?.querySelector("#" + CSS.escape(m.focusHeading));
              if (target) target.scrollIntoView({ behavior: "smooth", block: "start" });
            });
          }
          closeStoryMobile();
        });
        if (progress) progress.textContent = `${_storyMobileIdx + 1}/${_storyMilestones.length}`;
        // Update prev/next button states
        const prev = document.getElementById("storyMobilePrev");
        const next = document.getElementById("storyMobileNext");
        if (prev) prev.disabled = _storyMobileIdx <= 0;
        if (next) next.disabled = _storyMobileIdx >= _storyMilestones.length - 1;
      }

      function _storyMobilePrev() {
        if (_storyMobileIdx > 0) { _storyMobileIdx--; _renderStoryMobileCard(); }
      }
      function _storyMobileNext() {
        if (_storyMobileIdx < _storyMilestones.length - 1) { _storyMobileIdx++; _renderStoryMobileCard(); }
      }

      function _wireStoryMobile() {
        document.getElementById("btnStoryMobileTrigger")?.addEventListener("click", openStoryMobile);
        document.getElementById("btnStoryMobileClose")?.addEventListener("click", closeStoryMobile);
        document.getElementById("storyMobileOverlay")?.addEventListener("click", closeStoryMobile);
        document.getElementById("storyMobilePrev")?.addEventListener("click", _storyMobilePrev);
        document.getElementById("storyMobileNext")?.addEventListener("click", _storyMobileNext);
        // Story autoplay toggle for mobile (bd-24q.4.4).
        document.getElementById("storyMobileAutoplay")?.addEventListener("click", () => {
          if (STORY_AUTOPLAY.enabled && STORY_AUTOPLAY.pausedAtMilestone) storyAutoplayResume();
          else if (STORY_AUTOPLAY.enabled) storyAutoplayStop();
          else storyAutoplayStart();
        });
        // Swipe gesture support
        let _touchStartX = 0;
        const area = document.getElementById("storyMobileCardArea");
        if (area) {
          area.addEventListener("touchstart", (e) => { _touchStartX = e.touches[0]?.clientX || 0; }, { passive: true });
          area.addEventListener("touchend", (e) => {
            const dx = (e.changedTouches[0]?.clientX || 0) - _touchStartX;
            if (Math.abs(dx) > 60) {
              if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;
              if (dx > 0) _storyMobilePrev(); else _storyMobileNext();
            }
          });
        }
      }

      // -----------------------------------------------------------
      // Mobile Mini-Map Sheet (bd-24q.2.3)
      // -----------------------------------------------------------

      function openMiniMapMobile() {
        const sheet = document.getElementById("miniMapMobileSheet");
        const overlay = document.getElementById("miniMapMobileOverlay");
        if (sheet) { sheet.classList.remove("hidden"); requestAnimationFrame(() => sheet.classList.add("open")); }
        if (overlay) overlay.classList.remove("hidden");
        void updateMiniMapMobileList();
      }

      function closeMiniMapMobile() {
        const sheet = document.getElementById("miniMapMobileSheet");
        const overlay = document.getElementById("miniMapMobileOverlay");
        if (sheet) { sheet.classList.remove("open"); setTimeout(() => sheet.classList.add("hidden"), 260); }
        if (overlay) overlay.classList.add("hidden");
      }

      async function updateMiniMapMobileList() {
        const list = document.getElementById("miniMapMobileList");
        if (!list) return;
        const outline = await getOutline(DOC.idx);
        const metrics = DOC.idx > 0 ? await getHeadingMetrics(DOC.idx) : new Map();
        const filter = (document.getElementById("miniMapMobileSearch")?.value || "").trim().toLowerCase();
        const items = [];
        for (const entry of outline) {
          if (filter && !entry.text.toLowerCase().includes(filter)) continue;
          const m = metrics.get(entry.id) || { addLines: 0, delLines: 0, tokensAdded: 0, tokensDeleted: 0 };
          const total = m.addLines + m.delLines;
          const color = total === 0 ? "bg-slate-50 text-slate-600" : total > 20 ? "bg-red-50 text-red-700" : total > 5 ? "bg-amber-50 text-amber-700" : "bg-emerald-50 text-emerald-700";
          const indent = Math.max(0, entry.level - 1) * 10;
          const badge = total > 0 ? `<span class="ml-auto shrink-0 rounded-full px-1.5 py-0.5 text-[10px] font-bold ${color}">+${m.addLines} -${m.delLines}</span>` : "";
          items.push(`<button class="w-full text-left flex items-center gap-2 rounded-xl px-3 py-2.5 min-h-[44px] ${color} hover:brightness-95 active:brightness-90 transition-colors" data-heading-id="${escapeHtml(entry.id)}" style="padding-left:${indent + 12}px"><span class="truncate text-sm font-medium">${escapeHtml(entry.text)}</span>${badge}</button>`);
        }
        list.innerHTML = items.length ? items.join("") : '<div class="text-xs text-slate-400 italic p-3">No headings found</div>';
        list.querySelectorAll("button[data-heading-id]").forEach(btn => {
          btn.addEventListener("click", () => {
            const hid = btn.dataset.headingId;
            if (DOC.tab !== "spec") setDocTab("spec");
            setTimeout(() => {
              const docEl = document.getElementById("docRendered");
              if (docEl) {
                const target = docEl.querySelector("#" + CSS.escape(hid));
                if (target) {
                  target.scrollIntoView({ behavior: "smooth", block: "start" });
                  target.classList.remove("section-highlight");
                  void target.offsetWidth;
                  target.classList.add("section-highlight");
                }
              }
            }, 200);
            const stayOpen = document.getElementById("miniMapMobileStayOpen")?.checked;
            if (!stayOpen) closeMiniMapMobile();
          });
        });
      }

      function _wireMiniMapMobile() {
        document.getElementById("btnMiniMapMobile")?.addEventListener("click", openMiniMapMobile);
        document.getElementById("btnMiniMapMobileClose")?.addEventListener("click", closeMiniMapMobile);
        document.getElementById("miniMapMobileOverlay")?.addEventListener("click", closeMiniMapMobile);
        let searchTimer = 0;
        document.getElementById("miniMapMobileSearch")?.addEventListener("input", () => {
          clearTimeout(searchTimer);
          searchTimer = setTimeout(() => void updateMiniMapMobileList(), 150);
        });
      }

      function _wireHeatStripe() {
        const canvas = document.getElementById("dockHeatStripe");
        if (!canvas) return;

        canvas.addEventListener("mousemove", _showHeatTooltip);
        canvas.addEventListener("mouseleave", _hideHeatTooltip);
        canvas.addEventListener("click", _heatStripeClick);

        // Mobile: tap-hold for tooltip, single tap for jump
        let _touchTimer = 0;
        let _touchMoved = false;
        canvas.addEventListener("touchstart", (e) => {
          _touchMoved = false;
          _touchTimer = setTimeout(() => {
            if (!_touchMoved && e.touches.length === 1) {
              const touch = e.touches[0];
              _showHeatTooltip({ clientX: touch.clientX, clientY: touch.clientY });
            }
          }, 400);
        }, { passive: true });
        canvas.addEventListener("touchmove", () => { _touchMoved = true; }, { passive: true });
        canvas.addEventListener("touchend", (e) => {
          clearTimeout(_touchTimer);
          if (!_touchMoved && e.changedTouches.length === 1) {
            const touch = e.changedTouches[0];
            _heatStripeClick({ clientX: touch.clientX, clientY: touch.clientY });
          }
          setTimeout(_hideHeatTooltip, 1500);
        });
      }

      function syncDockAndDoc() {
        if (!ALL_COMMITS.length) return;
        DOC.idx = clamp(DOC.idx, 0, ALL_COMMITS.length - 1);
        initDockIfNeeded();
        drawDock();
        renderHeatStripe();
        void updateDocUI();
      }

      // --- Phase 4: Bucket toggle DOM caching ---
      let BUCKET_TOGGLES_BUILT = false;
      const BUCKET_TOGGLE_INDICATORS = new Map(); // bucketId -> [desktopSpan, mobileSpan]

      function renderBucketToggles() {
        const wrap = document.getElementById("bucketToggles");
        const wrapM = document.getElementById("bucketTogglesMobile");

        if (!BUCKET_TOGGLES_BUILT) {
          wrap.innerHTML = "";
          wrapM.innerHTML = "";
          for (const b of BUCKETS) {
            const item = bucketToggleItem(b);
            const itemM = bucketToggleItem(b, true);
            wrap.appendChild(item);
            wrapM.appendChild(itemM);
            const ind = item.querySelector("[data-toggle-ind]");
            const indM = itemM.querySelector("[data-toggle-ind]");
            BUCKET_TOGGLE_INDICATORS.set(b.id, [ind, indM]);
          }
          BUCKET_TOGGLES_BUILT = true;
        }

        // Update only the toggle indicator styles
        for (const b of BUCKETS) {
          const on = STATE.bucketEnabled.has(b.id);
          const indicators = BUCKET_TOGGLE_INDICATORS.get(b.id);
          if (!indicators) continue;
          for (const ind of indicators) {
            if (!ind) continue;
            ind.style.background = on ? b.color : "#cbd5e1";
            ind.style.transform = on ? "translateX(16px)" : "translateX(0)";
          }
        }
      }

      function bucketToggleItem(bucket, isMobile = false) {
        const id = (isMobile ? "m-" : "") + `b-${bucket.id}`;

        const btn = document.createElement("button");
        btn.type = "button";
        btn.id = id;
        btn.className =
          "focus-ring flex items-start gap-3 rounded-2xl border border-slate-900/10 bg-white/70 px-3 py-2 text-left hover:bg-white";
        btn.innerHTML = `
          <span class="mt-1 inline-block h-2.5 w-2.5 rounded-full" style="background:${bucket.color}"></span>
          <span class="min-w-0">
            <span class="block text-xs font-semibold text-slate-900">${escapeHtml(bucket.name)}</span>
            <span class="mt-0.5 block text-[11px] leading-snug text-slate-500">${escapeHtml(bucket.desc)}</span>
          </span>
          <span class="ml-auto mt-0.5 inline-flex h-6 w-10 items-center rounded-full border border-slate-900/10 bg-white/60 p-0.5">
            <span data-toggle-ind class="h-5 w-5 rounded-full transition"></span>
          </span>
        `;
        btn.addEventListener("click", () => {
          if (STATE.bucketEnabled.has(bucket.id)) {
            STATE.bucketEnabled.delete(bucket.id);
          } else {
            STATE.bucketEnabled.add(bucket.id);
          }
          render();
          syncUrlToState();
        });
        return btn;
      }

      // -----------------------------------------------------------
      // Wall-Clock Series Builder (bd-24q.12.1)
      // Builds a dense bin array with explicit empty bins so quiet
      // periods are visible. Supports UTC and local timezone modes.
      // -----------------------------------------------------------

      function wallClockBinKey(t, resolution) {
        const fmt2 = (n) => String(n).padStart(2, "0");
        if (resolution === "day") return t.format("YYYY-MM-DD");
        if (resolution === "hour") return t.format("YYYY-MM-DD HH:00");
        if (resolution === "15m") {
          const m = Math.floor(t.minute() / 15) * 15;
          return `${t.format("YYYY-MM-DD HH")}:${fmt2(m)}`;
        }
        if (resolution === "5m") {
          const m = Math.floor(t.minute() / 5) * 5;
          return `${t.format("YYYY-MM-DD HH")}:${fmt2(m)}`;
        }
        return t.format("YYYY-MM-DD HH:mm");
      }

      function wallClockBinMinutes(resolution) {
        if (resolution === "day") return 1440;
        if (resolution === "hour") return 60;
        if (resolution === "15m") return 15;
        if (resolution === "5m") return 5;
        return 1;
      }

      function wallClockFloor(t, resolution) {
        if (resolution === "day") return t.startOf("day");
        if (resolution === "hour") return t.startOf("hour");
        if (resolution === "15m") {
          const m = Math.floor(t.minute() / 15) * 15;
          return t.startOf("hour").add(m, "minute");
        }
        if (resolution === "5m") {
          const m = Math.floor(t.minute() / 5) * 5;
          return t.startOf("hour").add(m, "minute");
        }
        return t.startOf("minute");
      }

      function buildWallClockBins(commits, resolution, tzMode) {
        if (!commits.length || resolution === "commit") return null;

        const toT = (c) => (tzMode === "utc" && dayjs.utc) ? dayjs.utc(c.dateIso) : dayjs(c.dateIso);
        // Use calendar-aware units for day/hour to handle DST correctly in local tz.
        const stepUnit = resolution === "day" ? "day" : resolution === "hour" ? "hour" : "minute";
        const stepAmount = (stepUnit === "minute") ? wallClockBinMinutes(resolution) : 1;

        let minT = toT(commits[0]);
        let maxT = toT(commits[0]);
        for (const c of commits) {
          const t = toT(c);
          if (t.isBefore(minT)) minT = t;
          if (t.isAfter(maxT)) maxT = t;
        }

        const startBin = wallClockFloor(minT, resolution);
        const endBin = wallClockFloor(maxT, resolution);

        const labels = [];
        const binsMap = new Map();
        let cursor = startBin;
        const maxBins = 10000;
        let count = 0;
        while (!cursor.isAfter(endBin) && count < maxBins) {
          const key = wallClockBinKey(cursor, resolution);
          labels.push(key);
          binsMap.set(key, { key, label: key, start: cursor, commits: [] });
          cursor = cursor.add(stepAmount, stepUnit);
          count++;
        }

        for (const c of commits) {
          const t = toT(c);
          const key = wallClockBinKey(wallClockFloor(t, resolution), resolution);
          const bin = binsMap.get(key);
          if (bin) bin.commits.push(c);
        }

        return { labels, bins: labels.map((k) => binsMap.get(k)) };
      }

      function aggregateBinMetric(binCommits, metricFn, mode) {
        if (!binCommits.length) return 0;
        const vals = binCommits.map(metricFn);
        const sum = vals.reduce((a, b) => a + b, 0);
        if (mode === "sum") return sum;
        if (mode === "mean") return sum / vals.length;
        if (mode === "median") {
          const sorted = vals.slice().sort((a, b) => a - b);
          const mid = Math.floor(sorted.length / 2);
          return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        }
        return sum;
      }


      // -----------------------------------------------------------
      // Heat Stripe: Compute Density + Dominant Bucket per Bin
      // (bd-24q.13.1)
      //
      // For each bin, computes:
      //   - totalMass: aggregate change mass (lines/tokens/lev/groups)
      //   - perBucket: Map<bucketId, mass> contributions
      //   - dominant: bucket id with highest contribution
      //     (tie-break: highest mass, then lowest bucket id)
      //   - repCommit: the commit with largest individual delta in bin
      //   - repCommitIdx: its index in ALL_COMMITS
      //
      // Cached by dataset hash + bucketMode + resolution + tzMode + metric.
      // -----------------------------------------------------------

      const _heatStripeCache = new Map();

      function computeHeatStripe(commits, { resolution = "commit", tzMode = "local", metric = "lines", bucketMode = "primary" } = {}) {
        // Cache key
        const cacheKey = `${WORKER_STATE.datasetHash}|${bucketMode}|${resolution}|${tzMode}|${metric}`;
        const cached = _heatStripeCache.get(cacheKey);
        if (cached) return cached;

        // Build bins (reuse wall-clock builder or commit-mode)
        let binLabels = [];
        let binCommitArrays = [];

        if (resolution === "commit") {
          const binIdx = new Map();
          for (const c of commits) {
            const k = c.short;
            let j = binIdx.get(k);
            if (j === undefined) {
              j = binLabels.length;
              binIdx.set(k, j);
              binLabels.push(k);
              binCommitArrays.push([]);
            }
            binCommitArrays[j].push(c);
          }
        } else {
          const wc = buildWallClockBins(commits, resolution, tzMode);
          if (wc) {
            binLabels = wc.labels;
            binCommitArrays = wc.bins.map((b) => b.commits);
          }
        }

        // Metric extractor for a single commit
        const metricVal = (c) => {
          if (metric === "groups") return 1;
          if (metric === "lines") return Number(c.impact || 0);
          if (metric === "tokens") return Number(METRICS.tokensChanged.get(c.hash) || 0);
          if (metric === "lev") return Number(METRICS.lev.get(c.hash) || 0);
          return 0;
        };

        // ALL_COMMITS hash->idx lookup for repCommitIdx
        const hashToIdx = new Map();
        for (let i = 0; i < ALL_COMMITS.length; i++) {
          hashToIdx.set(ALL_COMMITS[i].hash, i);
        }

        const bins = [];

        for (let bi = 0; bi < binLabels.length; bi++) {
          const bc = binCommitArrays[bi];
          const perBucket = new Map();
          for (const b of BUCKETS) perBucket.set(b.id, 0);

          let totalMass = 0;

          for (const c of bc) {
            if (metric === "groups") {
              // Count group contributions per bucket
              if (bucketMode === "primary") {
                for (const g of c.changeGroups) {
                  perBucket.set(g.primary, (perBucket.get(g.primary) || 0) + 1);
                  totalMass += 1;
                }
              } else {
                for (const g of c.changeGroups) {
                  for (const lb of g.labels) {
                    perBucket.set(lb, (perBucket.get(lb) || 0) + 1);
                    totalMass += 1;
                  }
                }
              }
            } else {
              const v = metricVal(c);
              const groups = c.changeGroups.length || 1;
              const perGroup = v / groups;

              if (bucketMode === "primary") {
                for (const g of c.changeGroups) {
                  perBucket.set(g.primary, (perBucket.get(g.primary) || 0) + perGroup);
                }
              } else {
                for (const g of c.changeGroups) {
                  const labels = g.labels?.length ? g.labels : [10];
                  const perLabel = perGroup / labels.length;
                  for (const lb of labels) {
                    perBucket.set(lb, (perBucket.get(lb) || 0) + perLabel);
                  }
                }
              }
              totalMass += v;
            }
          }

          // Dominant bucket: highest contribution, tie-break lowest id
          let dominant = BUCKETS[BUCKETS.length - 1].id; // default: Other
          let maxContrib = 0;
          for (const b of BUCKETS) {
            const contrib = perBucket.get(b.id) || 0;
            if (contrib > maxContrib || (contrib === maxContrib && b.id < dominant)) {
              maxContrib = contrib;
              dominant = b.id;
            }
          }

          // Representative commit: highest individual metric value in bin
          let repCommit = null;
          let repCommitIdx = -1;
          let repVal = -1;
          for (const c of bc) {
            const v = metricVal(c);
            if (v > repVal) {
              repVal = v;
              repCommit = c;
              repCommitIdx = hashToIdx.get(c.hash) ?? -1;
            }
          }

          bins.push({
            label: binLabels[bi],
            totalMass,
            perBucket,
            dominant,
            dominantColor: (bucketById(dominant) || {}).color || "#94a3b8",
            repCommit,
            repCommitIdx,
            empty: bc.length === 0,
          });
        }

        // Compute global max for normalization
        let maxMass = 0;
        for (const b of bins) {
          if (b.totalMass > maxMass) maxMass = b.totalMass;
        }

        const result = { bins, maxMass, binCount: bins.length, cacheKey };
        _heatStripeCache.set(cacheKey, result);
        return result;
      }

      function renderCharts(commits) {
        const resSel = document.getElementById("stackResolution");
        const metricSel = document.getElementById("stackMetric");
        const tzSel = document.getElementById("stackTimezone");
        const resolution = resSel?.value || "commit";
        const metric = metricSel?.value || "groups";
        const tzMode = tzSel?.value || "local";

        const commitsHash = commits.length + "|" + (commits[0]?.hash || "") + "|" + (commits[commits.length - 1]?.hash || "") + "|" + resolution + "|" + metric + "|" + tzMode + "|" + STATE.bucketMode;
        if (_lastChartsCommitsHash === commitsHash) return;
        _lastChartsCommitsHash = commitsHash;

        // Timeline scatter
        if (!chartTimeline) chartTimeline = echarts.init(document.getElementById("timelineChart"));
        if (!chartStack) chartStack = echarts.init(document.getElementById("stackChart"));
        if (!chartDonut) chartDonut = echarts.init(document.getElementById("donutChart"));
        if (!chartBocpd) chartBocpd = echarts.init(document.getElementById("bocpdChart"));

        const timelineData = commits.map((c) => {
          return [
            c.dateIso,
            c.impact,
            c.primary,
            c.short,
            c.subject,
            c.hash,
            c.author,
          ];
        });

        chartTimeline.setOption({
          grid: { left: 44, right: 18, top: 18, bottom: 40 },
          tooltip: {
            trigger: "item",
            borderWidth: 1,
            backgroundColor: "rgba(255,255,255,0.95)",
            textStyle: { color: "#0b1220" },
            extraCssText: "box-shadow: 0 16px 40px rgba(2,6,23,0.18); border-radius: 14px;",
            formatter: (p) => {
              const d = p.data;
              const b = bucketById(d[2]);
              return `
                <div style="min-width: 240px">
                  <div style="display:flex;align-items:center;gap:10px;">
                    <span style="width:10px;height:10px;border-radius:99px;background:${b.color};display:inline-block;"></span>
                    <div style="font-weight:700">${escapeHtml(d[3])}</div>
                    <div style="margin-left:auto;font-size:11px;color:rgba(2,6,23,.62)">${dayjs(d[0]).format(
                      "YYYY-MM-DD HH:mm:ss",
                    )}</div>
                  </div>
                  <div style="margin-top:6px;font-size:12px;color:rgba(2,6,23,.8)">${escapeHtml(d[4])}</div>
                  <div style="margin-top:6px;font-size:11px;color:rgba(2,6,23,.62)">Impact ${fmtInt(
                    d[1],
                  )} lines · Bucket ${escapeHtml(b.name)}</div>
                </div>
              `;
            },
          },
          xAxis: {
            type: "time",
            name: "time",
            nameTextStyle: { color: "rgba(2,6,23,.55)" },
            axisLabel: { color: "rgba(2,6,23,.55)" },
            axisLine: { lineStyle: { color: "rgba(2,6,23,.12)" } },
            splitLine: { lineStyle: { color: "rgba(2,6,23,.06)" } },
          },
          yAxis: {
            type: "value",
            name: "lines changed",
            nameTextStyle: { color: "rgba(2,6,23,.55)" },
            axisLabel: { color: "rgba(2,6,23,.55)" },
            axisLine: { lineStyle: { color: "rgba(2,6,23,.12)" } },
            splitLine: { lineStyle: { color: "rgba(2,6,23,.06)" } },
          },
          series: [
            {
              type: "scatter",
              data: timelineData,
              symbolSize: (d) => clamp(6 + Math.sqrt(d[1] || 0) * 0.7, 6, 40),
              itemStyle: {
                color: (p) => bucketById(p.data[2]).color,
                opacity: 0.9,
              },
              emphasis: { scale: true },
            },
          ],
        }, { lazyUpdate: true });

        chartTimeline.off("click");
        chartTimeline.on("click", (p) => {
          const hash = p.data[5];
          const idx = ALL_COMMITS.findIndex((c) => c.hash === hash);
          if (idx >= 0) selectCommitIdx(idx);
          const el = document.getElementById(`commit-${hash}`);
          if (el) {
            el.scrollIntoView({ behavior: "smooth", block: "start" });
            el.open = true;
          }
        });

        // Stacked buckets by time bin (commit/day/hour/15m/5m)
        // Uses dense wall-clock bins for time-based resolutions so
        // empty periods are visible in the chart (bd-24q.12.1).
        let binLabels = [];
        let binCommits = [];

        if (resolution === "commit") {
          // Commit mode: one bin per commit (no empty bins).
          const binIdx = new Map();
          for (const c of commits) {
            const k = c.short;
            let j = binIdx.get(k);
            if (j === undefined) {
              j = binLabels.length;
              binIdx.set(k, j);
              binLabels.push(k);
              binCommits.push([]);
            }
            binCommits[j].push(c);
          }
        } else {
          // Wall-clock mode: dense bins with empties filled.
          const wc = buildWallClockBins(commits, resolution, tzMode);
          if (wc) {
            binLabels = wc.labels;
            binCommits = wc.bins.map((b) => b.commits);
          }
        }

        const valuesByBucket = new Map(BUCKETS.map((b) => [b.id, new Array(binLabels.length).fill(0)]));

        const metricForCommit = (c) => {
          if (metric === "groups") return 1; // handled per-group
          if (metric === "lines") return Number(c.impact || 0);
          if (metric === "tokens") return Number(METRICS.tokensChanged.get(c.hash) || 0);
          if (metric === "lev") return Number(METRICS.lev.get(c.hash) || 0);
          return 0;
        };

        for (let bi = 0; bi < binCommits.length; bi++) {
          for (const c of binCommits[bi]) {
            if (metric === "groups") {
              if (STATE.bucketMode === "primary") {
                for (const g of c.changeGroups) {
                  const a = valuesByBucket.get(g.primary);
                  if (a) a[bi] += 1;
                }
              } else {
                for (const g of c.changeGroups) {
                  for (const b of g.labels) {
                    const a = valuesByBucket.get(b);
                    if (a) a[bi] += 1;
                  }
                }
              }
              continue;
            }

            const v = metricForCommit(c);
            const groups = c.changeGroups.length || 1;
            const perGroup = v / groups;

            if (STATE.bucketMode === "primary") {
              for (const g of c.changeGroups) {
                const a = valuesByBucket.get(g.primary);
                if (a) a[bi] += perGroup;
              }
            } else {
              for (const g of c.changeGroups) {
                const labels = g.labels?.length ? g.labels : [10];
                const perLabel = perGroup / labels.length;
                for (const b of labels) {
                  const a = valuesByBucket.get(b);
                  if (a) a[bi] += perLabel;
                }
              }
            }
          }
        }

        chartStack.setOption({
          grid: { left: 44, right: 18, top: 18, bottom: 60 },
          tooltip: {
            trigger: "axis",
            formatter: (params) => {
              if (!params?.length) return "";
              const label = params[0].axisValue + (tzMode === "utc" && resolution !== "commit" ? " UTC" : "");
              const total = params.reduce((s, p) => s + (Number(p.value) || 0), 0);
              const lines = params
                .filter((p) => p.value > 0)
                .map((p) => `${p.marker} ${escapeHtml(p.seriesName)}: ${Number(p.value).toFixed(metric === "groups" ? 0 : 1)}`)
                .join("<br>");
              return `<div style="font-weight:700;margin-bottom:4px">${escapeHtml(label)}</div>${lines || "<span style='color:#94a3b8'>No activity</span>"}${total > 0 ? `<div style="margin-top:4px;font-size:11px;color:rgba(2,6,23,.55)">Total: ${total.toFixed(metric === "groups" ? 0 : 1)}</div>` : ""}`;
            },
          },
          xAxis: {
            type: "category",
            data: binLabels,
            axisLabel: {
              color: "rgba(2,6,23,.55)",
              rotate: resolution === "commit" ? 45 : (resolution === "day" ? 0 : 45),
              interval: "auto",
            },
            axisLine: { lineStyle: { color: "rgba(2,6,23,.12)" } },
          },
          yAxis: {
            type: "value",
            axisLabel: { color: "rgba(2,6,23,.55)" },
            splitLine: { lineStyle: { color: "rgba(2,6,23,.06)" } },
          },
          legend: {
            type: "scroll",
            bottom: 0,
            textStyle: { color: "rgba(2,6,23,.62)" },
          },
          series: BUCKETS.map((b) => {
            return {
              name: `${b.id}. ${b.name}`,
              type: "bar",
              stack: "b",
              barWidth: "60%",
              emphasis: { focus: "series" },
              itemStyle: { color: b.color, opacity: 0.9 },
              data: valuesByBucket.get(b.id),
            };
          }),
        }, { lazyUpdate: true });

        // Donut distribution by (primary or multi)
        const totals = new Map(BUCKETS.map((b) => [b.id, 0]));
        if (STATE.bucketMode === "primary") {
          for (const c of commits) {
            for (const g of c.changeGroups) {
              totals.set(g.primary, (totals.get(g.primary) || 0) + 1);
            }
          }
        } else {
          for (const c of commits) {
            for (const g of c.changeGroups) {
              for (const b of g.labels) totals.set(b, (totals.get(b) || 0) + 1);
            }
          }
        }
        const donutData = BUCKETS.map((b) => ({ name: `${b.id}. ${b.name}`, value: totals.get(b.id) || 0, itemStyle: { color: b.color } }));

        chartDonut.setOption({
          tooltip: { trigger: "item" },
          series: [
            {
              type: "pie",
              radius: ["45%", "70%"],
              avoidLabelOverlap: true,
              itemStyle: { borderRadius: 10, borderColor: "rgba(255,255,255,0.8)", borderWidth: 2 },
              label: { show: false },
              emphasis: { label: { show: true, fontWeight: 700, formatter: "{b}\\n{c}" } },
              labelLine: { show: false },
              data: donutData,
            },
          ],
        }, { lazyUpdate: true });

        renderBocpd(commits);
        void maybeRefreshPhaseAndOutliers(commits);
      }

      // -----------------------------------------------------------
      // Phase Map: Overlay Rendering + Interactions (bd-24q.11.2)
      // -----------------------------------------------------------
      const PHASE_COLORS = [
        "rgba(59,130,246,0.06)","rgba(168,85,247,0.06)","rgba(34,197,94,0.06)",
        "rgba(249,115,22,0.06)","rgba(236,72,153,0.06)","rgba(20,184,166,0.06)",
      ];
      let PHASE_FILTER = { segIdx: -1 };

      function renderPhaseOverlay(commits) {
        if (!chartTimeline || !commits.length) return;
        const phase = WORKER_DERIVED.phase;
        if (!phase || !phase.segments || !phase.segments.length) return;
        const areas = phase.segments.map((seg, i) => {
          const c0 = commits[seg.start]; const c1 = commits[seg.end] || commits[commits.length - 1];
          if (!c0 || !c1) return null;
          return [{ xAxis: c0.dateIso, itemStyle: { color: PHASE_COLORS[i % PHASE_COLORS.length], opacity: PHASE_FILTER.segIdx === i ? 0.18 : 0.06 } }, { xAxis: c1.dateIso }];
        }).filter(Boolean);
        chartTimeline.setOption({ series: [{ markArea: { silent: false, data: areas, tooltip: { formatter: (p) => {
          const seg = WORKER_DERIVED.phase?.segments?.[p.dataIndex];
          if (!seg) return "";
          return `<div style="min-width:160px"><div style="font-weight:700">Phase ${p.dataIndex + 1}</div><div style="font-size:11px">Duration: ${seg.length} commits</div><div style="font-size:11px">Mean: ${seg.mean.toFixed(2)}, σ: ${seg.stddev.toFixed(2)}</div><div style="font-size:11px">Confidence: ${(seg.confidence * 100).toFixed(0)}%</div></div>`;
        } } } }] }, false);
        if (chartBocpd) {
          const ba = phase.segments.map((seg, i) => [{ xAxis: seg.start, itemStyle: { color: PHASE_COLORS[i % PHASE_COLORS.length], opacity: PHASE_FILTER.segIdx === i ? 0.18 : 0.06 } }, { xAxis: seg.end }]);
          chartBocpd.setOption({ series: [{ markArea: { silent: true, data: ba } }, {}] }, false);
        }
      }

      // -----------------------------------------------------------
      // Outlier Dashboard UI (bd-24q.10.2)
      // -----------------------------------------------------------
      let _outlierComputeSeq = 0;
      async function renderOutlierPanel(commits) {
        if (!commits || !commits.length) return;
        const list = document.getElementById("outlierList");
        const empty = document.getElementById("outlierEmpty");
        const loading = document.getElementById("outlierLoading");
        if (!list) return;
        const metric = document.getElementById("outlierMetricSel")?.value || "impact";
        const topK = Number(document.getElementById("outlierTopKSel")?.value || 10);
        if (loading) loading.classList.remove("hidden");
        if (empty) empty.classList.add("hidden");
        list.innerHTML = "";
        const seq = ++_outlierComputeSeq;
        try {
          const result = await computeMultiMetricOutliers(commits, topK);
          if (seq !== _outlierComputeSeq) return;
          const data = result?.[metric];
          if (!data || !data.top || !data.top.length) { if (loading) loading.classList.add("hidden"); if (empty) empty.classList.remove("hidden"); return; }
          const maxZ = Math.max(1, ...data.top.map(o => Math.abs(o.z)));
          list.innerHTML = data.top.map((o, rank) => {
            const c = ALL_COMMITS.find(cm => cm.hash === o.hash);
            const b = c ? bucketById(c.primary) : { color: "#94a3b8", name: "?" };
            const zAbs = Math.abs(o.z).toFixed(2);
            const barW = Math.round((Math.abs(o.z) / maxZ) * 100);
            const zColor = Math.abs(o.z) > 3 ? "#dc2626" : Math.abs(o.z) > 2 ? "#d97706" : "#059669";
            return `<div class="flex items-center gap-3 rounded-2xl px-3 py-2 cursor-pointer hover:bg-slate-50/80 transition-colors border border-slate-100" data-outlier-hash="${escapeHtml(o.hash)}"><div class="shrink-0 w-6 text-center text-[10px] font-bold text-slate-400">#${rank+1}</div><div class="shrink-0 w-2 h-2 rounded-full" style="background:${b.color}"></div><div class="min-w-0 flex-1"><div class="flex items-baseline gap-2"><span class="mono text-xs font-semibold text-slate-800">${escapeHtml((o.hash||"").slice(0,7))}</span><span class="truncate text-[11px] text-slate-600 max-w-[200px]">${escapeHtml((c?.subject||"").slice(0,60))}</span></div><div class="mt-0.5 text-[10px] text-slate-400">${o.ts ? dayjs(o.ts).format("YYYY-MM-DD HH:mm") : ""} <span style="color:${b.color}">${escapeHtml(b.name)}</span></div></div><div class="shrink-0 text-right"><div class="text-xs font-bold text-slate-800">${fmtInt(Math.round(o.value))}</div><div class="mt-0.5 flex items-center gap-1"><span class="inline-block h-1.5 rounded-full bg-slate-200" style="width:40px"><span class="inline-block h-1.5 rounded-full" style="width:${barW}%;background:${zColor}"></span></span><span class="text-[10px] mono font-semibold" style="color:${zColor}">z=${zAbs}</span></div></div></div>`;
          }).join("");
          if (loading) loading.classList.add("hidden");
          list.querySelectorAll("[data-outlier-hash]").forEach(el => {
            el.addEventListener("click", () => {
              const idx = ALL_COMMITS.findIndex(c => c.hash === el.dataset.outlierHash);
              if (idx >= 0) selectCommitIdx(idx);
            });
          });
          // Annotate timeline chart
          if (chartTimeline) {
            const mpData = data.top.slice(0, 10).map(o => {
              const c = commits.find(cm => cm.hash === o.hash);
              if (!c) return null;
              return { coord: [c.dateIso, Number(c.impact || 0)], value: Math.abs(o.z).toFixed(1), symbol: "diamond", symbolSize: 8, itemStyle: { color: "rgba(220,38,38,0.8)", borderColor: "#fff", borderWidth: 1 }, label: { show: false } };
            }).filter(Boolean);
            chartTimeline.setOption({ series: [{ markPoint: { data: mpData } }] }, false);
          }
        } catch (e) { if (loading) loading.classList.add("hidden"); console.error("Outlier render:", e); }
      }
      function _wireOutlierPanel() {
        const refresh = () => { if (ALL_COMMITS.length) void renderOutlierPanel(ALL_COMMITS); };
        document.getElementById("outlierMetricSel")?.addEventListener("change", refresh);
        document.getElementById("outlierTopKSel")?.addEventListener("change", refresh);
      }


      // --- Cluster Explorer (bd-24q.14.3) ---
      let _selectedClusterId = null;
      let _selectedClusterMembers = [];
      let _clusterNavIdx = -1;

      async function renderClusterPanel() {
        const panel = document.getElementById("clusterPanel");
        if (!panel) return;
        const list = document.getElementById("clusterList");
        const empty = document.getElementById("clusterEmpty");
        const loading = document.getElementById("clusterLoading");
        if (!list) return;

        const threshold = parseFloat(document.getElementById("clusterThresholdSel")?.value || "0.3");
        const limit = parseInt(document.getElementById("clusterLimitSel")?.value || "10", 10);

        if (loading) { loading.classList.remove("hidden"); }
        if (empty) { empty.classList.add("hidden"); }
        list.innerHTML = "";

        try {
          const res = await workerRequest("compute_clusters", { limit, threshold }, { timeoutMs: 30000 });
          if (loading) loading.classList.add("hidden");
          const clusters = res.clusters || [];
          if (!clusters.length) {
            if (empty) empty.classList.remove("hidden");
            return;
          }

          list.innerHTML = clusters.map((c) => {
            const isSelected = c.id === _selectedClusterId;
            const medoidCommit = ALL_COMMITS[c.medoid] || {};
            const tagsHtml = c.tags.map(t => `<span class="inline-block rounded-full bg-indigo-100 text-indigo-700 px-2 py-0.5 text-[10px] font-medium">${t}</span>`).join(" ");
            return `<div class="cluster-item cursor-pointer rounded-2xl border p-3 transition-all ${isSelected ? "border-indigo-400 bg-indigo-50/80 ring-2 ring-indigo-300" : "border-slate-900/10 bg-white/60 hover:bg-white/80"}" data-cluster-id="${c.id}">` +
              `<div class="flex items-start justify-between gap-2">` +
              `<div class="flex-1 min-w-0">` +
              `<div class="flex items-center gap-2 flex-wrap">${tagsHtml}<span class="text-[10px] text-slate-400">${c.size} commits</span></div>` +
              `<div class="mt-1 text-xs text-slate-600 truncate">Medoid: #${c.medoid} ${medoidCommit.short || ""} \u2014 ${medoidCommit.subject || ""}</div>` +
              `</div>` +
              `<span class="shrink-0 text-xs font-bold ${isSelected ? "text-indigo-600" : "text-slate-400"}">${isSelected ? "\u2713" : ""}</span>` +
              `</div></div>`;
          }).join("");
        } catch (e) {
          if (loading) loading.classList.add("hidden");
          list.innerHTML = '<div class="text-xs text-red-500 p-2">Error computing clusters.</div>';
        }
      }

      function selectCluster(clusterId) {
        if (_selectedClusterId === clusterId) {
          _selectedClusterId = null;
          _selectedClusterMembers = [];
          _clusterNavIdx = -1;
        } else {
          _selectedClusterId = clusterId;
          // Find cluster data from last render.
          _selectedClusterMembers = [];
          const items = document.querySelectorAll("#clusterList .cluster-item");
          items.forEach(el => {
            if (el.dataset.clusterId === clusterId) el.classList.add("border-indigo-400", "bg-indigo-50/80", "ring-2", "ring-indigo-300");
            else el.classList.remove("border-indigo-400", "bg-indigo-50/80", "ring-2", "ring-indigo-300");
          });
        }

        // Re-render to update selected state + fetch member data.
        void renderClusterPanel().then(() => {
          updateClusterNav();
          highlightClusterOnTimeline();
        });
      }

      function updateClusterNav() {
        const nav = document.getElementById("clusterNav");
        const label = document.getElementById("clusterNavLabel");
        if (!nav) return;

        if (!_selectedClusterId || !_selectedClusterMembers.length) {
          nav.classList.add("hidden");
          return;
        }
        nav.classList.remove("hidden");
        _clusterNavIdx = Math.max(0, Math.min(_clusterNavIdx, _selectedClusterMembers.length - 1));
        if (label) label.textContent = `${_clusterNavIdx + 1} / ${_selectedClusterMembers.length}`;
      }

      function clusterNavigate(delta) {
        if (!_selectedClusterMembers.length) return;
        _clusterNavIdx = Math.max(0, Math.min(_selectedClusterMembers.length - 1, _clusterNavIdx + delta));
        const commitIdx = _selectedClusterMembers[_clusterNavIdx];
        if (typeof commitIdx === "number") selectCommitIdx(commitIdx);
        updateClusterNav();
      }

      function highlightClusterOnTimeline() {
        // Clear previous highlights.
        document.querySelectorAll(".timeline-cluster-highlight").forEach(el => el.classList.remove("timeline-cluster-highlight"));
        if (!_selectedClusterId || !_selectedClusterMembers.length) return;
        // Add highlight class to member commit items in the commit list.
        const memberSet = new Set(_selectedClusterMembers);
        document.querySelectorAll("#commitList [data-idx]").forEach(el => {
          const idx = parseInt(el.dataset.idx, 10);
          if (memberSet.has(idx)) el.classList.add("timeline-cluster-highlight");
        });
      }

      function _wireClusterPanel() {
        const refresh = () => { if (ALL_COMMITS.length) void renderClusterPanel(); };
        document.getElementById("clusterThresholdSel")?.addEventListener("change", refresh);
        document.getElementById("clusterLimitSel")?.addEventListener("change", refresh);

        document.getElementById("clusterList")?.addEventListener("click", async (e) => {
          const item = e.target.closest(".cluster-item");
          if (!item) return;
          const cid = item.dataset.clusterId;
          if (!cid) return;
          // Fetch fresh cluster data to get member list.
          const threshold = parseFloat(document.getElementById("clusterThresholdSel")?.value || "0.3");
          const limit = parseInt(document.getElementById("clusterLimitSel")?.value || "10", 10);
          try {
            const res = await workerRequest("compute_clusters", { limit, threshold }, { timeoutMs: 30000 });
            const cluster = (res.clusters || []).find(c => c.id === cid);
            if (cluster) {
              _selectedClusterMembers = cluster.items.map(it => it.idx);
              _clusterNavIdx = 0;
            }
          } catch { /* ignore */ }
          selectCluster(cid);
        });

        document.getElementById("clusterPrev")?.addEventListener("click", () => clusterNavigate(-1));
        document.getElementById("clusterNext")?.addEventListener("click", () => clusterNavigate(1));
      }

      function renderBocpd(commits) {
        const H = Number(document.getElementById("hazard").value);
        document.getElementById("hazardLabel").textContent = H.toFixed(2);

        const xs = commits.map((c) => c.idx);
        const ys = commits.map((c) => Math.log1p(c.impact));

        const cp = WORKER_DERIVED.phase && WORKER_DERIVED.phaseKey === `${H}|${ys.join(",")}`
          ? WORKER_DERIVED.phase
          : bocpdChangePoints(ys, H);
        const markers = cp.changePoints.map((idx) => ({
          xAxis: xs[idx],
          label: { formatter: "CP", color: "rgba(2,6,23,.75)", fontSize: 10 },
          lineStyle: { color: "rgba(2,6,23,.25)", width: 1, type: "dashed" },
        }));

        chartBocpd.setOption({
          grid: { left: 44, right: 18, top: 18, bottom: 40 },
          tooltip: { trigger: "axis" },
          xAxis: {
            type: "value",
            name: "commit index",
            nameTextStyle: { color: "rgba(2,6,23,.55)" },
            axisLabel: { color: "rgba(2,6,23,.55)" },
            splitLine: { lineStyle: { color: "rgba(2,6,23,.06)" } },
          },
          yAxis: {
            type: "value",
            name: "log(1+impact)",
            nameTextStyle: { color: "rgba(2,6,23,.55)" },
            axisLabel: { color: "rgba(2,6,23,.55)" },
            splitLine: { lineStyle: { color: "rgba(2,6,23,.06)" } },
          },
          series: [
            {
              type: "line",
              data: xs.map((x, i) => [x, ys[i]]),
              showSymbol: false,
              lineStyle: { width: 2, color: "rgba(2,6,23,.78)" },
              markLine: {
                symbol: "none",
                data: markers,
              },
            },
            {
              type: "line",
              data: xs.map((x, i) => [x, cp.p0[i]]),
              yAxisIndex: 0,
              showSymbol: false,
              lineStyle: { width: 2, color: "rgba(37,99,235,.55)" },
            },
          ],
        });
      }

      // Minimal BOCPD over a scalar series with a crude Normal-Gamma model.
      // This is an interpretive visualization only.
      function bocpdChangePoints(y, hazard) {
        // Prior
        let mu0 = 0.0;
        let kappa0 = 0.01;
        let alpha0 = 0.5;
        let beta0 = 0.5;

        // Run-length posterior (log-space)
        let logR = [0.0]; // P(r=0)=1 at t=0
        // Sufficient stats per run length: n, mean, M2
        let stats = [{ n: 0, mean: 0.0, m2: 0.0 }];

        const p0 = [];
        const changePoints = [];

        const logHaz = Math.log(hazard);
        const log1mHaz = Math.log(1.0 - hazard);

        for (let t = 0; t < y.length; t++) {
          const x = y[t];

          // Predictive probabilities for each run length
          const logPred = [];
          for (let r = 0; r < stats.length; r++) {
            const st = stats[r];
            // Conjugate predictive approx: Student-t-ish with parameters from Normal-Gamma.
            const n = st.n;
            const mean = st.mean;
            const kappa = kappa0 + n;
            const alpha = alpha0 + n / 2;
            const beta =
              beta0 +
              0.5 * st.m2 +
              (kappa0 * n * (mean - mu0) * (mean - mu0)) / (2 * (kappa0 + n));

            const dof = 2 * alpha;
            const scale2 = (beta * (kappa + 1)) / (alpha * kappa);
            const logp = studentTLogPdf(x, mean, Math.sqrt(scale2), dof);
            logPred.push(logp);
          }

          // Growth + change point
          const newLogR = new Array(stats.length + 1).fill(-Infinity);

          // r_t = 0
          let logSumCp = -Infinity;
          for (let r = 0; r < logR.length; r++) {
            logSumCp = logAddExp(logSumCp, logR[r] + logPred[r] + logHaz);
          }
          newLogR[0] = logSumCp;

          // r_t = r_{t-1}+1
          for (let r = 0; r < logR.length; r++) {
            newLogR[r + 1] = logR[r] + logPred[r] + log1mHaz;
          }

          // Normalize
          const logZ = newLogR.reduce((a, b) => logAddExp(a, b), -Infinity);
          for (let i = 0; i < newLogR.length; i++) newLogR[i] -= logZ;

          // Record P(r_t=0)
          const p_r0 = Math.exp(newLogR[0]);
          p0.push(p_r0);
          if (p_r0 > 0.5) changePoints.push(t);

          // Update stats for next step
          const newStats = new Array(stats.length + 1);
          // For r=0, reset stats
          newStats[0] = { n: 1, mean: x, m2: 0.0 };
          for (let r = 1; r < newStats.length; r++) {
            newStats[r] = updateWelford(stats[r - 1], x);
          }

          // Prune (keep top K run lengths)
          const K = 120;
          const idxs = newLogR.map((v, i) => [v, i]).sort((a, b) => b[0] - a[0]).slice(0, K).map((x) => x[1]).sort((a,b)=>a-b);
          logR = idxs.map((i) => newLogR[i]);
          stats = idxs.map((i) => newStats[i]);

          // Renormalize after pruning
          const logZ2 = logR.reduce((a, b) => logAddExp(a, b), -Infinity);
          logR = logR.map((v) => v - logZ2);
        }

        return { p0, changePoints };
      }

      function updateWelford(st, x) {
        const n1 = st.n + 1;
        const delta = x - st.mean;
        const mean1 = st.mean + delta / n1;
        const delta2 = x - mean1;
        const m21 = st.m2 + delta * delta2;
        return { n: n1, mean: mean1, m2: m21 };
      }

      function logAddExp(a, b) {
        if (a === -Infinity) return b;
        if (b === -Infinity) return a;
        const m = Math.max(a, b);
        return m + Math.log(Math.exp(a - m) + Math.exp(b - m));
      }

      function studentTLogPdf(x, mu, sigma, nu) {
        // log Γ((ν+1)/2) - log(σ*sqrt(νπ)) - log Γ(ν/2) - (ν+1)/2 log(1 + ((x-μ)/σ)^2 / ν)
        const z = (x - mu) / (sigma || 1e-9);
        return (
          logGamma((nu + 1) / 2) -
          logGamma(nu / 2) -
          Math.log((sigma || 1e-9) * Math.sqrt(nu * Math.PI)) -
          ((nu + 1) / 2) * Math.log(1 + (z * z) / nu)
        );
      }

      // Lanczos approximation for log-gamma
      function logGamma(z) {
        const p = [
          0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313,
          -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6,
          1.5056327351493116e-7,
        ];
        if (z < 0.5) {
          return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - logGamma(1 - z);
        }
        z -= 1;
        let x = p[0];
        for (let i = 1; i < p.length; i++) x += p[i] / (z + i);
        const t = z + 7.5;
        return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x);
      }

      // --- Phase 5: Virtualized commit list + lazy detail loading ---
      // Only render a window of COMMIT_PAGE_SIZE commits at a time.
      // Change group details are injected on first <details> open (lazy).
      const COMMIT_PAGE_SIZE = 20;
      const COMMIT_LIST_NODES = new Map(); // hash -> details element
      let COMMIT_LIST_MODE = null;
      let _clFilteredCommits = []; // current filtered list for progressive load
      let _clRenderedCount = 0;    // how many we've appended so far
      let _clObserver = null;      // IntersectionObserver for sentinel
      const COMMIT_DETAIL_LOADED = new Set(); // hashes with detail content populated

      function buildCommitNode(c) {
        const details = document.createElement("details");
        details.id = `commit-${c.hash}`;
        details.className = "glass-2 rounded-3xl px-4 py-3 shadow-sm";
        details.dataset.hash = c.hash;

        const tags = (STATE.bucketMode === "primary" ? [c.primary] : c.labels).map(bucketById);

        // Render only the summary; detail content is lazy-loaded on first open
        details.innerHTML = `
          <summary class="cursor-pointer list-none">
            <div class="flex flex-col gap-3 sm:flex-row sm:items-start sm:justify-between">
              <div class="min-w-0">
                <div class="flex flex-wrap items-center gap-2">
                  <span class="mono text-xs font-semibold text-slate-600">${escapeHtml(c.short)}</span>
                  <span class="mono text-xs text-slate-500">${dayjs(c.dateIso).format("HH:mm:ss")}</span>
                  <span class="mono text-xs text-slate-500">+${fmtInt(c.add)} -${fmtInt(c.del)}</span>
                </div>
                <div class="mt-1 truncate text-sm font-semibold text-slate-900">${escapeHtml(c.subject)}</div>
                <div class="mt-1 flex flex-wrap gap-1.5">
                  ${tags
                    .map(
                      (t) => `
                        <span class="chip inline-flex items-center gap-2 rounded-full px-2.5 py-1 text-[11px] font-semibold text-slate-700">
                          <span class="inline-block h-2 w-2 rounded-full" style="background:${t.color}"></span>
                          ${escapeHtml(`${t.id}. ${t.name}`)}
                        </span>`,
                    )
                    .join("")}
                </div>
              </div>
              <div class="shrink-0">
                <a class="focus-ring chip inline-flex items-center gap-2 rounded-2xl px-3 py-2 text-xs font-semibold text-slate-700 hover:bg-white"
                   href="${escapeHtml(c.url)}" target="_blank" rel="noreferrer">View commit</a>
              </div>
            </div>
          </summary>
          <div class="commit-detail-placeholder"></div>
        `;

        details.addEventListener("toggle", () => {
          if (details.open) {
            selectCommitIdx(c.idx);
            // Lazy-load change group detail on first open
            if (!COMMIT_DETAIL_LOADED.has(c.hash)) {
              COMMIT_DETAIL_LOADED.add(c.hash);
              const ph = details.querySelector(".commit-detail-placeholder");
              if (ph) {
                ph.className = "mt-3 border-t border-slate-900/10 pt-3";
                ph.innerHTML =
                  (c.hasClassification ? "" : `<div class="text-xs text-red-700">Missing classification entry for this commit.</div>`) +
                  c.changeGroups.map((g, i) => renderGroup(g, i)).join("");
              }
            }
          }
        });

        return details;
      }

      function ensureCommitNodes() {
        if (COMMIT_LIST_MODE === STATE.bucketMode) return;
        COMMIT_LIST_NODES.clear();
        COMMIT_LIST_MODE = STATE.bucketMode;
        COMMIT_DETAIL_LOADED.clear();
      }

      // Append the next page of commits to the DOM
      function _clAppendPage() {
        const wrap = document.getElementById("commitList");
        if (!wrap) return;
        const end = Math.min(_clRenderedCount + COMMIT_PAGE_SIZE, _clFilteredCommits.length);
        if (_clRenderedCount >= end) return;
        const frag = document.createDocumentFragment();
        for (let i = _clRenderedCount; i < end; i++) {
          const c = _clFilteredCommits[i];
          let node = COMMIT_LIST_NODES.get(c.hash);
          if (!node) {
            node = buildCommitNode(c);
            COMMIT_LIST_NODES.set(c.hash, node);
          }
          frag.appendChild(node);
        }
        const sentinel = document.getElementById("commitListSentinel");
        if (sentinel) wrap.insertBefore(frag, sentinel);
        else wrap.appendChild(frag);
        _clRenderedCount = end;
        if (sentinel && _clRenderedCount >= _clFilteredCommits.length) {
          sentinel.style.display = "none";
        }
      }

      function _clSetupObserver() {
        if (_clObserver) _clObserver.disconnect();
        const sentinel = document.getElementById("commitListSentinel");
        if (!sentinel) return;
        _clObserver = new IntersectionObserver(
          (entries) => {
            if (entries[0].isIntersecting && _clRenderedCount < _clFilteredCommits.length) {
              _clAppendPage();
            }
          },
          { rootMargin: "400px" }
        );
        _clObserver.observe(sentinel);
      }

      function renderCommitList(filteredCommits) {
        const wrap = document.getElementById("commitList");
        if (!wrap) return;

        const commitsHash = filteredCommits.length + "|" + (filteredCommits[0]?.hash || "") + "|" + (filteredCommits[filteredCommits.length - 1]?.hash || "");
        if (_lastCommitListCommitsHash === commitsHash && _lastCommitListBucketMode === STATE.bucketMode) return;
        _lastCommitListCommitsHash = commitsHash;
        _lastCommitListBucketMode = STATE.bucketMode;

        ensureCommitNodes();

        _clFilteredCommits = filteredCommits;
        _clRenderedCount = 0;

        // Clear and rebuild with sentinel
        wrap.innerHTML = "";
        wrap.dataset.mode = STATE.bucketMode;

        let sentinel = document.createElement("div");
        sentinel.id = "commitListSentinel";
        sentinel.style.height = "1px";
        wrap.appendChild(sentinel);

        // Render first page
        _clAppendPage();
        // Set up observer for subsequent pages
        _clSetupObserver();
      }

      function renderGroup(g, i) {
        const chips = g.labels.map((id) => bucketById(id));
        const confPct = Math.round(clamp(g.confidence, 0, 1) * 100);
        const headings = (g.changed_headings || []).slice(0, 8);
        const evidence = (g.evidence || []).slice(0, 3);

        return `
          <div class="mt-3 rounded-3xl border border-slate-900/10 bg-white/60 p-4">
            <div class="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between">
              <div class="min-w-0">
                <div class="text-xs font-semibold text-slate-500">Change group ${i + 1}</div>
                <div class="mt-1 text-sm font-semibold text-slate-900">${escapeHtml(g.summary || "")}</div>
                <div class="mt-2 flex flex-wrap gap-1.5">
                  ${chips
                    .map(
                      (c) => `
                        <span class="chip inline-flex items-center gap-2 rounded-full px-2.5 py-1 text-[11px] font-semibold text-slate-700">
                          <span class="inline-block h-2 w-2 rounded-full" style="background:${c.color}"></span>
                          ${escapeHtml(`${c.id}. ${c.name}`)}
                        </span>`,
                    )
                    .join("")}
                  <span class="chip inline-flex items-center rounded-full px-2.5 py-1 text-[11px] font-semibold text-slate-700">
                    Confidence <span class="mono ml-1">${confPct}%</span>
                  </span>
                </div>
              </div>
            </div>

            ${
              headings.length
                ? `
                  <div class="mt-3">
                    <div class="text-[11px] font-semibold text-slate-500">Touched headings</div>
                    <div class="mt-2 flex flex-wrap gap-1.5">
                      ${headings
                        .map(
                          (h) => `<span class="chip mono rounded-full px-2.5 py-1 text-[11px] text-slate-700">${escapeHtml(h)}</span>`,
                        )
                        .join("")}
                    </div>
                  </div>
                `
                : ""
            }

            ${
              evidence.length
                ? `
                  <div class="mt-3">
                    <div class="text-[11px] font-semibold text-slate-500">Diff excerpts</div>
                    <div class="mt-2 grid grid-cols-1 gap-2">
                      ${evidence
                        .map(
                          (e) => `
                            <pre class="codebox overflow-auto rounded-2xl p-3"><code class="language-diff">${escapeHtml(
                              String(e),
                            )}</code></pre>
                          `,
                        )
                        .join("")}
                    </div>
                  </div>
                `
                : ""
            }
          </div>
        `;
      }

      // -----------------------------
      // Navigation helpers
      // -----------------------------

      function scrollToSection(id) {
        const el = document.getElementById(id);
        if (!el) return;
        el.scrollIntoView({ behavior: "smooth", block: "start" });
      }

      // -----------------------------
      // UI wiring
      // -----------------------------

      function wireUI() {
        const q = document.getElementById("q");
        const impact = document.getElementById("impact");
        const impactLabel = document.getElementById("impactLabel");
        const qMobile = document.getElementById("qMobile");
        const impactMobile = document.getElementById("impactMobile");
        const impactLabelMobile = document.getElementById("impactLabelMobile");

        const setImpact = (v, skipRender) => {
          STATE.minImpact = Number(v);
          impact.value = String(v);
          impactMobile.value = String(v);
          impactLabel.textContent = `${fmtInt(v)} lines`;
          impactLabelMobile.textContent = `${fmtInt(v)} lines`;
          if (!skipRender) render();
        };
        setImpact(STATE.minImpact, true);

        const debouncedRenderSearch = debounce(() => { render(); syncUrlToState(); }, 150);
        const debouncedRenderSlider = debounce(() => { render(); syncUrlToState(); }, 50);

        q.addEventListener("input", () => {
          STATE.q = q.value;
          qMobile.value = q.value;
          debouncedRenderSearch();
        });
        qMobile.addEventListener("input", () => {
          STATE.q = qMobile.value;
          q.value = qMobile.value;
          debouncedRenderSearch();
        });

        impact.addEventListener("input", () => {
          STATE.minImpact = Number(impact.value);
          impactMobile.value = impact.value;
          impactLabel.textContent = `${fmtInt(impact.value)} lines`;
          impactLabelMobile.textContent = `${fmtInt(impact.value)} lines`;
          debouncedRenderSlider();
        });
        impactMobile.addEventListener("input", () => {
          STATE.minImpact = Number(impactMobile.value);
          impact.value = impactMobile.value;
          impactLabel.textContent = `${fmtInt(impactMobile.value)} lines`;
          impactLabelMobile.textContent = `${fmtInt(impactMobile.value)} lines`;
          debouncedRenderSlider();
        });

        const setMode = (m) => {
          STATE.bucketMode = m;
          document.getElementById("bucketModeLabel").textContent = m;
          document.getElementById("modePrimary").className =
            "focus-ring rounded-2xl border border-slate-900/10 px-3 py-2 text-xs font-semibold " +
            (m === "primary" ? "bg-slate-900 text-white" : "bg-white/70 text-slate-900");
          document.getElementById("modeMulti").className =
            "focus-ring rounded-2xl border border-slate-900/10 px-3 py-2 text-xs font-semibold " +
            (m === "multi" ? "bg-slate-900 text-white" : "bg-white/70 text-slate-900");
          document.getElementById("modePrimaryMobile").className =
            "focus-ring rounded-2xl border border-slate-900/10 px-3 py-2 text-xs font-semibold " +
            (m === "primary" ? "bg-slate-900 text-white" : "bg-white/70 text-slate-900");
          document.getElementById("modeMultiMobile").className =
            "focus-ring rounded-2xl border border-slate-900/10 px-3 py-2 text-xs font-semibold " +
            (m === "multi" ? "bg-slate-900 text-white" : "bg-white/70 text-slate-900");
          render();
          syncUrlToState();
        };

        document.getElementById("modePrimary").addEventListener("click", () => setMode("primary"));
        document.getElementById("modeMulti").addEventListener("click", () => setMode("multi"));
        document.getElementById("modePrimaryMobile").addEventListener("click", () => setMode("primary"));
        document.getElementById("modeMultiMobile").addEventListener("click", () => setMode("multi"));

        document.getElementById("btnReset").addEventListener("click", () => { resetFilters(); syncUrlToState(); });
        document.getElementById("btnResetMobile").addEventListener("click", () => { resetFilters(); syncUrlToState(); });

        // Section buttons
        document.getElementById("viewTimeline").addEventListener("click", () => scrollToSection("sectionTimeline"));
        document.getElementById("viewCommits").addEventListener("click", () => scrollToSection("sectionCommits"));
        document.getElementById("viewAlien").addEventListener("click", () => scrollToSection("sectionAlien"));

        // BOCPD hazard slider
        document.getElementById("hazard").addEventListener("input", debounce(() => render(), 50));

        // Stack chart controls
        document.getElementById("stackResolution")?.addEventListener("change", () => { render(); syncUrlToState(); });
        document.getElementById("stackMetric")?.addEventListener("change", () => { render(); syncUrlToState(); });
        document.getElementById("stackTimezone")?.addEventListener("change", () => { render(); syncUrlToState(); });

        // Doc tabs + toggles
        document.getElementById("docTabSpec")?.addEventListener("click", () => setDocTab("spec"));
        document.getElementById("docTabDiff")?.addEventListener("click", () => setDocTab("diff"));
        document.getElementById("docTabMetrics")?.addEventListener("click", () => setDocTab("metrics"));
        document.getElementById("docTabSections")?.addEventListener("click", () => setDocTab("sections"));

        document.getElementById("btnCopyLink")?.addEventListener("click", () => copyPermalink());
        document.getElementById("btnShareHelp")?.addEventListener("click", () => toggleShareHelp());
        // Close share help popover on outside click.
        document.addEventListener("click", (e) => {
          const pop = document.getElementById("shareHelpPopover");
          const btn = document.getElementById("btnShareHelp");
          if (pop && !pop.classList.contains("hidden") && !pop.contains(e.target) && e.target !== btn) {
            pop.classList.add("hidden");
          }
        });

        document.getElementById("btnRawToggle")?.addEventListener("click", () => {
          DOC.rawSpec = !DOC.rawSpec;
          syncUrlToState();
          void updateDocUI();
        });

        // Story mode toggle + navigation (bd-24q.4.2).
        document.getElementById("btnStoryToggle")?.addEventListener("click", () => {
          const rail = document.getElementById("storyRail");
          if (rail) {
            const show = rail.classList.toggle("hidden");
            const btn = document.getElementById("btnStoryToggle");
            if (btn) {
              btn.classList.toggle("bg-slate-900", !show);
              btn.classList.toggle("text-white", !show);
              btn.classList.toggle("bg-white/70", show);
              btn.classList.toggle("text-slate-900", show);
            }
            if (!show) renderStoryCards();
          }
        });
        document.getElementById("storyPrev")?.addEventListener("click", () => storyPrev());
        document.getElementById("storyNext")?.addEventListener("click", () => storyNext());
        // Story autoplay toggle (bd-24q.4.4).
        document.getElementById("storyAutoplayBtn")?.addEventListener("click", () => {
          if (STORY_AUTOPLAY.enabled && STORY_AUTOPLAY.pausedAtMilestone) storyAutoplayResume();
          else if (STORY_AUTOPLAY.enabled) storyAutoplayStop();
          else storyAutoplayStart();
        });

        document.getElementById("btnMiniMapToggle")?.addEventListener("click", () => {
          const mm = document.getElementById("miniMap");
          if (mm) {
            const show = mm.classList.toggle("hidden");
            const btn = document.getElementById("btnMiniMapToggle");
            if (btn) {
              btn.classList.toggle("bg-slate-900", !show);
              btn.classList.toggle("text-white", !show);
              btn.classList.toggle("bg-white/70", show);
              btn.classList.toggle("text-slate-900", show);
            }
            if (!show) void updateMiniMap();
          }
        });

        // Mini-map search filter with debounce (bd-24q.2.2).
        {
          let searchTimer = 0;
          document.getElementById("miniMapSearch")?.addEventListener("input", () => {
            clearTimeout(searchTimer);
            searchTimer = setTimeout(() => void updateMiniMap(), 150);
          });
        }

        // --- Inline highlights controls (bd-24q.16.2) ---
        document.getElementById("btnIHToggle")?.addEventListener("click", toggleInlineHighlights);
        document.getElementById("btnIHNext")?.addEventListener("click", () => ihNavigate("next"));
        document.getElementById("btnIHPrev")?.addEventListener("click", () => ihNavigate("prev"));
        document.addEventListener("keydown", (e) => {
          if (!DOC.inlineHighlights) return;
          if (e.altKey && e.key === "ArrowDown") { e.preventDefault(); ihNavigate("next"); }
          if (e.altKey && e.key === "ArrowUp") { e.preventDefault(); ihNavigate("prev"); }
        });
        if (DOC.inlineHighlights) {
          const btn = document.getElementById("btnIHToggle");
          const nav = document.getElementById("ihNav");
          if (btn) { btn.classList.add("bg-slate-900", "text-white"); }
          if (nav) nav.style.display = "flex";
        }

        document.getElementById("btnPrettyDiff")?.addEventListener("click", () => {
          DOC.diffMode = "pretty";
          syncUrlToState();
          void updateDocUI();
        });
        document.getElementById("btnRawDiff")?.addEventListener("click", () => {
          DOC.diffMode = "raw";
          syncUrlToState();
          void updateDocUI();
        });

        // --- A/B Compare event listeners (bd-24q.1: typeahead pickers) ---
        document.getElementById("btnCompareToggle")?.addEventListener("click", () => {
          DOC.compareMode = !DOC.compareMode;
          const btn = document.getElementById("btnCompareToggle");
          const bar = document.getElementById("abCompareBar");
          const layoutBtn = document.getElementById("btnDiffLayout");
          if (btn) { btn.classList.toggle("bg-slate-900", DOC.compareMode); btn.classList.toggle("text-white", DOC.compareMode); btn.classList.toggle("bg-white/70", !DOC.compareMode); btn.classList.toggle("text-slate-900", !DOC.compareMode); }
          if (bar) bar.classList.toggle("hidden", !DOC.compareMode);
          if (layoutBtn) layoutBtn.classList.toggle("hidden", !DOC.compareMode);
          const sbsBtn = document.getElementById("btnSbsRendered");
          if (sbsBtn) sbsBtn.classList.toggle("hidden", !DOC.compareMode);
          if (!DOC.compareMode) { DOC.abViewMode = "diff"; _sbsRenderedKey = ""; }
          if (DOC.compareMode) { DOC.compareFromIdx = Math.max(0, DOC.idx - 1); DOC.compareToIdx = DOC.idx; populateCompareSelects(); }
          syncUrlToState();
          void updateDocUI();
        });
        document.getElementById("btnDiffLayout")?.addEventListener("click", () => {
          DOC.diffLayout = DOC.diffLayout === "side-by-side" ? "line-by-line" : "side-by-side";
          DOC.abViewMode = "diff"; // switching diff layout exits rendered mode
          const btn = document.getElementById("btnDiffLayout");
          if (btn) btn.textContent = DOC.diffLayout === "side-by-side" ? "Side-by-Side" : "Unified";
          updateSbsButtonStyles();
          syncUrlToState(); void updateDocUI();
        });
        // Side-by-side rendered markdown toggle (bd-24q.15.1).
        document.getElementById("btnSbsRendered")?.addEventListener("click", () => {
          DOC.abViewMode = DOC.abViewMode === "rendered" ? "diff" : "rendered";
          updateSbsButtonStyles();
          syncUrlToState(); void updateDocUI();
        });
        // Sync scroll toggle for side-by-side panes (bd-24q.15.1).
        document.getElementById("btnSbsSyncScroll")?.addEventListener("click", () => {
          DOC.sbsSyncScroll = !DOC.sbsSyncScroll;
          const btn = document.getElementById("btnSbsSyncScroll");
          if (btn) btn.innerHTML = DOC.sbsSyncScroll ? "Sync &#x2714;" : "Sync";
          if (DOC.sbsSyncScroll) setupSbsSyncScroll();
          else if (_sbsScrollCleanup) { _sbsScrollCleanup(); _sbsScrollCleanup = null; }
        });
        // Copy permalink for side-by-side rendered view (bd-24q.15.1).
        document.getElementById("btnSbsCopyLink")?.addEventListener("click", () => {
          const qs = encodeUrlState();
          const url = qs ? `${location.origin}${location.pathname}?${qs}` : `${location.origin}${location.pathname}`;
          const done = () => { const b = document.getElementById("btnSbsCopyLink"); if (b) { b.textContent = "Copied!"; setTimeout(() => { b.textContent = "Copy Link"; }, 1500); } };
          if (navigator.clipboard?.writeText) { navigator.clipboard.writeText(url).then(done, () => { fallbackCopy(url); done(); }); }
          else { fallbackCopy(url); done(); }
        });
        // Mobile pane tabs (bd-24q.15.3).
        document.getElementById("sbsTabA")?.addEventListener("click", () => switchSbsMobilePane("a"));
        document.getElementById("sbsTabB")?.addEventListener("click", () => switchSbsMobilePane("b"));
        document.getElementById("btnSwapAB")?.addEventListener("click", () => {
          const tmp = DOC.compareFromIdx; DOC.compareFromIdx = DOC.compareToIdx; DOC.compareToIdx = tmp;
          populateCompareSelects(); syncUrlToState(); void updateDocUI();
        });
        // Reset A/B to current commit (bd-24q.1).
        document.getElementById("btnResetAB")?.addEventListener("click", () => {
          DOC.compareFromIdx = Math.max(0, DOC.idx - 1);
          DOC.compareToIdx = DOC.idx;
          populateCompareSelects(); syncUrlToState(); void updateDocUI();
        });
        // Typeahead picker buttons open their dropdowns (bd-24q.1).
        document.getElementById("pickerABtn")?.addEventListener("click", (e) => { e.stopPropagation(); openPicker("pickerA"); });
        document.getElementById("pickerBBtn")?.addEventListener("click", (e) => { e.stopPropagation(); openPicker("pickerB"); });
        wirePickerSearch("pickerA");
        wirePickerSearch("pickerB");
        // Close picker dropdowns on outside click.
        document.addEventListener("click", (e) => {
          for (const id of ["pickerA", "pickerB"]) {
            const picker = document.getElementById(id);
            const dropdown = document.getElementById(id + "Dropdown");
            if (picker && dropdown && !dropdown.classList.contains("hidden") && !picker.contains(e.target)) {
              closePicker(id);
            }
          }
        });

        document.getElementById("btnComputeAll")?.addEventListener("click", () => {
          void computeAllMetrics();
        });
        document.getElementById("btnCancelCompute")?.addEventListener("click", () => {
          COMPUTE_ABORT_CONTROLLER?.abort();
        });

        // Galaxy brain button: jump to alien section
        document.getElementById("btnGalaxy").addEventListener("click", () => scrollToSection("sectionAlien"));

        // Dock collapse toggle (mobile)
        const dockBody = document.getElementById("dockBody");
        const dockToggle = document.getElementById("dockCollapseToggle");
        if (dockToggle && dockBody) {
          dockToggle.addEventListener("click", () => {
            const hidden = dockBody.classList.toggle("hidden");
            dockToggle.textContent = hidden ? "\u25BC" : "\u25B2";
            if (!hidden) drawDock(); // redraw canvas after un-collapsing
          });
        }

        // Dock controls
        document.getElementById("dockPrev")?.addEventListener("click", () => selectCommitIdx(DOC.idx - 1));
        document.getElementById("dockNext")?.addEventListener("click", () => selectCommitIdx(DOC.idx + 1));
        document.getElementById("dockSlider")?.addEventListener("input", (e) => {
          playbackOnManualScrub();
          const v = Number(e?.target?.value || 0);
          selectCommitIdx(v);
        });
        document.getElementById("dockSlider")?.addEventListener("change", () => {
          playbackOnScrubEnd();
        });

        // Playback controls (bd-24q.7.2).
        document.getElementById("dockPlayPause")?.addEventListener("click", () => playbackToggle());
        document.getElementById("dockSpeed")?.addEventListener("change", (e) => {
          playbackSetSpeed(Number(e.target.value));
          _syncPlaybackUI();
        });
        document.getElementById("dockLoop")?.addEventListener("click", () => {
          playbackSetLoop(!PLAYBACK.loop);
          _syncPlaybackUI();
        });

        document.addEventListener("keydown", (e) => {
          // Cmd/Ctrl+K: open search palette (works from anywhere, bd-24q.9.2).
          if ((e.metaKey || e.ctrlKey) && e.key === "k") {
            e.preventDefault();
            if (_spOpen) closeSearchPalette(); else openSearchPalette();
            return;
          }

          const t = e.target;
          const isTyping =
            t && (t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.tagName === "SELECT" || t.isContentEditable);
          if (isTyping) return;

          if (e.key === "ArrowLeft") {
            e.preventDefault();
            selectCommitIdx(DOC.idx - 1);
          }
          if (e.key === "ArrowRight") {
            e.preventDefault();
            selectCommitIdx(DOC.idx + 1);
          }
          // Playback keyboard shortcuts (bd-24q.7.2).
          if (e.key === " " || e.code === "Space") {
            e.preventDefault();
            playbackToggle();
          }
        });

        // Mobile sheet
        const overlay = document.getElementById("overlay");
        const sheet = document.getElementById("sheet");
        const openSheet = () => {
          overlay.classList.remove("hidden");
          sheet.classList.remove("hidden");
          requestAnimationFrame(() => sheet.classList.add("open"));
        };
        const closeSheet = () => {
          sheet.classList.remove("open");
          setTimeout(() => {
            overlay.classList.add("hidden");
            sheet.classList.add("hidden");
          }, 200);
        };

        document.getElementById("btnFilters").addEventListener("click", openSheet);
        overlay.addEventListener("click", closeSheet);
        document.getElementById("btnCloseSheet").addEventListener("click", closeSheet);
        document.getElementById("btnApplyMobile").addEventListener("click", () => {
          // Apply mobile search changes
          STATE.q = qMobile.value;
          q.value = qMobile.value;
          render();
          syncUrlToState();
          closeSheet();
        });

        // --- Search Palette event wiring (bd-24q.9.2) ---
        const spOverlay = document.getElementById("searchPaletteOverlay");
        const spInput = document.getElementById("searchPaletteInput");
        const spResultsEl = document.getElementById("searchPaletteResults");

        if (spOverlay) {
          spOverlay.addEventListener("click", (e) => {
            if (e.target === spOverlay) closeSearchPalette();
          });
        }

        if (spInput) {
          spInput.addEventListener("input", () => {
            clearTimeout(_spDebounce);
            _spDebounce = setTimeout(() => searchPaletteQuery(spInput.value), 180);
          });

          spInput.addEventListener("keydown", (e) => {
            if (e.key === "Escape") { e.preventDefault(); closeSearchPalette(); return; }
            if (e.key === "ArrowDown") { e.preventDefault(); spNavigate(1); return; }
            if (e.key === "ArrowUp") { e.preventDefault(); spNavigate(-1); return; }
            if (e.key === "Enter") { e.preventDefault(); selectSearchResult(_spActiveIdx); return; }
          });
        }

        if (spResultsEl) {
          spResultsEl.addEventListener("click", (e) => {
            const item = e.target.closest(".search-palette-item");
            if (!item) return;
            const idx = parseInt(item.dataset.spIdx, 10);
            if (!isNaN(idx)) selectSearchResult(idx);
          });
        }
      }

      function resetFilters() {
        STATE.q = "";
        STATE.minImpact = 0;
        STATE.bucketMode = "primary";
        STATE.bucketEnabled = new Set(BUCKETS.map((b) => b.id));

        document.getElementById("q").value = "";
        document.getElementById("qMobile").value = "";
        document.getElementById("impact").value = "0";
        document.getElementById("impactMobile").value = "0";
        document.getElementById("impactLabel").textContent = "0 lines";
        document.getElementById("impactLabelMobile").textContent = "0 lines";

        render();
      }

      // -----------------------------
      // Boot
      // -----------------------------

      window.addEventListener("resize", () => {
        chartTimeline?.resize();
        chartStack?.resize();
        chartDonut?.resize();
        chartBocpd?.resize();
        drawDock();
        renderHeatStripe();
      });

	      wireUI();
	      _wireHeatStripe();
	      _wireMiniMapMobile();
	      _wireStoryMobile();
	      lsCacheInit();
	      document.getElementById("btnCancelWarmup")?.addEventListener("click", () => { WARMUP_ABORT_CONTROLLER?.abort(); });
		      _wireOutlierPanel();
		      _wireClusterPanel();

		      (async function boot() {
		        await loadEvolutionDataset();
		        if (!DATASET.loaded || !DATASET.db) {
		          setWorkerStatus("Dataset load failed.", "error", DATASET.error || "");
		          const integrity = document.getElementById("kpiIntegrity");
		          if (integrity) integrity.textContent = "ERROR";
		          return;
		        }

		        WORKER_STATE.datasetHash = String(DATASET.meta?.db_hash || DB_STATE.cacheKey || "");
		        setWorkerStatus("DB loaded · worker idle (on-demand compute)", "neutral");

		        // Build commit list once so URL state clamping works.
		        ensureEnriched();

		        // Start at the latest commit (most interesting view).
		        DOC.idx = Math.max(0, ALL_COMMITS.length - 1);

		        // Restore state from URL if present; otherwise use defaults.
		        const urlState = decodeUrlState(location.search);
		        if (urlState) {
		          applyUrlState(urlState);
	          if (DOC.compareMode) {
	            populateCompareSelects();
	            const _b = document.getElementById("btnCompareToggle"); if (_b) { _b.classList.add("bg-slate-900","text-white"); _b.classList.remove("bg-white/70","text-slate-900"); }
	            const _r = document.getElementById("abCompareBar"); if (_r) _r.classList.remove("hidden");
	            const _l = document.getElementById("btnDiffLayout"); if (_l) { _l.classList.remove("hidden"); _l.textContent = DOC.diffLayout === "side-by-side" ? "Side-by-Side" : "Unified"; }
	          }
	        }

	        // Set tab (may have been overridden by URL state).
	        setDocTab(DOC.tab);
	        render();

		        // Record initial URL state (replaceState so back goes to referrer, not blank).
		        syncUrlToState({ immediate: true, replace: true });
		      })();

      // Browser back/forward: restore state from URL.
      window.addEventListener("popstate", () => {
        const s = decodeUrlState(location.search);
        if (s) {
          applyUrlState(s);
          // Restore compare UI elements.
          const cmpBtn = document.getElementById("btnCompareToggle");
          const cmpBar = document.getElementById("abCompareBar");
          const layoutBtn = document.getElementById("btnDiffLayout");
          if (cmpBtn) { cmpBtn.classList.toggle("bg-slate-900", DOC.compareMode); cmpBtn.classList.toggle("text-white", DOC.compareMode); cmpBtn.classList.toggle("bg-white/70", !DOC.compareMode); cmpBtn.classList.toggle("text-slate-900", !DOC.compareMode); }
          if (cmpBar) cmpBar.classList.toggle("hidden", !DOC.compareMode);
          if (layoutBtn) { layoutBtn.classList.toggle("hidden", !DOC.compareMode); if (DOC.compareMode) layoutBtn.textContent = DOC.diffLayout === "side-by-side" ? "Side-by-Side" : "Unified"; }
          const sbsRndBtn = document.getElementById("btnSbsRendered");
          if (sbsRndBtn) sbsRndBtn.classList.toggle("hidden", !DOC.compareMode);
          if (DOC.compareMode) { populateCompareSelects(); updateSbsButtonStyles(); }
          setDocTab(DOC.tab);
          selectCommitIdx(DOC.idx);
          render();
        }
      });
    </script>
  </body>
</html>
